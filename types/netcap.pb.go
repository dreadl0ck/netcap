// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: netcap.proto

// generated protocol buffer code will be put into the "types" package

package types

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Type int32

const (
	Type_NC_Header                      Type = 0
	Type_NC_Batch                       Type = 1
	Type_NC_Connection                  Type = 3
	Type_NC_Ethernet                    Type = 7
	Type_NC_ARP                         Type = 8
	Type_NC_Dot1Q                       Type = 9
	Type_NC_Dot11                       Type = 10
	Type_NC_Dot11QOS                    Type = 11
	Type_NC_Dot11HTControl              Type = 12
	Type_NC_Dot11HTControlVHT           Type = 13
	Type_NC_Dot11HTControlHT            Type = 14
	Type_NC_Dot11HTControlMFB           Type = 15
	Type_NC_Dot11LinkAdapationControl   Type = 16
	Type_NC_Dot11ASEL                   Type = 17
	Type_NC_LinkLayerDiscovery          Type = 18
	Type_NC_LLDPChassisID               Type = 19
	Type_NC_LLDPPortID                  Type = 20
	Type_NC_LinkLayerDiscoveryValue     Type = 21
	Type_NC_EthernetCTP                 Type = 22
	Type_NC_EthernetCTPReply            Type = 23
	Type_NC_LinkLayerDiscoveryInfo      Type = 24
	Type_NC_LLDPSysCapabilities         Type = 25
	Type_NC_LLDPCapabilities            Type = 26
	Type_NC_LLDPMgmtAddress             Type = 27
	Type_NC_LLDPOrgSpecificTLV          Type = 28
	Type_NC_IPv4                        Type = 29
	Type_NC_IPv4Option                  Type = 30
	Type_NC_IPv6                        Type = 31
	Type_NC_ICMPv4                      Type = 32
	Type_NC_ICMPv6                      Type = 33
	Type_NC_ICMPv6NeighborAdvertisement Type = 34
	Type_NC_ICMPv6RouterAdvertisement   Type = 35
	Type_NC_ICMPv6Option                Type = 36
	Type_NC_UDP                         Type = 37
	Type_NC_TCP                         Type = 38
	Type_NC_TCPOption                   Type = 39
	Type_NC_SCTP                        Type = 40
	Type_NC_DNS                         Type = 41
	Type_NC_DNSResourceRecord           Type = 42
	Type_NC_DNSSOA                      Type = 43
	Type_NC_DNSSRV                      Type = 44
	Type_NC_DNSMX                       Type = 45
	Type_NC_DNSQuestion                 Type = 46
	Type_NC_DHCPv4                      Type = 47
	Type_NC_DHCPOption                  Type = 48
	Type_NC_DHCPv6                      Type = 49
	Type_NC_DHCPv6Option                Type = 50
	Type_NC_LLC                         Type = 51
	Type_NC_NTP                         Type = 52
	Type_NC_SIP                         Type = 53
	Type_NC_IGMP                        Type = 54
	Type_NC_IGMPv3GroupRecord           Type = 55
	Type_NC_IPv6HopByHop                Type = 56
	Type_NC_IPv6HopByHopOption          Type = 57
	Type_NC_IPv6HopByHopOptionAlignment Type = 58
	Type_NC_SNAP                        Type = 59
	Type_NC_ICMPv6Echo                  Type = 60
	Type_NC_ICMPv6NeighborSolicitation  Type = 61
	Type_NC_ICMPv6RouterSolicitation    Type = 62
	Type_NC_HTTP                        Type = 63
	Type_NC_TLSClientHello              Type = 64
	Type_NC_IPSecAH                     Type = 65
	Type_NC_IPSecESP                    Type = 66
	Type_NC_Geneve                      Type = 67
	Type_NC_IPv6Fragment                Type = 68
	Type_NC_VXLAN                       Type = 69
	Type_NC_USB                         Type = 70
	Type_NC_LCM                         Type = 71
	Type_NC_MPLS                        Type = 72
	Type_NC_Modbus                      Type = 73
	Type_NC_OSPFv2                      Type = 74
	Type_NC_OSPFv3                      Type = 75
	Type_NC_BFD                         Type = 76
	Type_NC_GRE                         Type = 77
	Type_NC_FDDI                        Type = 78
	Type_NC_EAP                         Type = 79
	Type_NC_VRRPv2                      Type = 80
	Type_NC_EAPOL                       Type = 81
	Type_NC_EAPOLKey                    Type = 82
	Type_NC_CiscoDiscovery              Type = 83
	Type_NC_CiscoDiscoveryInfo          Type = 84
	Type_NC_USBRequestBlockSetup        Type = 85
	Type_NC_NortelDiscovery             Type = 86
	Type_NC_CIP                         Type = 87
	Type_NC_ENIP                        Type = 88
	Type_NC_DeviceProfile               Type = 89
	Type_NC_File                        Type = 90
	Type_NC_SMTP                        Type = 91
	Type_NC_Diameter                    Type = 92
	Type_NC_POP3                        Type = 93
	Type_NC_TLSServerHello              Type = 94
	Type_NC_Software                    Type = 95
	Type_NC_Service                     Type = 96
	Type_NC_Credentials                 Type = 97
	Type_NC_SSH                         Type = 98
	Type_NC_Vulnerability               Type = 99
	Type_NC_Exploit                     Type = 100
	Type_NC_IPProfile                   Type = 101
	Type_NC_Mail                        Type = 102
	Type_NC_Alert                       Type = 103
)

var Type_name = map[int32]string{
	0:   "NC_Header",
	1:   "NC_Batch",
	3:   "NC_Connection",
	7:   "NC_Ethernet",
	8:   "NC_ARP",
	9:   "NC_Dot1Q",
	10:  "NC_Dot11",
	11:  "NC_Dot11QOS",
	12:  "NC_Dot11HTControl",
	13:  "NC_Dot11HTControlVHT",
	14:  "NC_Dot11HTControlHT",
	15:  "NC_Dot11HTControlMFB",
	16:  "NC_Dot11LinkAdapationControl",
	17:  "NC_Dot11ASEL",
	18:  "NC_LinkLayerDiscovery",
	19:  "NC_LLDPChassisID",
	20:  "NC_LLDPPortID",
	21:  "NC_LinkLayerDiscoveryValue",
	22:  "NC_EthernetCTP",
	23:  "NC_EthernetCTPReply",
	24:  "NC_LinkLayerDiscoveryInfo",
	25:  "NC_LLDPSysCapabilities",
	26:  "NC_LLDPCapabilities",
	27:  "NC_LLDPMgmtAddress",
	28:  "NC_LLDPOrgSpecificTLV",
	29:  "NC_IPv4",
	30:  "NC_IPv4Option",
	31:  "NC_IPv6",
	32:  "NC_ICMPv4",
	33:  "NC_ICMPv6",
	34:  "NC_ICMPv6NeighborAdvertisement",
	35:  "NC_ICMPv6RouterAdvertisement",
	36:  "NC_ICMPv6Option",
	37:  "NC_UDP",
	38:  "NC_TCP",
	39:  "NC_TCPOption",
	40:  "NC_SCTP",
	41:  "NC_DNS",
	42:  "NC_DNSResourceRecord",
	43:  "NC_DNSSOA",
	44:  "NC_DNSSRV",
	45:  "NC_DNSMX",
	46:  "NC_DNSQuestion",
	47:  "NC_DHCPv4",
	48:  "NC_DHCPOption",
	49:  "NC_DHCPv6",
	50:  "NC_DHCPv6Option",
	51:  "NC_LLC",
	52:  "NC_NTP",
	53:  "NC_SIP",
	54:  "NC_IGMP",
	55:  "NC_IGMPv3GroupRecord",
	56:  "NC_IPv6HopByHop",
	57:  "NC_IPv6HopByHopOption",
	58:  "NC_IPv6HopByHopOptionAlignment",
	59:  "NC_SNAP",
	60:  "NC_ICMPv6Echo",
	61:  "NC_ICMPv6NeighborSolicitation",
	62:  "NC_ICMPv6RouterSolicitation",
	63:  "NC_HTTP",
	64:  "NC_TLSClientHello",
	65:  "NC_IPSecAH",
	66:  "NC_IPSecESP",
	67:  "NC_Geneve",
	68:  "NC_IPv6Fragment",
	69:  "NC_VXLAN",
	70:  "NC_USB",
	71:  "NC_LCM",
	72:  "NC_MPLS",
	73:  "NC_Modbus",
	74:  "NC_OSPFv2",
	75:  "NC_OSPFv3",
	76:  "NC_BFD",
	77:  "NC_GRE",
	78:  "NC_FDDI",
	79:  "NC_EAP",
	80:  "NC_VRRPv2",
	81:  "NC_EAPOL",
	82:  "NC_EAPOLKey",
	83:  "NC_CiscoDiscovery",
	84:  "NC_CiscoDiscoveryInfo",
	85:  "NC_USBRequestBlockSetup",
	86:  "NC_NortelDiscovery",
	87:  "NC_CIP",
	88:  "NC_ENIP",
	89:  "NC_DeviceProfile",
	90:  "NC_File",
	91:  "NC_SMTP",
	92:  "NC_Diameter",
	93:  "NC_POP3",
	94:  "NC_TLSServerHello",
	95:  "NC_Software",
	96:  "NC_Service",
	97:  "NC_Credentials",
	98:  "NC_SSH",
	99:  "NC_Vulnerability",
	100: "NC_Exploit",
	101: "NC_IPProfile",
	102: "NC_Mail",
	103: "NC_Alert",
}

var Type_value = map[string]int32{
	"NC_Header":                      0,
	"NC_Batch":                       1,
	"NC_Connection":                  3,
	"NC_Ethernet":                    7,
	"NC_ARP":                         8,
	"NC_Dot1Q":                       9,
	"NC_Dot11":                       10,
	"NC_Dot11QOS":                    11,
	"NC_Dot11HTControl":              12,
	"NC_Dot11HTControlVHT":           13,
	"NC_Dot11HTControlHT":            14,
	"NC_Dot11HTControlMFB":           15,
	"NC_Dot11LinkAdapationControl":   16,
	"NC_Dot11ASEL":                   17,
	"NC_LinkLayerDiscovery":          18,
	"NC_LLDPChassisID":               19,
	"NC_LLDPPortID":                  20,
	"NC_LinkLayerDiscoveryValue":     21,
	"NC_EthernetCTP":                 22,
	"NC_EthernetCTPReply":            23,
	"NC_LinkLayerDiscoveryInfo":      24,
	"NC_LLDPSysCapabilities":         25,
	"NC_LLDPCapabilities":            26,
	"NC_LLDPMgmtAddress":             27,
	"NC_LLDPOrgSpecificTLV":          28,
	"NC_IPv4":                        29,
	"NC_IPv4Option":                  30,
	"NC_IPv6":                        31,
	"NC_ICMPv4":                      32,
	"NC_ICMPv6":                      33,
	"NC_ICMPv6NeighborAdvertisement": 34,
	"NC_ICMPv6RouterAdvertisement":   35,
	"NC_ICMPv6Option":                36,
	"NC_UDP":                         37,
	"NC_TCP":                         38,
	"NC_TCPOption":                   39,
	"NC_SCTP":                        40,
	"NC_DNS":                         41,
	"NC_DNSResourceRecord":           42,
	"NC_DNSSOA":                      43,
	"NC_DNSSRV":                      44,
	"NC_DNSMX":                       45,
	"NC_DNSQuestion":                 46,
	"NC_DHCPv4":                      47,
	"NC_DHCPOption":                  48,
	"NC_DHCPv6":                      49,
	"NC_DHCPv6Option":                50,
	"NC_LLC":                         51,
	"NC_NTP":                         52,
	"NC_SIP":                         53,
	"NC_IGMP":                        54,
	"NC_IGMPv3GroupRecord":           55,
	"NC_IPv6HopByHop":                56,
	"NC_IPv6HopByHopOption":          57,
	"NC_IPv6HopByHopOptionAlignment": 58,
	"NC_SNAP":                        59,
	"NC_ICMPv6Echo":                  60,
	"NC_ICMPv6NeighborSolicitation":  61,
	"NC_ICMPv6RouterSolicitation":    62,
	"NC_HTTP":                        63,
	"NC_TLSClientHello":              64,
	"NC_IPSecAH":                     65,
	"NC_IPSecESP":                    66,
	"NC_Geneve":                      67,
	"NC_IPv6Fragment":                68,
	"NC_VXLAN":                       69,
	"NC_USB":                         70,
	"NC_LCM":                         71,
	"NC_MPLS":                        72,
	"NC_Modbus":                      73,
	"NC_OSPFv2":                      74,
	"NC_OSPFv3":                      75,
	"NC_BFD":                         76,
	"NC_GRE":                         77,
	"NC_FDDI":                        78,
	"NC_EAP":                         79,
	"NC_VRRPv2":                      80,
	"NC_EAPOL":                       81,
	"NC_EAPOLKey":                    82,
	"NC_CiscoDiscovery":              83,
	"NC_CiscoDiscoveryInfo":          84,
	"NC_USBRequestBlockSetup":        85,
	"NC_NortelDiscovery":             86,
	"NC_CIP":                         87,
	"NC_ENIP":                        88,
	"NC_DeviceProfile":               89,
	"NC_File":                        90,
	"NC_SMTP":                        91,
	"NC_Diameter":                    92,
	"NC_POP3":                        93,
	"NC_TLSServerHello":              94,
	"NC_Software":                    95,
	"NC_Service":                     96,
	"NC_Credentials":                 97,
	"NC_SSH":                         98,
	"NC_Vulnerability":               99,
	"NC_Exploit":                     100,
	"NC_IPProfile":                   101,
	"NC_Mail":                        102,
	"NC_Alert":                       103,
}

func (x Type) String() string {
	return proto.EnumName(Type_name, int32(x))
}

func (Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{0}
}

type Header struct {
	Created          int64  `protobuf:"varint,1,opt,name=Created,proto3" json:"Created,omitempty"`
	InputSource      string `protobuf:"bytes,2,opt,name=InputSource,proto3" json:"InputSource,omitempty"`
	Type             Type   `protobuf:"varint,3,opt,name=Type,proto3,enum=types.Type" json:"Type,omitempty"`
	Version          string `protobuf:"bytes,4,opt,name=Version,proto3" json:"Version,omitempty"`
	ContainsPayloads bool   `protobuf:"varint,5,opt,name=ContainsPayloads,proto3" json:"ContainsPayloads,omitempty"`
}

func (m *Header) Reset()         { *m = Header{} }
func (m *Header) String() string { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()    {}
func (*Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{0}
}
func (m *Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Header.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Header.Merge(m, src)
}
func (m *Header) XXX_Size() int {
	return m.Size()
}
func (m *Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Header.DiscardUnknown(m)
}

var xxx_messageInfo_Header proto.InternalMessageInfo

func (m *Header) GetCreated() int64 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *Header) GetInputSource() string {
	if m != nil {
		return m.InputSource
	}
	return ""
}

func (m *Header) GetType() Type {
	if m != nil {
		return m.Type
	}
	return Type_NC_Header
}

func (m *Header) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Header) GetContainsPayloads() bool {
	if m != nil {
		return m.ContainsPayloads
	}
	return false
}

type Batch struct {
	ClientID         string `protobuf:"bytes,1,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	MessageType      Type   `protobuf:"varint,2,opt,name=MessageType,proto3,enum=types.Type" json:"MessageType,omitempty"`
	TotalSize        int32  `protobuf:"varint,3,opt,name=TotalSize,proto3" json:"TotalSize,omitempty"`
	Data             []byte `protobuf:"bytes,4,opt,name=Data,proto3" json:"Data,omitempty"`
	ContainsPayloads bool   `protobuf:"varint,5,opt,name=ContainsPayloads,proto3" json:"ContainsPayloads,omitempty"`
}

func (m *Batch) Reset()         { *m = Batch{} }
func (m *Batch) String() string { return proto.CompactTextString(m) }
func (*Batch) ProtoMessage()    {}
func (*Batch) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{1}
}
func (m *Batch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Batch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Batch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Batch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Batch.Merge(m, src)
}
func (m *Batch) XXX_Size() int {
	return m.Size()
}
func (m *Batch) XXX_DiscardUnknown() {
	xxx_messageInfo_Batch.DiscardUnknown(m)
}

var xxx_messageInfo_Batch proto.InternalMessageInfo

func (m *Batch) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *Batch) GetMessageType() Type {
	if m != nil {
		return m.MessageType
	}
	return Type_NC_Header
}

func (m *Batch) GetTotalSize() int32 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

func (m *Batch) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Batch) GetContainsPayloads() bool {
	if m != nil {
		return m.ContainsPayloads
	}
	return false
}

type PacketContext struct {
	SrcIP   string `protobuf:"bytes,1,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP   string `protobuf:"bytes,2,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
	SrcPort int32  `protobuf:"varint,3,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	DstPort int32  `protobuf:"varint,4,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
}

func (m *PacketContext) Reset()         { *m = PacketContext{} }
func (m *PacketContext) String() string { return proto.CompactTextString(m) }
func (*PacketContext) ProtoMessage()    {}
func (*PacketContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{2}
}
func (m *PacketContext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PacketContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PacketContext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PacketContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PacketContext.Merge(m, src)
}
func (m *PacketContext) XXX_Size() int {
	return m.Size()
}
func (m *PacketContext) XXX_DiscardUnknown() {
	xxx_messageInfo_PacketContext.DiscardUnknown(m)
}

var xxx_messageInfo_PacketContext proto.InternalMessageInfo

func (m *PacketContext) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *PacketContext) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

func (m *PacketContext) GetSrcPort() int32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *PacketContext) GetDstPort() int32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

// a connection has the following attributes:
// Mac <-> Mac bidirectional Mac
// IP <-> IP bidirectional IP
// Port <-> Port bidirectional Port
type Connection struct {
	TimestampFirst      int64  `protobuf:"varint,1,opt,name=TimestampFirst,proto3" json:"TimestampFirst,omitempty"`
	LinkProto           string `protobuf:"bytes,2,opt,name=LinkProto,proto3" json:"LinkProto,omitempty"`
	NetworkProto        string `protobuf:"bytes,3,opt,name=NetworkProto,proto3" json:"NetworkProto,omitempty"`
	TransportProto      string `protobuf:"bytes,4,opt,name=TransportProto,proto3" json:"TransportProto,omitempty"`
	ApplicationProto    string `protobuf:"bytes,5,opt,name=ApplicationProto,proto3" json:"ApplicationProto,omitempty"`
	SrcMAC              string `protobuf:"bytes,6,opt,name=SrcMAC,proto3" json:"SrcMAC,omitempty"`
	DstMAC              string `protobuf:"bytes,7,opt,name=DstMAC,proto3" json:"DstMAC,omitempty"`
	SrcIP               string `protobuf:"bytes,8,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	SrcPort             string `protobuf:"bytes,9,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	DstIP               string `protobuf:"bytes,10,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
	DstPort             string `protobuf:"bytes,11,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
	TotalSize           int32  `protobuf:"varint,12,opt,name=TotalSize,proto3" json:"TotalSize,omitempty"`
	AppPayloadSize      int32  `protobuf:"varint,13,opt,name=AppPayloadSize,proto3" json:"AppPayloadSize,omitempty"`
	NumPackets          int32  `protobuf:"varint,14,opt,name=NumPackets,proto3" json:"NumPackets,omitempty"`
	UID                 string `protobuf:"bytes,15,opt,name=UID,proto3" json:"UID,omitempty"`
	TimestampLast       int64  `protobuf:"varint,16,opt,name=TimestampLast,proto3" json:"TimestampLast,omitempty"`
	Duration            int64  `protobuf:"varint,17,opt,name=Duration,proto3" json:"Duration,omitempty"`
	BytesServerToClient int64  `protobuf:"varint,18,opt,name=BytesServerToClient,proto3" json:"BytesServerToClient,omitempty"`
	BytesClientToServer int64  `protobuf:"varint,19,opt,name=BytesClientToServer,proto3" json:"BytesClientToServer,omitempty"`
	// tcp flags
	NumFINFlags int32 `protobuf:"varint,20,opt,name=NumFINFlags,proto3" json:"NumFINFlags,omitempty"`
	NumRSTFlags int32 `protobuf:"varint,21,opt,name=NumRSTFlags,proto3" json:"NumRSTFlags,omitempty"`
	NumACKFlags int32 `protobuf:"varint,22,opt,name=NumACKFlags,proto3" json:"NumACKFlags,omitempty"`
	NumSYNFlags int32 `protobuf:"varint,23,opt,name=NumSYNFlags,proto3" json:"NumSYNFlags,omitempty"`
	NumURGFlags int32 `protobuf:"varint,24,opt,name=NumURGFlags,proto3" json:"NumURGFlags,omitempty"`
	NumECEFlags int32 `protobuf:"varint,25,opt,name=NumECEFlags,proto3" json:"NumECEFlags,omitempty"`
	NumPSHFlags int32 `protobuf:"varint,26,opt,name=NumPSHFlags,proto3" json:"NumPSHFlags,omitempty"`
	NumCWRFlags int32 `protobuf:"varint,27,opt,name=NumCWRFlags,proto3" json:"NumCWRFlags,omitempty"`
	NumNSFlags  int32 `protobuf:"varint,28,opt,name=NumNSFlags,proto3" json:"NumNSFlags,omitempty"`
	// tcp window size
	MeanWindowSize int32 `protobuf:"varint,29,opt,name=MeanWindowSize,proto3" json:"MeanWindowSize,omitempty"`
}

func (m *Connection) Reset()         { *m = Connection{} }
func (m *Connection) String() string { return proto.CompactTextString(m) }
func (*Connection) ProtoMessage()    {}
func (*Connection) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{3}
}
func (m *Connection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Connection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Connection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Connection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Connection.Merge(m, src)
}
func (m *Connection) XXX_Size() int {
	return m.Size()
}
func (m *Connection) XXX_DiscardUnknown() {
	xxx_messageInfo_Connection.DiscardUnknown(m)
}

var xxx_messageInfo_Connection proto.InternalMessageInfo

func (m *Connection) GetTimestampFirst() int64 {
	if m != nil {
		return m.TimestampFirst
	}
	return 0
}

func (m *Connection) GetLinkProto() string {
	if m != nil {
		return m.LinkProto
	}
	return ""
}

func (m *Connection) GetNetworkProto() string {
	if m != nil {
		return m.NetworkProto
	}
	return ""
}

func (m *Connection) GetTransportProto() string {
	if m != nil {
		return m.TransportProto
	}
	return ""
}

func (m *Connection) GetApplicationProto() string {
	if m != nil {
		return m.ApplicationProto
	}
	return ""
}

func (m *Connection) GetSrcMAC() string {
	if m != nil {
		return m.SrcMAC
	}
	return ""
}

func (m *Connection) GetDstMAC() string {
	if m != nil {
		return m.DstMAC
	}
	return ""
}

func (m *Connection) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *Connection) GetSrcPort() string {
	if m != nil {
		return m.SrcPort
	}
	return ""
}

func (m *Connection) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

func (m *Connection) GetDstPort() string {
	if m != nil {
		return m.DstPort
	}
	return ""
}

func (m *Connection) GetTotalSize() int32 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

func (m *Connection) GetAppPayloadSize() int32 {
	if m != nil {
		return m.AppPayloadSize
	}
	return 0
}

func (m *Connection) GetNumPackets() int32 {
	if m != nil {
		return m.NumPackets
	}
	return 0
}

func (m *Connection) GetUID() string {
	if m != nil {
		return m.UID
	}
	return ""
}

func (m *Connection) GetTimestampLast() int64 {
	if m != nil {
		return m.TimestampLast
	}
	return 0
}

func (m *Connection) GetDuration() int64 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *Connection) GetBytesServerToClient() int64 {
	if m != nil {
		return m.BytesServerToClient
	}
	return 0
}

func (m *Connection) GetBytesClientToServer() int64 {
	if m != nil {
		return m.BytesClientToServer
	}
	return 0
}

func (m *Connection) GetNumFINFlags() int32 {
	if m != nil {
		return m.NumFINFlags
	}
	return 0
}

func (m *Connection) GetNumRSTFlags() int32 {
	if m != nil {
		return m.NumRSTFlags
	}
	return 0
}

func (m *Connection) GetNumACKFlags() int32 {
	if m != nil {
		return m.NumACKFlags
	}
	return 0
}

func (m *Connection) GetNumSYNFlags() int32 {
	if m != nil {
		return m.NumSYNFlags
	}
	return 0
}

func (m *Connection) GetNumURGFlags() int32 {
	if m != nil {
		return m.NumURGFlags
	}
	return 0
}

func (m *Connection) GetNumECEFlags() int32 {
	if m != nil {
		return m.NumECEFlags
	}
	return 0
}

func (m *Connection) GetNumPSHFlags() int32 {
	if m != nil {
		return m.NumPSHFlags
	}
	return 0
}

func (m *Connection) GetNumCWRFlags() int32 {
	if m != nil {
		return m.NumCWRFlags
	}
	return 0
}

func (m *Connection) GetNumNSFlags() int32 {
	if m != nil {
		return m.NumNSFlags
	}
	return 0
}

func (m *Connection) GetMeanWindowSize() int32 {
	if m != nil {
		return m.MeanWindowSize
	}
	return 0
}

// Ethernet is a family of computer networking technologies commonly used in local area networks (LAN), metropolitan area networks (MAN) and wide area networks (WAN).
// It was commercially introduced in 1980 and first standardized in 1983 as IEEE 802.3.
// Ethernet has since retained a good deal of backward compatibility and has been refined to support higher bit rates, a greater number of nodes, and longer link distances.
// Over time, Ethernet has largely replaced competing wired LAN technologies such as Token Ring, FDDI and ARCNET.
type Ethernet struct {
	Timestamp      int64   `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	SrcMAC         string  `protobuf:"bytes,2,opt,name=SrcMAC,proto3" json:"SrcMAC,omitempty"`
	DstMAC         string  `protobuf:"bytes,3,opt,name=DstMAC,proto3" json:"DstMAC,omitempty"`
	EthernetType   int32   `protobuf:"varint,4,opt,name=EthernetType,proto3" json:"EthernetType,omitempty"`
	PayloadEntropy float64 `protobuf:"fixed64,5,opt,name=PayloadEntropy,proto3" json:"PayloadEntropy,omitempty"`
	PayloadSize    int32   `protobuf:"varint,6,opt,name=PayloadSize,proto3" json:"PayloadSize,omitempty"`
}

func (m *Ethernet) Reset()         { *m = Ethernet{} }
func (m *Ethernet) String() string { return proto.CompactTextString(m) }
func (*Ethernet) ProtoMessage()    {}
func (*Ethernet) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{4}
}
func (m *Ethernet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ethernet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ethernet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Ethernet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ethernet.Merge(m, src)
}
func (m *Ethernet) XXX_Size() int {
	return m.Size()
}
func (m *Ethernet) XXX_DiscardUnknown() {
	xxx_messageInfo_Ethernet.DiscardUnknown(m)
}

var xxx_messageInfo_Ethernet proto.InternalMessageInfo

func (m *Ethernet) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Ethernet) GetSrcMAC() string {
	if m != nil {
		return m.SrcMAC
	}
	return ""
}

func (m *Ethernet) GetDstMAC() string {
	if m != nil {
		return m.DstMAC
	}
	return ""
}

func (m *Ethernet) GetEthernetType() int32 {
	if m != nil {
		return m.EthernetType
	}
	return 0
}

func (m *Ethernet) GetPayloadEntropy() float64 {
	if m != nil {
		return m.PayloadEntropy
	}
	return 0
}

func (m *Ethernet) GetPayloadSize() int32 {
	if m != nil {
		return m.PayloadSize
	}
	return 0
}

// The Address Resolution Protocol (ARP) is a communication protocol used for discovering the link layer address,
// such as a MAC address, associated with a given internet layer address, typically an IPv4 address.
type ARP struct {
	Timestamp           int64  `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	AddrType            int32  `protobuf:"varint,2,opt,name=AddrType,proto3" json:"AddrType,omitempty"`
	Protocol            int32  `protobuf:"varint,3,opt,name=Protocol,proto3" json:"Protocol,omitempty"`
	HwAddressSize       int32  `protobuf:"varint,4,opt,name=HwAddressSize,proto3" json:"HwAddressSize,omitempty"`
	ProtocolAddressSize int32  `protobuf:"varint,5,opt,name=ProtocolAddressSize,proto3" json:"ProtocolAddressSize,omitempty"`
	Operation           int32  `protobuf:"varint,6,opt,name=Operation,proto3" json:"Operation,omitempty"`
	SrcHwAddress        string `protobuf:"bytes,7,opt,name=SrcHwAddress,proto3" json:"SrcHwAddress,omitempty"`
	// Sender Protocol Address: The IP address of the device sending this message
	SrcProtocolAddress string `protobuf:"bytes,8,opt,name=SrcProtocolAddress,proto3" json:"SrcProtocolAddress,omitempty"`
	DstHwAddress       string `protobuf:"bytes,9,opt,name=DstHwAddress,proto3" json:"DstHwAddress,omitempty"`
	DstProtocolAddress string `protobuf:"bytes,10,opt,name=DstProtocolAddress,proto3" json:"DstProtocolAddress,omitempty"`
}

func (m *ARP) Reset()         { *m = ARP{} }
func (m *ARP) String() string { return proto.CompactTextString(m) }
func (*ARP) ProtoMessage()    {}
func (*ARP) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{5}
}
func (m *ARP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ARP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ARP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ARP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ARP.Merge(m, src)
}
func (m *ARP) XXX_Size() int {
	return m.Size()
}
func (m *ARP) XXX_DiscardUnknown() {
	xxx_messageInfo_ARP.DiscardUnknown(m)
}

var xxx_messageInfo_ARP proto.InternalMessageInfo

func (m *ARP) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *ARP) GetAddrType() int32 {
	if m != nil {
		return m.AddrType
	}
	return 0
}

func (m *ARP) GetProtocol() int32 {
	if m != nil {
		return m.Protocol
	}
	return 0
}

func (m *ARP) GetHwAddressSize() int32 {
	if m != nil {
		return m.HwAddressSize
	}
	return 0
}

func (m *ARP) GetProtocolAddressSize() int32 {
	if m != nil {
		return m.ProtocolAddressSize
	}
	return 0
}

func (m *ARP) GetOperation() int32 {
	if m != nil {
		return m.Operation
	}
	return 0
}

func (m *ARP) GetSrcHwAddress() string {
	if m != nil {
		return m.SrcHwAddress
	}
	return ""
}

func (m *ARP) GetSrcProtocolAddress() string {
	if m != nil {
		return m.SrcProtocolAddress
	}
	return ""
}

func (m *ARP) GetDstHwAddress() string {
	if m != nil {
		return m.DstHwAddress
	}
	return ""
}

func (m *ARP) GetDstProtocolAddress() string {
	if m != nil {
		return m.DstProtocolAddress
	}
	return ""
}

// Dot1Q is the packet layer for 802.1Q VLAN headers.
type Dot1Q struct {
	Timestamp      int64 `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Priority       int32 `protobuf:"varint,2,opt,name=Priority,proto3" json:"Priority,omitempty"`
	DropEligible   bool  `protobuf:"varint,3,opt,name=DropEligible,proto3" json:"DropEligible,omitempty"`
	VLANIdentifier int32 `protobuf:"varint,4,opt,name=VLANIdentifier,proto3" json:"VLANIdentifier,omitempty"`
	Type           int32 `protobuf:"varint,5,opt,name=Type,proto3" json:"Type,omitempty"`
}

func (m *Dot1Q) Reset()         { *m = Dot1Q{} }
func (m *Dot1Q) String() string { return proto.CompactTextString(m) }
func (*Dot1Q) ProtoMessage()    {}
func (*Dot1Q) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{6}
}
func (m *Dot1Q) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dot1Q) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Dot1Q.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Dot1Q) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dot1Q.Merge(m, src)
}
func (m *Dot1Q) XXX_Size() int {
	return m.Size()
}
func (m *Dot1Q) XXX_DiscardUnknown() {
	xxx_messageInfo_Dot1Q.DiscardUnknown(m)
}

var xxx_messageInfo_Dot1Q proto.InternalMessageInfo

func (m *Dot1Q) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Dot1Q) GetPriority() int32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *Dot1Q) GetDropEligible() bool {
	if m != nil {
		return m.DropEligible
	}
	return false
}

func (m *Dot1Q) GetVLANIdentifier() int32 {
	if m != nil {
		return m.VLANIdentifier
	}
	return 0
}

func (m *Dot1Q) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

// Dot11 provides an IEEE 802.11 base packet header.
// See http://standards.ieee.org/findstds/standard/802.11-2012.html for excruciating detail.
type Dot11 struct {
	Timestamp      int64           `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Type           int32           `protobuf:"varint,2,opt,name=Type,proto3" json:"Type,omitempty"`
	Proto          int32           `protobuf:"varint,3,opt,name=Proto,proto3" json:"Proto,omitempty"`
	Flags          int32           `protobuf:"varint,4,opt,name=Flags,proto3" json:"Flags,omitempty"`
	DurationID     int32           `protobuf:"varint,5,opt,name=DurationID,proto3" json:"DurationID,omitempty"`
	Address1       string          `protobuf:"bytes,6,opt,name=Address1,proto3" json:"Address1,omitempty"`
	Address2       string          `protobuf:"bytes,7,opt,name=Address2,proto3" json:"Address2,omitempty"`
	Address3       string          `protobuf:"bytes,8,opt,name=Address3,proto3" json:"Address3,omitempty"`
	Address4       string          `protobuf:"bytes,9,opt,name=Address4,proto3" json:"Address4,omitempty"`
	SequenceNumber int32           `protobuf:"varint,10,opt,name=SequenceNumber,proto3" json:"SequenceNumber,omitempty"`
	FragmentNumber int32           `protobuf:"varint,11,opt,name=FragmentNumber,proto3" json:"FragmentNumber,omitempty"`
	Checksum       uint32          `protobuf:"varint,12,opt,name=Checksum,proto3" json:"Checksum,omitempty"`
	QOS            *Dot11QOS       `protobuf:"bytes,13,opt,name=QOS,proto3" json:"QOS,omitempty"`
	HTControl      *Dot11HTControl `protobuf:"bytes,14,opt,name=HTControl,proto3" json:"HTControl,omitempty"`
}

func (m *Dot11) Reset()         { *m = Dot11{} }
func (m *Dot11) String() string { return proto.CompactTextString(m) }
func (*Dot11) ProtoMessage()    {}
func (*Dot11) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{7}
}
func (m *Dot11) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dot11) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Dot11.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Dot11) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dot11.Merge(m, src)
}
func (m *Dot11) XXX_Size() int {
	return m.Size()
}
func (m *Dot11) XXX_DiscardUnknown() {
	xxx_messageInfo_Dot11.DiscardUnknown(m)
}

var xxx_messageInfo_Dot11 proto.InternalMessageInfo

func (m *Dot11) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Dot11) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Dot11) GetProto() int32 {
	if m != nil {
		return m.Proto
	}
	return 0
}

func (m *Dot11) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *Dot11) GetDurationID() int32 {
	if m != nil {
		return m.DurationID
	}
	return 0
}

func (m *Dot11) GetAddress1() string {
	if m != nil {
		return m.Address1
	}
	return ""
}

func (m *Dot11) GetAddress2() string {
	if m != nil {
		return m.Address2
	}
	return ""
}

func (m *Dot11) GetAddress3() string {
	if m != nil {
		return m.Address3
	}
	return ""
}

func (m *Dot11) GetAddress4() string {
	if m != nil {
		return m.Address4
	}
	return ""
}

func (m *Dot11) GetSequenceNumber() int32 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *Dot11) GetFragmentNumber() int32 {
	if m != nil {
		return m.FragmentNumber
	}
	return 0
}

func (m *Dot11) GetChecksum() uint32 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

func (m *Dot11) GetQOS() *Dot11QOS {
	if m != nil {
		return m.QOS
	}
	return nil
}

func (m *Dot11) GetHTControl() *Dot11HTControl {
	if m != nil {
		return m.HTControl
	}
	return nil
}

type Dot11QOS struct {
	TID       int32 `protobuf:"varint,1,opt,name=TID,proto3" json:"TID,omitempty"`
	EOSP      bool  `protobuf:"varint,2,opt,name=EOSP,proto3" json:"EOSP,omitempty"`
	AckPolicy int32 `protobuf:"varint,3,opt,name=AckPolicy,proto3" json:"AckPolicy,omitempty"`
	TXOP      int32 `protobuf:"varint,4,opt,name=TXOP,proto3" json:"TXOP,omitempty"`
}

func (m *Dot11QOS) Reset()         { *m = Dot11QOS{} }
func (m *Dot11QOS) String() string { return proto.CompactTextString(m) }
func (*Dot11QOS) ProtoMessage()    {}
func (*Dot11QOS) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{8}
}
func (m *Dot11QOS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dot11QOS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Dot11QOS.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Dot11QOS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dot11QOS.Merge(m, src)
}
func (m *Dot11QOS) XXX_Size() int {
	return m.Size()
}
func (m *Dot11QOS) XXX_DiscardUnknown() {
	xxx_messageInfo_Dot11QOS.DiscardUnknown(m)
}

var xxx_messageInfo_Dot11QOS proto.InternalMessageInfo

func (m *Dot11QOS) GetTID() int32 {
	if m != nil {
		return m.TID
	}
	return 0
}

func (m *Dot11QOS) GetEOSP() bool {
	if m != nil {
		return m.EOSP
	}
	return false
}

func (m *Dot11QOS) GetAckPolicy() int32 {
	if m != nil {
		return m.AckPolicy
	}
	return 0
}

func (m *Dot11QOS) GetTXOP() int32 {
	if m != nil {
		return m.TXOP
	}
	return 0
}

type Dot11HTControl struct {
	ACConstraint bool               `protobuf:"varint,1,opt,name=ACConstraint,proto3" json:"ACConstraint,omitempty"`
	RDGMorePPDU  bool               `protobuf:"varint,2,opt,name=RDGMorePPDU,proto3" json:"RDGMorePPDU,omitempty"`
	VHT          *Dot11HTControlVHT `protobuf:"bytes,3,opt,name=VHT,proto3" json:"VHT,omitempty"`
	HT           *Dot11HTControlHT  `protobuf:"bytes,4,opt,name=HT,proto3" json:"HT,omitempty"`
}

func (m *Dot11HTControl) Reset()         { *m = Dot11HTControl{} }
func (m *Dot11HTControl) String() string { return proto.CompactTextString(m) }
func (*Dot11HTControl) ProtoMessage()    {}
func (*Dot11HTControl) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{9}
}
func (m *Dot11HTControl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dot11HTControl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Dot11HTControl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Dot11HTControl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dot11HTControl.Merge(m, src)
}
func (m *Dot11HTControl) XXX_Size() int {
	return m.Size()
}
func (m *Dot11HTControl) XXX_DiscardUnknown() {
	xxx_messageInfo_Dot11HTControl.DiscardUnknown(m)
}

var xxx_messageInfo_Dot11HTControl proto.InternalMessageInfo

func (m *Dot11HTControl) GetACConstraint() bool {
	if m != nil {
		return m.ACConstraint
	}
	return false
}

func (m *Dot11HTControl) GetRDGMorePPDU() bool {
	if m != nil {
		return m.RDGMorePPDU
	}
	return false
}

func (m *Dot11HTControl) GetVHT() *Dot11HTControlVHT {
	if m != nil {
		return m.VHT
	}
	return nil
}

func (m *Dot11HTControl) GetHT() *Dot11HTControlHT {
	if m != nil {
		return m.HT
	}
	return nil
}

type Dot11HTControlVHT struct {
	MRQ            bool               `protobuf:"varint,1,opt,name=MRQ,proto3" json:"MRQ,omitempty"`
	UnsolicitedMFB bool               `protobuf:"varint,2,opt,name=UnsolicitedMFB,proto3" json:"UnsolicitedMFB,omitempty"`
	MSI            int32              `protobuf:"varint,3,opt,name=MSI,proto3" json:"MSI,omitempty"`
	MFB            *Dot11HTControlMFB `protobuf:"bytes,4,opt,name=MFB,proto3" json:"MFB,omitempty"`
	CompressedMSI  int32              `protobuf:"varint,5,opt,name=CompressedMSI,proto3" json:"CompressedMSI,omitempty"`
	STBCIndication bool               `protobuf:"varint,6,opt,name=STBCIndication,proto3" json:"STBCIndication,omitempty"`
	MFSI           int32              `protobuf:"varint,7,opt,name=MFSI,proto3" json:"MFSI,omitempty"`
	GID            int32              `protobuf:"varint,8,opt,name=GID,proto3" json:"GID,omitempty"`
	CodingType     int32              `protobuf:"varint,9,opt,name=CodingType,proto3" json:"CodingType,omitempty"`
	FbTXBeamformed bool               `protobuf:"varint,10,opt,name=FbTXBeamformed,proto3" json:"FbTXBeamformed,omitempty"`
}

func (m *Dot11HTControlVHT) Reset()         { *m = Dot11HTControlVHT{} }
func (m *Dot11HTControlVHT) String() string { return proto.CompactTextString(m) }
func (*Dot11HTControlVHT) ProtoMessage()    {}
func (*Dot11HTControlVHT) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{10}
}
func (m *Dot11HTControlVHT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dot11HTControlVHT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Dot11HTControlVHT.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Dot11HTControlVHT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dot11HTControlVHT.Merge(m, src)
}
func (m *Dot11HTControlVHT) XXX_Size() int {
	return m.Size()
}
func (m *Dot11HTControlVHT) XXX_DiscardUnknown() {
	xxx_messageInfo_Dot11HTControlVHT.DiscardUnknown(m)
}

var xxx_messageInfo_Dot11HTControlVHT proto.InternalMessageInfo

func (m *Dot11HTControlVHT) GetMRQ() bool {
	if m != nil {
		return m.MRQ
	}
	return false
}

func (m *Dot11HTControlVHT) GetUnsolicitedMFB() bool {
	if m != nil {
		return m.UnsolicitedMFB
	}
	return false
}

func (m *Dot11HTControlVHT) GetMSI() int32 {
	if m != nil {
		return m.MSI
	}
	return 0
}

func (m *Dot11HTControlVHT) GetMFB() *Dot11HTControlMFB {
	if m != nil {
		return m.MFB
	}
	return nil
}

func (m *Dot11HTControlVHT) GetCompressedMSI() int32 {
	if m != nil {
		return m.CompressedMSI
	}
	return 0
}

func (m *Dot11HTControlVHT) GetSTBCIndication() bool {
	if m != nil {
		return m.STBCIndication
	}
	return false
}

func (m *Dot11HTControlVHT) GetMFSI() int32 {
	if m != nil {
		return m.MFSI
	}
	return 0
}

func (m *Dot11HTControlVHT) GetGID() int32 {
	if m != nil {
		return m.GID
	}
	return 0
}

func (m *Dot11HTControlVHT) GetCodingType() int32 {
	if m != nil {
		return m.CodingType
	}
	return 0
}

func (m *Dot11HTControlVHT) GetFbTXBeamformed() bool {
	if m != nil {
		return m.FbTXBeamformed
	}
	return false
}

type Dot11HTControlHT struct {
	LinkAdapationControl *Dot11LinkAdapationControl `protobuf:"bytes,1,opt,name=LinkAdapationControl,proto3" json:"LinkAdapationControl,omitempty"`
	CalibrationPosition  int32                      `protobuf:"varint,2,opt,name=CalibrationPosition,proto3" json:"CalibrationPosition,omitempty"`
	CalibrationSequence  int32                      `protobuf:"varint,3,opt,name=CalibrationSequence,proto3" json:"CalibrationSequence,omitempty"`
	CSISteering          int32                      `protobuf:"varint,4,opt,name=CSISteering,proto3" json:"CSISteering,omitempty"`
	NDPAnnouncement      bool                       `protobuf:"varint,5,opt,name=NDPAnnouncement,proto3" json:"NDPAnnouncement,omitempty"`
	DEI                  bool                       `protobuf:"varint,6,opt,name=DEI,proto3" json:"DEI,omitempty"`
}

func (m *Dot11HTControlHT) Reset()         { *m = Dot11HTControlHT{} }
func (m *Dot11HTControlHT) String() string { return proto.CompactTextString(m) }
func (*Dot11HTControlHT) ProtoMessage()    {}
func (*Dot11HTControlHT) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{11}
}
func (m *Dot11HTControlHT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dot11HTControlHT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Dot11HTControlHT.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Dot11HTControlHT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dot11HTControlHT.Merge(m, src)
}
func (m *Dot11HTControlHT) XXX_Size() int {
	return m.Size()
}
func (m *Dot11HTControlHT) XXX_DiscardUnknown() {
	xxx_messageInfo_Dot11HTControlHT.DiscardUnknown(m)
}

var xxx_messageInfo_Dot11HTControlHT proto.InternalMessageInfo

func (m *Dot11HTControlHT) GetLinkAdapationControl() *Dot11LinkAdapationControl {
	if m != nil {
		return m.LinkAdapationControl
	}
	return nil
}

func (m *Dot11HTControlHT) GetCalibrationPosition() int32 {
	if m != nil {
		return m.CalibrationPosition
	}
	return 0
}

func (m *Dot11HTControlHT) GetCalibrationSequence() int32 {
	if m != nil {
		return m.CalibrationSequence
	}
	return 0
}

func (m *Dot11HTControlHT) GetCSISteering() int32 {
	if m != nil {
		return m.CSISteering
	}
	return 0
}

func (m *Dot11HTControlHT) GetNDPAnnouncement() bool {
	if m != nil {
		return m.NDPAnnouncement
	}
	return false
}

func (m *Dot11HTControlHT) GetDEI() bool {
	if m != nil {
		return m.DEI
	}
	return false
}

type Dot11HTControlMFB struct {
	NumSTS int32 `protobuf:"varint,1,opt,name=NumSTS,proto3" json:"NumSTS,omitempty"`
	VHTMCS int32 `protobuf:"varint,2,opt,name=VHTMCS,proto3" json:"VHTMCS,omitempty"`
	BW     int32 `protobuf:"varint,3,opt,name=BW,proto3" json:"BW,omitempty"`
	SNR    int32 `protobuf:"varint,4,opt,name=SNR,proto3" json:"SNR,omitempty"`
}

func (m *Dot11HTControlMFB) Reset()         { *m = Dot11HTControlMFB{} }
func (m *Dot11HTControlMFB) String() string { return proto.CompactTextString(m) }
func (*Dot11HTControlMFB) ProtoMessage()    {}
func (*Dot11HTControlMFB) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{12}
}
func (m *Dot11HTControlMFB) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dot11HTControlMFB) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Dot11HTControlMFB.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Dot11HTControlMFB) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dot11HTControlMFB.Merge(m, src)
}
func (m *Dot11HTControlMFB) XXX_Size() int {
	return m.Size()
}
func (m *Dot11HTControlMFB) XXX_DiscardUnknown() {
	xxx_messageInfo_Dot11HTControlMFB.DiscardUnknown(m)
}

var xxx_messageInfo_Dot11HTControlMFB proto.InternalMessageInfo

func (m *Dot11HTControlMFB) GetNumSTS() int32 {
	if m != nil {
		return m.NumSTS
	}
	return 0
}

func (m *Dot11HTControlMFB) GetVHTMCS() int32 {
	if m != nil {
		return m.VHTMCS
	}
	return 0
}

func (m *Dot11HTControlMFB) GetBW() int32 {
	if m != nil {
		return m.BW
	}
	return 0
}

func (m *Dot11HTControlMFB) GetSNR() int32 {
	if m != nil {
		return m.SNR
	}
	return 0
}

type Dot11LinkAdapationControl struct {
	TRQ  bool       `protobuf:"varint,1,opt,name=TRQ,proto3" json:"TRQ,omitempty"`
	MRQ  bool       `protobuf:"varint,2,opt,name=MRQ,proto3" json:"MRQ,omitempty"`
	MSI  int32      `protobuf:"varint,3,opt,name=MSI,proto3" json:"MSI,omitempty"`
	MFSI int32      `protobuf:"varint,4,opt,name=MFSI,proto3" json:"MFSI,omitempty"`
	MFB  int32      `protobuf:"varint,6,opt,name=MFB,proto3" json:"MFB,omitempty"`
	ASEL *Dot11ASEL `protobuf:"bytes,5,opt,name=ASEL,proto3" json:"ASEL,omitempty"`
}

func (m *Dot11LinkAdapationControl) Reset()         { *m = Dot11LinkAdapationControl{} }
func (m *Dot11LinkAdapationControl) String() string { return proto.CompactTextString(m) }
func (*Dot11LinkAdapationControl) ProtoMessage()    {}
func (*Dot11LinkAdapationControl) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{13}
}
func (m *Dot11LinkAdapationControl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dot11LinkAdapationControl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Dot11LinkAdapationControl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Dot11LinkAdapationControl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dot11LinkAdapationControl.Merge(m, src)
}
func (m *Dot11LinkAdapationControl) XXX_Size() int {
	return m.Size()
}
func (m *Dot11LinkAdapationControl) XXX_DiscardUnknown() {
	xxx_messageInfo_Dot11LinkAdapationControl.DiscardUnknown(m)
}

var xxx_messageInfo_Dot11LinkAdapationControl proto.InternalMessageInfo

func (m *Dot11LinkAdapationControl) GetTRQ() bool {
	if m != nil {
		return m.TRQ
	}
	return false
}

func (m *Dot11LinkAdapationControl) GetMRQ() bool {
	if m != nil {
		return m.MRQ
	}
	return false
}

func (m *Dot11LinkAdapationControl) GetMSI() int32 {
	if m != nil {
		return m.MSI
	}
	return 0
}

func (m *Dot11LinkAdapationControl) GetMFSI() int32 {
	if m != nil {
		return m.MFSI
	}
	return 0
}

func (m *Dot11LinkAdapationControl) GetMFB() int32 {
	if m != nil {
		return m.MFB
	}
	return 0
}

func (m *Dot11LinkAdapationControl) GetASEL() *Dot11ASEL {
	if m != nil {
		return m.ASEL
	}
	return nil
}

type Dot11ASEL struct {
	Command int32 `protobuf:"varint,1,opt,name=Command,proto3" json:"Command,omitempty"`
	Data    int32 `protobuf:"varint,2,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *Dot11ASEL) Reset()         { *m = Dot11ASEL{} }
func (m *Dot11ASEL) String() string { return proto.CompactTextString(m) }
func (*Dot11ASEL) ProtoMessage()    {}
func (*Dot11ASEL) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{14}
}
func (m *Dot11ASEL) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dot11ASEL) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Dot11ASEL.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Dot11ASEL) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dot11ASEL.Merge(m, src)
}
func (m *Dot11ASEL) XXX_Size() int {
	return m.Size()
}
func (m *Dot11ASEL) XXX_DiscardUnknown() {
	xxx_messageInfo_Dot11ASEL.DiscardUnknown(m)
}

var xxx_messageInfo_Dot11ASEL proto.InternalMessageInfo

func (m *Dot11ASEL) GetCommand() int32 {
	if m != nil {
		return m.Command
	}
	return 0
}

func (m *Dot11ASEL) GetData() int32 {
	if m != nil {
		return m.Data
	}
	return 0
}

// The Link Layer Discovery Protocol (LLDP) is a vendor-neutral link layer protocol
// used by network devices for advertising their identity, capabilities, and neighbors
// on a local area network based on IEEE 802 technology, principally wired Ethernet.
// The protocol is formally referred to by the IEEE as Station and Media Access Control Connectivity
// Discovery specified in IEEE 802.1AB and IEEE 802.3 section 6 clause 79.
// LLDP performs functions similar to several proprietary protocols, such as Cisco Discovery Protocol, Foundry Discovery Protocol, Nortel Discovery Protocol and Link Layer Topology Discovery.
type LinkLayerDiscovery struct {
	Timestamp int64                      `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	ChassisID *LLDPChassisID             `protobuf:"bytes,2,opt,name=ChassisID,proto3" json:"ChassisID,omitempty"`
	PortID    *LLDPPortID                `protobuf:"bytes,3,opt,name=PortID,proto3" json:"PortID,omitempty"`
	TTL       int32                      `protobuf:"varint,4,opt,name=TTL,proto3" json:"TTL,omitempty"`
	Values    []*LinkLayerDiscoveryValue `protobuf:"bytes,5,rep,name=Values,proto3" json:"Values,omitempty"`
}

func (m *LinkLayerDiscovery) Reset()         { *m = LinkLayerDiscovery{} }
func (m *LinkLayerDiscovery) String() string { return proto.CompactTextString(m) }
func (*LinkLayerDiscovery) ProtoMessage()    {}
func (*LinkLayerDiscovery) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{15}
}
func (m *LinkLayerDiscovery) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LinkLayerDiscovery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LinkLayerDiscovery.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LinkLayerDiscovery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LinkLayerDiscovery.Merge(m, src)
}
func (m *LinkLayerDiscovery) XXX_Size() int {
	return m.Size()
}
func (m *LinkLayerDiscovery) XXX_DiscardUnknown() {
	xxx_messageInfo_LinkLayerDiscovery.DiscardUnknown(m)
}

var xxx_messageInfo_LinkLayerDiscovery proto.InternalMessageInfo

func (m *LinkLayerDiscovery) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *LinkLayerDiscovery) GetChassisID() *LLDPChassisID {
	if m != nil {
		return m.ChassisID
	}
	return nil
}

func (m *LinkLayerDiscovery) GetPortID() *LLDPPortID {
	if m != nil {
		return m.PortID
	}
	return nil
}

func (m *LinkLayerDiscovery) GetTTL() int32 {
	if m != nil {
		return m.TTL
	}
	return 0
}

func (m *LinkLayerDiscovery) GetValues() []*LinkLayerDiscoveryValue {
	if m != nil {
		return m.Values
	}
	return nil
}

type LLDPChassisID struct {
	Subtype int32  `protobuf:"varint,1,opt,name=Subtype,proto3" json:"Subtype,omitempty"`
	ID      []byte `protobuf:"bytes,2,opt,name=ID,proto3" json:"ID,omitempty"`
}

func (m *LLDPChassisID) Reset()         { *m = LLDPChassisID{} }
func (m *LLDPChassisID) String() string { return proto.CompactTextString(m) }
func (*LLDPChassisID) ProtoMessage()    {}
func (*LLDPChassisID) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{16}
}
func (m *LLDPChassisID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LLDPChassisID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LLDPChassisID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LLDPChassisID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LLDPChassisID.Merge(m, src)
}
func (m *LLDPChassisID) XXX_Size() int {
	return m.Size()
}
func (m *LLDPChassisID) XXX_DiscardUnknown() {
	xxx_messageInfo_LLDPChassisID.DiscardUnknown(m)
}

var xxx_messageInfo_LLDPChassisID proto.InternalMessageInfo

func (m *LLDPChassisID) GetSubtype() int32 {
	if m != nil {
		return m.Subtype
	}
	return 0
}

func (m *LLDPChassisID) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

type LLDPPortID struct {
	Subtype int32  `protobuf:"varint,1,opt,name=Subtype,proto3" json:"Subtype,omitempty"`
	ID      []byte `protobuf:"bytes,2,opt,name=ID,proto3" json:"ID,omitempty"`
}

func (m *LLDPPortID) Reset()         { *m = LLDPPortID{} }
func (m *LLDPPortID) String() string { return proto.CompactTextString(m) }
func (*LLDPPortID) ProtoMessage()    {}
func (*LLDPPortID) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{17}
}
func (m *LLDPPortID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LLDPPortID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LLDPPortID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LLDPPortID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LLDPPortID.Merge(m, src)
}
func (m *LLDPPortID) XXX_Size() int {
	return m.Size()
}
func (m *LLDPPortID) XXX_DiscardUnknown() {
	xxx_messageInfo_LLDPPortID.DiscardUnknown(m)
}

var xxx_messageInfo_LLDPPortID proto.InternalMessageInfo

func (m *LLDPPortID) GetSubtype() int32 {
	if m != nil {
		return m.Subtype
	}
	return 0
}

func (m *LLDPPortID) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

type LinkLayerDiscoveryValue struct {
	Type   int32  `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Length int32  `protobuf:"varint,2,opt,name=Length,proto3" json:"Length,omitempty"`
	Value  []byte `protobuf:"bytes,3,opt,name=Value,proto3" json:"Value,omitempty"`
}

func (m *LinkLayerDiscoveryValue) Reset()         { *m = LinkLayerDiscoveryValue{} }
func (m *LinkLayerDiscoveryValue) String() string { return proto.CompactTextString(m) }
func (*LinkLayerDiscoveryValue) ProtoMessage()    {}
func (*LinkLayerDiscoveryValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{18}
}
func (m *LinkLayerDiscoveryValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LinkLayerDiscoveryValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LinkLayerDiscoveryValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LinkLayerDiscoveryValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LinkLayerDiscoveryValue.Merge(m, src)
}
func (m *LinkLayerDiscoveryValue) XXX_Size() int {
	return m.Size()
}
func (m *LinkLayerDiscoveryValue) XXX_DiscardUnknown() {
	xxx_messageInfo_LinkLayerDiscoveryValue.DiscardUnknown(m)
}

var xxx_messageInfo_LinkLayerDiscoveryValue proto.InternalMessageInfo

func (m *LinkLayerDiscoveryValue) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *LinkLayerDiscoveryValue) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *LinkLayerDiscoveryValue) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type EthernetCTP struct {
	Timestamp int64 `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	SkipCount int32 `protobuf:"varint,2,opt,name=SkipCount,proto3" json:"SkipCount,omitempty"`
}

func (m *EthernetCTP) Reset()         { *m = EthernetCTP{} }
func (m *EthernetCTP) String() string { return proto.CompactTextString(m) }
func (*EthernetCTP) ProtoMessage()    {}
func (*EthernetCTP) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{19}
}
func (m *EthernetCTP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EthernetCTP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EthernetCTP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EthernetCTP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EthernetCTP.Merge(m, src)
}
func (m *EthernetCTP) XXX_Size() int {
	return m.Size()
}
func (m *EthernetCTP) XXX_DiscardUnknown() {
	xxx_messageInfo_EthernetCTP.DiscardUnknown(m)
}

var xxx_messageInfo_EthernetCTP proto.InternalMessageInfo

func (m *EthernetCTP) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *EthernetCTP) GetSkipCount() int32 {
	if m != nil {
		return m.SkipCount
	}
	return 0
}

type EthernetCTPReply struct {
	Timestamp     int64  `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Function      int32  `protobuf:"varint,2,opt,name=Function,proto3" json:"Function,omitempty"`
	ReceiptNumber int32  `protobuf:"varint,3,opt,name=ReceiptNumber,proto3" json:"ReceiptNumber,omitempty"`
	Data          []byte `protobuf:"bytes,4,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *EthernetCTPReply) Reset()         { *m = EthernetCTPReply{} }
func (m *EthernetCTPReply) String() string { return proto.CompactTextString(m) }
func (*EthernetCTPReply) ProtoMessage()    {}
func (*EthernetCTPReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{20}
}
func (m *EthernetCTPReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EthernetCTPReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EthernetCTPReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EthernetCTPReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EthernetCTPReply.Merge(m, src)
}
func (m *EthernetCTPReply) XXX_Size() int {
	return m.Size()
}
func (m *EthernetCTPReply) XXX_DiscardUnknown() {
	xxx_messageInfo_EthernetCTPReply.DiscardUnknown(m)
}

var xxx_messageInfo_EthernetCTPReply proto.InternalMessageInfo

func (m *EthernetCTPReply) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *EthernetCTPReply) GetFunction() int32 {
	if m != nil {
		return m.Function
	}
	return 0
}

func (m *EthernetCTPReply) GetReceiptNumber() int32 {
	if m != nil {
		return m.ReceiptNumber
	}
	return 0
}

func (m *EthernetCTPReply) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type LinkLayerDiscoveryInfo struct {
	Timestamp       int64                      `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	PortDescription string                     `protobuf:"bytes,2,opt,name=PortDescription,proto3" json:"PortDescription,omitempty"`
	SysName         string                     `protobuf:"bytes,3,opt,name=SysName,proto3" json:"SysName,omitempty"`
	SysDescription  string                     `protobuf:"bytes,4,opt,name=SysDescription,proto3" json:"SysDescription,omitempty"`
	SysCapabilities *LLDPSysCapabilities       `protobuf:"bytes,5,opt,name=SysCapabilities,proto3" json:"SysCapabilities,omitempty"`
	MgmtAddress     *LLDPMgmtAddress           `protobuf:"bytes,6,opt,name=MgmtAddress,proto3" json:"MgmtAddress,omitempty"`
	OrgTLVs         []*LLDPOrgSpecificTLV      `protobuf:"bytes,7,rep,name=OrgTLVs,proto3" json:"OrgTLVs,omitempty"`
	Unknown         []*LinkLayerDiscoveryValue `protobuf:"bytes,8,rep,name=Unknown,proto3" json:"Unknown,omitempty"`
}

func (m *LinkLayerDiscoveryInfo) Reset()         { *m = LinkLayerDiscoveryInfo{} }
func (m *LinkLayerDiscoveryInfo) String() string { return proto.CompactTextString(m) }
func (*LinkLayerDiscoveryInfo) ProtoMessage()    {}
func (*LinkLayerDiscoveryInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{21}
}
func (m *LinkLayerDiscoveryInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LinkLayerDiscoveryInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LinkLayerDiscoveryInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LinkLayerDiscoveryInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LinkLayerDiscoveryInfo.Merge(m, src)
}
func (m *LinkLayerDiscoveryInfo) XXX_Size() int {
	return m.Size()
}
func (m *LinkLayerDiscoveryInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_LinkLayerDiscoveryInfo.DiscardUnknown(m)
}

var xxx_messageInfo_LinkLayerDiscoveryInfo proto.InternalMessageInfo

func (m *LinkLayerDiscoveryInfo) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *LinkLayerDiscoveryInfo) GetPortDescription() string {
	if m != nil {
		return m.PortDescription
	}
	return ""
}

func (m *LinkLayerDiscoveryInfo) GetSysName() string {
	if m != nil {
		return m.SysName
	}
	return ""
}

func (m *LinkLayerDiscoveryInfo) GetSysDescription() string {
	if m != nil {
		return m.SysDescription
	}
	return ""
}

func (m *LinkLayerDiscoveryInfo) GetSysCapabilities() *LLDPSysCapabilities {
	if m != nil {
		return m.SysCapabilities
	}
	return nil
}

func (m *LinkLayerDiscoveryInfo) GetMgmtAddress() *LLDPMgmtAddress {
	if m != nil {
		return m.MgmtAddress
	}
	return nil
}

func (m *LinkLayerDiscoveryInfo) GetOrgTLVs() []*LLDPOrgSpecificTLV {
	if m != nil {
		return m.OrgTLVs
	}
	return nil
}

func (m *LinkLayerDiscoveryInfo) GetUnknown() []*LinkLayerDiscoveryValue {
	if m != nil {
		return m.Unknown
	}
	return nil
}

type LLDPSysCapabilities struct {
	SystemCap  *LLDPCapabilities `protobuf:"bytes,1,opt,name=SystemCap,proto3" json:"SystemCap,omitempty"`
	EnabledCap *LLDPCapabilities `protobuf:"bytes,2,opt,name=EnabledCap,proto3" json:"EnabledCap,omitempty"`
}

func (m *LLDPSysCapabilities) Reset()         { *m = LLDPSysCapabilities{} }
func (m *LLDPSysCapabilities) String() string { return proto.CompactTextString(m) }
func (*LLDPSysCapabilities) ProtoMessage()    {}
func (*LLDPSysCapabilities) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{22}
}
func (m *LLDPSysCapabilities) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LLDPSysCapabilities) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LLDPSysCapabilities.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LLDPSysCapabilities) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LLDPSysCapabilities.Merge(m, src)
}
func (m *LLDPSysCapabilities) XXX_Size() int {
	return m.Size()
}
func (m *LLDPSysCapabilities) XXX_DiscardUnknown() {
	xxx_messageInfo_LLDPSysCapabilities.DiscardUnknown(m)
}

var xxx_messageInfo_LLDPSysCapabilities proto.InternalMessageInfo

func (m *LLDPSysCapabilities) GetSystemCap() *LLDPCapabilities {
	if m != nil {
		return m.SystemCap
	}
	return nil
}

func (m *LLDPSysCapabilities) GetEnabledCap() *LLDPCapabilities {
	if m != nil {
		return m.EnabledCap
	}
	return nil
}

type LLDPCapabilities struct {
	Other       bool `protobuf:"varint,1,opt,name=Other,proto3" json:"Other,omitempty"`
	Repeater    bool `protobuf:"varint,2,opt,name=Repeater,proto3" json:"Repeater,omitempty"`
	Bridge      bool `protobuf:"varint,3,opt,name=Bridge,proto3" json:"Bridge,omitempty"`
	WLANAP      bool `protobuf:"varint,4,opt,name=WLANAP,proto3" json:"WLANAP,omitempty"`
	Router      bool `protobuf:"varint,5,opt,name=Router,proto3" json:"Router,omitempty"`
	Phone       bool `protobuf:"varint,6,opt,name=Phone,proto3" json:"Phone,omitempty"`
	DocSis      bool `protobuf:"varint,7,opt,name=DocSis,proto3" json:"DocSis,omitempty"`
	StationOnly bool `protobuf:"varint,8,opt,name=StationOnly,proto3" json:"StationOnly,omitempty"`
	CVLAN       bool `protobuf:"varint,9,opt,name=CVLAN,proto3" json:"CVLAN,omitempty"`
	SVLAN       bool `protobuf:"varint,10,opt,name=SVLAN,proto3" json:"SVLAN,omitempty"`
	TMPR        bool `protobuf:"varint,11,opt,name=TMPR,proto3" json:"TMPR,omitempty"`
}

func (m *LLDPCapabilities) Reset()         { *m = LLDPCapabilities{} }
func (m *LLDPCapabilities) String() string { return proto.CompactTextString(m) }
func (*LLDPCapabilities) ProtoMessage()    {}
func (*LLDPCapabilities) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{23}
}
func (m *LLDPCapabilities) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LLDPCapabilities) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LLDPCapabilities.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LLDPCapabilities) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LLDPCapabilities.Merge(m, src)
}
func (m *LLDPCapabilities) XXX_Size() int {
	return m.Size()
}
func (m *LLDPCapabilities) XXX_DiscardUnknown() {
	xxx_messageInfo_LLDPCapabilities.DiscardUnknown(m)
}

var xxx_messageInfo_LLDPCapabilities proto.InternalMessageInfo

func (m *LLDPCapabilities) GetOther() bool {
	if m != nil {
		return m.Other
	}
	return false
}

func (m *LLDPCapabilities) GetRepeater() bool {
	if m != nil {
		return m.Repeater
	}
	return false
}

func (m *LLDPCapabilities) GetBridge() bool {
	if m != nil {
		return m.Bridge
	}
	return false
}

func (m *LLDPCapabilities) GetWLANAP() bool {
	if m != nil {
		return m.WLANAP
	}
	return false
}

func (m *LLDPCapabilities) GetRouter() bool {
	if m != nil {
		return m.Router
	}
	return false
}

func (m *LLDPCapabilities) GetPhone() bool {
	if m != nil {
		return m.Phone
	}
	return false
}

func (m *LLDPCapabilities) GetDocSis() bool {
	if m != nil {
		return m.DocSis
	}
	return false
}

func (m *LLDPCapabilities) GetStationOnly() bool {
	if m != nil {
		return m.StationOnly
	}
	return false
}

func (m *LLDPCapabilities) GetCVLAN() bool {
	if m != nil {
		return m.CVLAN
	}
	return false
}

func (m *LLDPCapabilities) GetSVLAN() bool {
	if m != nil {
		return m.SVLAN
	}
	return false
}

func (m *LLDPCapabilities) GetTMPR() bool {
	if m != nil {
		return m.TMPR
	}
	return false
}

type LLDPMgmtAddress struct {
	Subtype          int32  `protobuf:"varint,1,opt,name=Subtype,proto3" json:"Subtype,omitempty"`
	Address          []byte `protobuf:"bytes,2,opt,name=Address,proto3" json:"Address,omitempty"`
	InterfaceSubtype int32  `protobuf:"varint,3,opt,name=InterfaceSubtype,proto3" json:"InterfaceSubtype,omitempty"`
	InterfaceNumber  uint32 `protobuf:"varint,4,opt,name=InterfaceNumber,proto3" json:"InterfaceNumber,omitempty"`
	OID              string `protobuf:"bytes,5,opt,name=OID,proto3" json:"OID,omitempty"`
}

func (m *LLDPMgmtAddress) Reset()         { *m = LLDPMgmtAddress{} }
func (m *LLDPMgmtAddress) String() string { return proto.CompactTextString(m) }
func (*LLDPMgmtAddress) ProtoMessage()    {}
func (*LLDPMgmtAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{24}
}
func (m *LLDPMgmtAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LLDPMgmtAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LLDPMgmtAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LLDPMgmtAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LLDPMgmtAddress.Merge(m, src)
}
func (m *LLDPMgmtAddress) XXX_Size() int {
	return m.Size()
}
func (m *LLDPMgmtAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_LLDPMgmtAddress.DiscardUnknown(m)
}

var xxx_messageInfo_LLDPMgmtAddress proto.InternalMessageInfo

func (m *LLDPMgmtAddress) GetSubtype() int32 {
	if m != nil {
		return m.Subtype
	}
	return 0
}

func (m *LLDPMgmtAddress) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *LLDPMgmtAddress) GetInterfaceSubtype() int32 {
	if m != nil {
		return m.InterfaceSubtype
	}
	return 0
}

func (m *LLDPMgmtAddress) GetInterfaceNumber() uint32 {
	if m != nil {
		return m.InterfaceNumber
	}
	return 0
}

func (m *LLDPMgmtAddress) GetOID() string {
	if m != nil {
		return m.OID
	}
	return ""
}

type LLDPOrgSpecificTLV struct {
	OUI     uint32 `protobuf:"varint,1,opt,name=OUI,proto3" json:"OUI,omitempty"`
	SubType int32  `protobuf:"varint,2,opt,name=SubType,proto3" json:"SubType,omitempty"`
	Info    []byte `protobuf:"bytes,3,opt,name=Info,proto3" json:"Info,omitempty"`
}

func (m *LLDPOrgSpecificTLV) Reset()         { *m = LLDPOrgSpecificTLV{} }
func (m *LLDPOrgSpecificTLV) String() string { return proto.CompactTextString(m) }
func (*LLDPOrgSpecificTLV) ProtoMessage()    {}
func (*LLDPOrgSpecificTLV) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{25}
}
func (m *LLDPOrgSpecificTLV) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LLDPOrgSpecificTLV) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LLDPOrgSpecificTLV.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LLDPOrgSpecificTLV) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LLDPOrgSpecificTLV.Merge(m, src)
}
func (m *LLDPOrgSpecificTLV) XXX_Size() int {
	return m.Size()
}
func (m *LLDPOrgSpecificTLV) XXX_DiscardUnknown() {
	xxx_messageInfo_LLDPOrgSpecificTLV.DiscardUnknown(m)
}

var xxx_messageInfo_LLDPOrgSpecificTLV proto.InternalMessageInfo

func (m *LLDPOrgSpecificTLV) GetOUI() uint32 {
	if m != nil {
		return m.OUI
	}
	return 0
}

func (m *LLDPOrgSpecificTLV) GetSubType() int32 {
	if m != nil {
		return m.SubType
	}
	return 0
}

func (m *LLDPOrgSpecificTLV) GetInfo() []byte {
	if m != nil {
		return m.Info
	}
	return nil
}

// Internet Protocol version 4 (IPv4) is the fourth version of the Internet Protocol (IP).
// It is one of the core protocols of standards-based internetworking methods in the Internet and other packet-switched networks.
// IPv4 was the first version deployed for production in the ARPANET in 1983.
// It still routes most Internet traffic today, despite the ongoing deployment of a successor protocol, IPv6.
// IPv4 is described in IETF publication RFC 791 (September 1981), replacing an earlier definition (RFC 760, January 1980).
// IPv4 uses a 32-bit address space, which limits the number of unique hosts to 4,294,967,296 (232), but large blocks are reserved for special networking methods.
type IPv4 struct {
	Timestamp      int64         `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Version        int32         `protobuf:"varint,2,opt,name=Version,proto3" json:"Version,omitempty"`
	IHL            int32         `protobuf:"varint,3,opt,name=IHL,proto3" json:"IHL,omitempty"`
	TOS            int32         `protobuf:"varint,4,opt,name=TOS,proto3" json:"TOS,omitempty"`
	Length         int32         `protobuf:"varint,5,opt,name=Length,proto3" json:"Length,omitempty"`
	Id             int32         `protobuf:"varint,6,opt,name=Id,proto3" json:"Id,omitempty"`
	Flags          int32         `protobuf:"varint,7,opt,name=Flags,proto3" json:"Flags,omitempty"`
	FragOffset     int32         `protobuf:"varint,8,opt,name=FragOffset,proto3" json:"FragOffset,omitempty"`
	TTL            int32         `protobuf:"varint,9,opt,name=TTL,proto3" json:"TTL,omitempty"`
	Protocol       int32         `protobuf:"varint,10,opt,name=Protocol,proto3" json:"Protocol,omitempty"`
	Checksum       int32         `protobuf:"varint,11,opt,name=Checksum,proto3" json:"Checksum,omitempty"`
	SrcIP          string        `protobuf:"bytes,12,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP          string        `protobuf:"bytes,13,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
	Padding        []byte        `protobuf:"bytes,14,opt,name=Padding,proto3" json:"Padding,omitempty"`
	Options        []*IPv4Option `protobuf:"bytes,15,rep,name=Options,proto3" json:"Options,omitempty"`
	PayloadEntropy float64       `protobuf:"fixed64,16,opt,name=PayloadEntropy,proto3" json:"PayloadEntropy,omitempty"`
	PayloadSize    int32         `protobuf:"varint,17,opt,name=PayloadSize,proto3" json:"PayloadSize,omitempty"`
	SrcPort        int32         `protobuf:"varint,18,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	DstPort        int32         `protobuf:"varint,19,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
}

func (m *IPv4) Reset()         { *m = IPv4{} }
func (m *IPv4) String() string { return proto.CompactTextString(m) }
func (*IPv4) ProtoMessage()    {}
func (*IPv4) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{26}
}
func (m *IPv4) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPv4) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPv4.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPv4) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPv4.Merge(m, src)
}
func (m *IPv4) XXX_Size() int {
	return m.Size()
}
func (m *IPv4) XXX_DiscardUnknown() {
	xxx_messageInfo_IPv4.DiscardUnknown(m)
}

var xxx_messageInfo_IPv4 proto.InternalMessageInfo

func (m *IPv4) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *IPv4) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *IPv4) GetIHL() int32 {
	if m != nil {
		return m.IHL
	}
	return 0
}

func (m *IPv4) GetTOS() int32 {
	if m != nil {
		return m.TOS
	}
	return 0
}

func (m *IPv4) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *IPv4) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *IPv4) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *IPv4) GetFragOffset() int32 {
	if m != nil {
		return m.FragOffset
	}
	return 0
}

func (m *IPv4) GetTTL() int32 {
	if m != nil {
		return m.TTL
	}
	return 0
}

func (m *IPv4) GetProtocol() int32 {
	if m != nil {
		return m.Protocol
	}
	return 0
}

func (m *IPv4) GetChecksum() int32 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

func (m *IPv4) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *IPv4) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

func (m *IPv4) GetPadding() []byte {
	if m != nil {
		return m.Padding
	}
	return nil
}

func (m *IPv4) GetOptions() []*IPv4Option {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *IPv4) GetPayloadEntropy() float64 {
	if m != nil {
		return m.PayloadEntropy
	}
	return 0
}

func (m *IPv4) GetPayloadSize() int32 {
	if m != nil {
		return m.PayloadSize
	}
	return 0
}

func (m *IPv4) GetSrcPort() int32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *IPv4) GetDstPort() int32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

type IPv4Option struct {
	OptionType   int32  `protobuf:"varint,1,opt,name=OptionType,proto3" json:"OptionType,omitempty"`
	OptionLength int32  `protobuf:"varint,2,opt,name=OptionLength,proto3" json:"OptionLength,omitempty"`
	OptionData   []byte `protobuf:"bytes,3,opt,name=OptionData,proto3" json:"OptionData,omitempty"`
}

func (m *IPv4Option) Reset()         { *m = IPv4Option{} }
func (m *IPv4Option) String() string { return proto.CompactTextString(m) }
func (*IPv4Option) ProtoMessage()    {}
func (*IPv4Option) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{27}
}
func (m *IPv4Option) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPv4Option) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPv4Option.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPv4Option) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPv4Option.Merge(m, src)
}
func (m *IPv4Option) XXX_Size() int {
	return m.Size()
}
func (m *IPv4Option) XXX_DiscardUnknown() {
	xxx_messageInfo_IPv4Option.DiscardUnknown(m)
}

var xxx_messageInfo_IPv4Option proto.InternalMessageInfo

func (m *IPv4Option) GetOptionType() int32 {
	if m != nil {
		return m.OptionType
	}
	return 0
}

func (m *IPv4Option) GetOptionLength() int32 {
	if m != nil {
		return m.OptionLength
	}
	return 0
}

func (m *IPv4Option) GetOptionData() []byte {
	if m != nil {
		return m.OptionData
	}
	return nil
}

// Internet Protocol version 6 (IPv6) is the most recent version of the Internet Protocol (IP),
// the communications protocol that provides an identification and location system for computers
// on networks and routes traffic across the Internet. IPv6 was developed by the Internet Engineering
// Task Force (IETF) to deal with the long-anticipated problem of IPv4 address exhaustion.
// IPv6 is intended to replace IPv4.
type IPv6 struct {
	Timestamp      int64         `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Version        int32         `protobuf:"varint,2,opt,name=Version,proto3" json:"Version,omitempty"`
	TrafficClass   int32         `protobuf:"varint,3,opt,name=TrafficClass,proto3" json:"TrafficClass,omitempty"`
	FlowLabel      uint32        `protobuf:"varint,4,opt,name=FlowLabel,proto3" json:"FlowLabel,omitempty"`
	Length         int32         `protobuf:"varint,5,opt,name=Length,proto3" json:"Length,omitempty"`
	NextHeader     int32         `protobuf:"varint,6,opt,name=NextHeader,proto3" json:"NextHeader,omitempty"`
	HopLimit       int32         `protobuf:"varint,7,opt,name=HopLimit,proto3" json:"HopLimit,omitempty"`
	SrcIP          string        `protobuf:"bytes,8,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP          string        `protobuf:"bytes,9,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
	PayloadEntropy float64       `protobuf:"fixed64,10,opt,name=PayloadEntropy,proto3" json:"PayloadEntropy,omitempty"`
	PayloadSize    int32         `protobuf:"varint,11,opt,name=PayloadSize,proto3" json:"PayloadSize,omitempty"`
	HopByHop       *IPv6HopByHop `protobuf:"bytes,12,opt,name=HopByHop,proto3" json:"HopByHop,omitempty"`
	SrcPort        int32         `protobuf:"varint,13,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	DstPort        int32         `protobuf:"varint,14,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
}

func (m *IPv6) Reset()         { *m = IPv6{} }
func (m *IPv6) String() string { return proto.CompactTextString(m) }
func (*IPv6) ProtoMessage()    {}
func (*IPv6) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{28}
}
func (m *IPv6) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPv6) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPv6.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPv6) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPv6.Merge(m, src)
}
func (m *IPv6) XXX_Size() int {
	return m.Size()
}
func (m *IPv6) XXX_DiscardUnknown() {
	xxx_messageInfo_IPv6.DiscardUnknown(m)
}

var xxx_messageInfo_IPv6 proto.InternalMessageInfo

func (m *IPv6) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *IPv6) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *IPv6) GetTrafficClass() int32 {
	if m != nil {
		return m.TrafficClass
	}
	return 0
}

func (m *IPv6) GetFlowLabel() uint32 {
	if m != nil {
		return m.FlowLabel
	}
	return 0
}

func (m *IPv6) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *IPv6) GetNextHeader() int32 {
	if m != nil {
		return m.NextHeader
	}
	return 0
}

func (m *IPv6) GetHopLimit() int32 {
	if m != nil {
		return m.HopLimit
	}
	return 0
}

func (m *IPv6) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *IPv6) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

func (m *IPv6) GetPayloadEntropy() float64 {
	if m != nil {
		return m.PayloadEntropy
	}
	return 0
}

func (m *IPv6) GetPayloadSize() int32 {
	if m != nil {
		return m.PayloadSize
	}
	return 0
}

func (m *IPv6) GetHopByHop() *IPv6HopByHop {
	if m != nil {
		return m.HopByHop
	}
	return nil
}

func (m *IPv6) GetSrcPort() int32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *IPv6) GetDstPort() int32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

type IPv6Fragment struct {
	Timestamp      int64  `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	NextHeader     int32  `protobuf:"varint,2,opt,name=NextHeader,proto3" json:"NextHeader,omitempty"`
	Reserved1      int32  `protobuf:"varint,3,opt,name=Reserved1,proto3" json:"Reserved1,omitempty"`
	FragmentOffset int32  `protobuf:"varint,4,opt,name=FragmentOffset,proto3" json:"FragmentOffset,omitempty"`
	Reserved2      int32  `protobuf:"varint,5,opt,name=Reserved2,proto3" json:"Reserved2,omitempty"`
	MoreFragments  bool   `protobuf:"varint,6,opt,name=MoreFragments,proto3" json:"MoreFragments,omitempty"`
	Identification uint32 `protobuf:"varint,7,opt,name=Identification,proto3" json:"Identification,omitempty"`
	SrcPort        int32  `protobuf:"varint,8,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	DstPort        int32  `protobuf:"varint,9,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
	SrcIP          string `protobuf:"bytes,10,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP          string `protobuf:"bytes,11,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
}

func (m *IPv6Fragment) Reset()         { *m = IPv6Fragment{} }
func (m *IPv6Fragment) String() string { return proto.CompactTextString(m) }
func (*IPv6Fragment) ProtoMessage()    {}
func (*IPv6Fragment) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{29}
}
func (m *IPv6Fragment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPv6Fragment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPv6Fragment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPv6Fragment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPv6Fragment.Merge(m, src)
}
func (m *IPv6Fragment) XXX_Size() int {
	return m.Size()
}
func (m *IPv6Fragment) XXX_DiscardUnknown() {
	xxx_messageInfo_IPv6Fragment.DiscardUnknown(m)
}

var xxx_messageInfo_IPv6Fragment proto.InternalMessageInfo

func (m *IPv6Fragment) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *IPv6Fragment) GetNextHeader() int32 {
	if m != nil {
		return m.NextHeader
	}
	return 0
}

func (m *IPv6Fragment) GetReserved1() int32 {
	if m != nil {
		return m.Reserved1
	}
	return 0
}

func (m *IPv6Fragment) GetFragmentOffset() int32 {
	if m != nil {
		return m.FragmentOffset
	}
	return 0
}

func (m *IPv6Fragment) GetReserved2() int32 {
	if m != nil {
		return m.Reserved2
	}
	return 0
}

func (m *IPv6Fragment) GetMoreFragments() bool {
	if m != nil {
		return m.MoreFragments
	}
	return false
}

func (m *IPv6Fragment) GetIdentification() uint32 {
	if m != nil {
		return m.Identification
	}
	return 0
}

func (m *IPv6Fragment) GetSrcPort() int32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *IPv6Fragment) GetDstPort() int32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

func (m *IPv6Fragment) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *IPv6Fragment) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

type ICMPv4 struct {
	Timestamp int64  `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	TypeCode  int32  `protobuf:"varint,2,opt,name=TypeCode,proto3" json:"TypeCode,omitempty"`
	Checksum  int32  `protobuf:"varint,3,opt,name=Checksum,proto3" json:"Checksum,omitempty"`
	Id        int32  `protobuf:"varint,4,opt,name=Id,proto3" json:"Id,omitempty"`
	Seq       int32  `protobuf:"varint,5,opt,name=Seq,proto3" json:"Seq,omitempty"`
	SrcIP     string `protobuf:"bytes,6,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP     string `protobuf:"bytes,7,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
}

func (m *ICMPv4) Reset()         { *m = ICMPv4{} }
func (m *ICMPv4) String() string { return proto.CompactTextString(m) }
func (*ICMPv4) ProtoMessage()    {}
func (*ICMPv4) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{30}
}
func (m *ICMPv4) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ICMPv4) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ICMPv4.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ICMPv4) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ICMPv4.Merge(m, src)
}
func (m *ICMPv4) XXX_Size() int {
	return m.Size()
}
func (m *ICMPv4) XXX_DiscardUnknown() {
	xxx_messageInfo_ICMPv4.DiscardUnknown(m)
}

var xxx_messageInfo_ICMPv4 proto.InternalMessageInfo

func (m *ICMPv4) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *ICMPv4) GetTypeCode() int32 {
	if m != nil {
		return m.TypeCode
	}
	return 0
}

func (m *ICMPv4) GetChecksum() int32 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

func (m *ICMPv4) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ICMPv4) GetSeq() int32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *ICMPv4) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *ICMPv4) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

type ICMPv6 struct {
	Timestamp int64  `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	TypeCode  int32  `protobuf:"varint,2,opt,name=TypeCode,proto3" json:"TypeCode,omitempty"`
	Checksum  int32  `protobuf:"varint,3,opt,name=Checksum,proto3" json:"Checksum,omitempty"`
	SrcIP     string `protobuf:"bytes,4,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP     string `protobuf:"bytes,5,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
}

func (m *ICMPv6) Reset()         { *m = ICMPv6{} }
func (m *ICMPv6) String() string { return proto.CompactTextString(m) }
func (*ICMPv6) ProtoMessage()    {}
func (*ICMPv6) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{31}
}
func (m *ICMPv6) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ICMPv6) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ICMPv6.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ICMPv6) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ICMPv6.Merge(m, src)
}
func (m *ICMPv6) XXX_Size() int {
	return m.Size()
}
func (m *ICMPv6) XXX_DiscardUnknown() {
	xxx_messageInfo_ICMPv6.DiscardUnknown(m)
}

var xxx_messageInfo_ICMPv6 proto.InternalMessageInfo

func (m *ICMPv6) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *ICMPv6) GetTypeCode() int32 {
	if m != nil {
		return m.TypeCode
	}
	return 0
}

func (m *ICMPv6) GetChecksum() int32 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

func (m *ICMPv6) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *ICMPv6) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

type ICMPv6NeighborAdvertisement struct {
	Timestamp     int64           `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Flags         int32           `protobuf:"varint,2,opt,name=Flags,proto3" json:"Flags,omitempty"`
	TargetAddress string          `protobuf:"bytes,3,opt,name=TargetAddress,proto3" json:"TargetAddress,omitempty"`
	Options       []*ICMPv6Option `protobuf:"bytes,4,rep,name=Options,proto3" json:"Options,omitempty"`
	SrcIP         string          `protobuf:"bytes,5,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP         string          `protobuf:"bytes,6,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
}

func (m *ICMPv6NeighborAdvertisement) Reset()         { *m = ICMPv6NeighborAdvertisement{} }
func (m *ICMPv6NeighborAdvertisement) String() string { return proto.CompactTextString(m) }
func (*ICMPv6NeighborAdvertisement) ProtoMessage()    {}
func (*ICMPv6NeighborAdvertisement) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{32}
}
func (m *ICMPv6NeighborAdvertisement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ICMPv6NeighborAdvertisement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ICMPv6NeighborAdvertisement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ICMPv6NeighborAdvertisement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ICMPv6NeighborAdvertisement.Merge(m, src)
}
func (m *ICMPv6NeighborAdvertisement) XXX_Size() int {
	return m.Size()
}
func (m *ICMPv6NeighborAdvertisement) XXX_DiscardUnknown() {
	xxx_messageInfo_ICMPv6NeighborAdvertisement.DiscardUnknown(m)
}

var xxx_messageInfo_ICMPv6NeighborAdvertisement proto.InternalMessageInfo

func (m *ICMPv6NeighborAdvertisement) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *ICMPv6NeighborAdvertisement) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *ICMPv6NeighborAdvertisement) GetTargetAddress() string {
	if m != nil {
		return m.TargetAddress
	}
	return ""
}

func (m *ICMPv6NeighborAdvertisement) GetOptions() []*ICMPv6Option {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *ICMPv6NeighborAdvertisement) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *ICMPv6NeighborAdvertisement) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

type ICMPv6RouterAdvertisement struct {
	Timestamp      int64           `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	HopLimit       int32           `protobuf:"varint,2,opt,name=HopLimit,proto3" json:"HopLimit,omitempty"`
	Flags          int32           `protobuf:"varint,3,opt,name=Flags,proto3" json:"Flags,omitempty"`
	RouterLifetime int32           `protobuf:"varint,4,opt,name=RouterLifetime,proto3" json:"RouterLifetime,omitempty"`
	ReachableTime  uint32          `protobuf:"varint,5,opt,name=ReachableTime,proto3" json:"ReachableTime,omitempty"`
	RetransTimer   uint32          `protobuf:"varint,6,opt,name=RetransTimer,proto3" json:"RetransTimer,omitempty"`
	Options        []*ICMPv6Option `protobuf:"bytes,7,rep,name=Options,proto3" json:"Options,omitempty"`
	SrcIP          string          `protobuf:"bytes,8,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP          string          `protobuf:"bytes,9,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
}

func (m *ICMPv6RouterAdvertisement) Reset()         { *m = ICMPv6RouterAdvertisement{} }
func (m *ICMPv6RouterAdvertisement) String() string { return proto.CompactTextString(m) }
func (*ICMPv6RouterAdvertisement) ProtoMessage()    {}
func (*ICMPv6RouterAdvertisement) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{33}
}
func (m *ICMPv6RouterAdvertisement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ICMPv6RouterAdvertisement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ICMPv6RouterAdvertisement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ICMPv6RouterAdvertisement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ICMPv6RouterAdvertisement.Merge(m, src)
}
func (m *ICMPv6RouterAdvertisement) XXX_Size() int {
	return m.Size()
}
func (m *ICMPv6RouterAdvertisement) XXX_DiscardUnknown() {
	xxx_messageInfo_ICMPv6RouterAdvertisement.DiscardUnknown(m)
}

var xxx_messageInfo_ICMPv6RouterAdvertisement proto.InternalMessageInfo

func (m *ICMPv6RouterAdvertisement) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *ICMPv6RouterAdvertisement) GetHopLimit() int32 {
	if m != nil {
		return m.HopLimit
	}
	return 0
}

func (m *ICMPv6RouterAdvertisement) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *ICMPv6RouterAdvertisement) GetRouterLifetime() int32 {
	if m != nil {
		return m.RouterLifetime
	}
	return 0
}

func (m *ICMPv6RouterAdvertisement) GetReachableTime() uint32 {
	if m != nil {
		return m.ReachableTime
	}
	return 0
}

func (m *ICMPv6RouterAdvertisement) GetRetransTimer() uint32 {
	if m != nil {
		return m.RetransTimer
	}
	return 0
}

func (m *ICMPv6RouterAdvertisement) GetOptions() []*ICMPv6Option {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *ICMPv6RouterAdvertisement) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *ICMPv6RouterAdvertisement) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

type ICMPv6Option struct {
	Type int32  `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Data []byte `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *ICMPv6Option) Reset()         { *m = ICMPv6Option{} }
func (m *ICMPv6Option) String() string { return proto.CompactTextString(m) }
func (*ICMPv6Option) ProtoMessage()    {}
func (*ICMPv6Option) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{34}
}
func (m *ICMPv6Option) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ICMPv6Option) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ICMPv6Option.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ICMPv6Option) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ICMPv6Option.Merge(m, src)
}
func (m *ICMPv6Option) XXX_Size() int {
	return m.Size()
}
func (m *ICMPv6Option) XXX_DiscardUnknown() {
	xxx_messageInfo_ICMPv6Option.DiscardUnknown(m)
}

var xxx_messageInfo_ICMPv6Option proto.InternalMessageInfo

func (m *ICMPv6Option) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ICMPv6Option) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// The User Datagram Protocol (UDP) is one of the core members of the Internet
// protocol suite. The protocol was designed by David P. Reed in 1980 and formally
// defined in RFC 768. With UDP, computer applications can send messages, in this
// case referred to as datagrams, to other hosts on an Internet Protocol (IP) network.
// Prior communications are not required in order to set up communication channels or data paths.
type UDP struct {
	Timestamp      int64   `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	SrcPort        int32   `protobuf:"varint,2,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	DstPort        int32   `protobuf:"varint,3,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
	Length         int32   `protobuf:"varint,4,opt,name=Length,proto3" json:"Length,omitempty"`
	Checksum       int32   `protobuf:"varint,5,opt,name=Checksum,proto3" json:"Checksum,omitempty"`
	PayloadEntropy float64 `protobuf:"fixed64,6,opt,name=PayloadEntropy,proto3" json:"PayloadEntropy,omitempty"`
	PayloadSize    int32   `protobuf:"varint,7,opt,name=PayloadSize,proto3" json:"PayloadSize,omitempty"`
	Payload        []byte  `protobuf:"bytes,8,opt,name=Payload,proto3" json:"Payload,omitempty"`
	SrcIP          string  `protobuf:"bytes,9,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP          string  `protobuf:"bytes,10,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
}

func (m *UDP) Reset()         { *m = UDP{} }
func (m *UDP) String() string { return proto.CompactTextString(m) }
func (*UDP) ProtoMessage()    {}
func (*UDP) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{35}
}
func (m *UDP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UDP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UDP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UDP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UDP.Merge(m, src)
}
func (m *UDP) XXX_Size() int {
	return m.Size()
}
func (m *UDP) XXX_DiscardUnknown() {
	xxx_messageInfo_UDP.DiscardUnknown(m)
}

var xxx_messageInfo_UDP proto.InternalMessageInfo

func (m *UDP) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *UDP) GetSrcPort() int32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *UDP) GetDstPort() int32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

func (m *UDP) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *UDP) GetChecksum() int32 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

func (m *UDP) GetPayloadEntropy() float64 {
	if m != nil {
		return m.PayloadEntropy
	}
	return 0
}

func (m *UDP) GetPayloadSize() int32 {
	if m != nil {
		return m.PayloadSize
	}
	return 0
}

func (m *UDP) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *UDP) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *UDP) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

// The Transmission Control Protocol (TCP) is one of the main protocols of the Internet
// protocol suite. It originated in the initial network implementation in which it
// complemented the Internet Protocol (IP). Therefore, the entire suite is commonly
// referred to as TCP/IP. TCP provides reliable, ordered, and error-checked delivery of
// a stream of octets (bytes) between applications running on hosts communicating via an
// IP network. Major internet applications such as the World Wide Web, email, remote
// administration, and file transfer rely on TCP, which is part of the Transport Layer
// of the TCP/IP suite. SSL/TLS often runs on top of TCP.
type TCP struct {
	Timestamp      int64        `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	SrcPort        int32        `protobuf:"varint,2,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	DstPort        int32        `protobuf:"varint,3,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
	SeqNum         uint32       `protobuf:"varint,4,opt,name=SeqNum,proto3" json:"SeqNum,omitempty"`
	AckNum         uint32       `protobuf:"varint,5,opt,name=AckNum,proto3" json:"AckNum,omitempty"`
	DataOffset     int32        `protobuf:"varint,6,opt,name=DataOffset,proto3" json:"DataOffset,omitempty"`
	FIN            bool         `protobuf:"varint,7,opt,name=FIN,proto3" json:"FIN,omitempty"`
	SYN            bool         `protobuf:"varint,8,opt,name=SYN,proto3" json:"SYN,omitempty"`
	RST            bool         `protobuf:"varint,9,opt,name=RST,proto3" json:"RST,omitempty"`
	PSH            bool         `protobuf:"varint,10,opt,name=PSH,proto3" json:"PSH,omitempty"`
	ACK            bool         `protobuf:"varint,11,opt,name=ACK,proto3" json:"ACK,omitempty"`
	URG            bool         `protobuf:"varint,12,opt,name=URG,proto3" json:"URG,omitempty"`
	ECE            bool         `protobuf:"varint,13,opt,name=ECE,proto3" json:"ECE,omitempty"`
	CWR            bool         `protobuf:"varint,14,opt,name=CWR,proto3" json:"CWR,omitempty"`
	NS             bool         `protobuf:"varint,15,opt,name=NS,proto3" json:"NS,omitempty"`
	Window         int32        `protobuf:"varint,16,opt,name=Window,proto3" json:"Window,omitempty"`
	Checksum       int32        `protobuf:"varint,17,opt,name=Checksum,proto3" json:"Checksum,omitempty"`
	Urgent         int32        `protobuf:"varint,18,opt,name=Urgent,proto3" json:"Urgent,omitempty"`
	Padding        []byte       `protobuf:"bytes,19,opt,name=Padding,proto3" json:"Padding,omitempty"`
	Options        []*TCPOption `protobuf:"bytes,20,rep,name=Options,proto3" json:"Options,omitempty"`
	PayloadEntropy float64      `protobuf:"fixed64,21,opt,name=PayloadEntropy,proto3" json:"PayloadEntropy,omitempty"`
	PayloadSize    int32        `protobuf:"varint,22,opt,name=PayloadSize,proto3" json:"PayloadSize,omitempty"`
	Payload        []byte       `protobuf:"bytes,23,opt,name=Payload,proto3" json:"Payload,omitempty"`
	SrcIP          string       `protobuf:"bytes,24,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP          string       `protobuf:"bytes,25,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
}

func (m *TCP) Reset()         { *m = TCP{} }
func (m *TCP) String() string { return proto.CompactTextString(m) }
func (*TCP) ProtoMessage()    {}
func (*TCP) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{36}
}
func (m *TCP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TCP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TCP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TCP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TCP.Merge(m, src)
}
func (m *TCP) XXX_Size() int {
	return m.Size()
}
func (m *TCP) XXX_DiscardUnknown() {
	xxx_messageInfo_TCP.DiscardUnknown(m)
}

var xxx_messageInfo_TCP proto.InternalMessageInfo

func (m *TCP) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *TCP) GetSrcPort() int32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *TCP) GetDstPort() int32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

func (m *TCP) GetSeqNum() uint32 {
	if m != nil {
		return m.SeqNum
	}
	return 0
}

func (m *TCP) GetAckNum() uint32 {
	if m != nil {
		return m.AckNum
	}
	return 0
}

func (m *TCP) GetDataOffset() int32 {
	if m != nil {
		return m.DataOffset
	}
	return 0
}

func (m *TCP) GetFIN() bool {
	if m != nil {
		return m.FIN
	}
	return false
}

func (m *TCP) GetSYN() bool {
	if m != nil {
		return m.SYN
	}
	return false
}

func (m *TCP) GetRST() bool {
	if m != nil {
		return m.RST
	}
	return false
}

func (m *TCP) GetPSH() bool {
	if m != nil {
		return m.PSH
	}
	return false
}

func (m *TCP) GetACK() bool {
	if m != nil {
		return m.ACK
	}
	return false
}

func (m *TCP) GetURG() bool {
	if m != nil {
		return m.URG
	}
	return false
}

func (m *TCP) GetECE() bool {
	if m != nil {
		return m.ECE
	}
	return false
}

func (m *TCP) GetCWR() bool {
	if m != nil {
		return m.CWR
	}
	return false
}

func (m *TCP) GetNS() bool {
	if m != nil {
		return m.NS
	}
	return false
}

func (m *TCP) GetWindow() int32 {
	if m != nil {
		return m.Window
	}
	return 0
}

func (m *TCP) GetChecksum() int32 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

func (m *TCP) GetUrgent() int32 {
	if m != nil {
		return m.Urgent
	}
	return 0
}

func (m *TCP) GetPadding() []byte {
	if m != nil {
		return m.Padding
	}
	return nil
}

func (m *TCP) GetOptions() []*TCPOption {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *TCP) GetPayloadEntropy() float64 {
	if m != nil {
		return m.PayloadEntropy
	}
	return 0
}

func (m *TCP) GetPayloadSize() int32 {
	if m != nil {
		return m.PayloadSize
	}
	return 0
}

func (m *TCP) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *TCP) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *TCP) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

type TCPOption struct {
	OptionType   int32  `protobuf:"varint,1,opt,name=OptionType,proto3" json:"OptionType,omitempty"`
	OptionLength int32  `protobuf:"varint,2,opt,name=OptionLength,proto3" json:"OptionLength,omitempty"`
	OptionData   []byte `protobuf:"bytes,3,opt,name=OptionData,proto3" json:"OptionData,omitempty"`
}

func (m *TCPOption) Reset()         { *m = TCPOption{} }
func (m *TCPOption) String() string { return proto.CompactTextString(m) }
func (*TCPOption) ProtoMessage()    {}
func (*TCPOption) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{37}
}
func (m *TCPOption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TCPOption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TCPOption.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TCPOption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TCPOption.Merge(m, src)
}
func (m *TCPOption) XXX_Size() int {
	return m.Size()
}
func (m *TCPOption) XXX_DiscardUnknown() {
	xxx_messageInfo_TCPOption.DiscardUnknown(m)
}

var xxx_messageInfo_TCPOption proto.InternalMessageInfo

func (m *TCPOption) GetOptionType() int32 {
	if m != nil {
		return m.OptionType
	}
	return 0
}

func (m *TCPOption) GetOptionLength() int32 {
	if m != nil {
		return m.OptionLength
	}
	return 0
}

func (m *TCPOption) GetOptionData() []byte {
	if m != nil {
		return m.OptionData
	}
	return nil
}

type SCTP struct {
	Timestamp       int64  `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	SrcPort         int32  `protobuf:"varint,2,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	DstPort         int32  `protobuf:"varint,3,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
	VerificationTag uint32 `protobuf:"varint,4,opt,name=VerificationTag,proto3" json:"VerificationTag,omitempty"`
	Checksum        uint32 `protobuf:"varint,5,opt,name=Checksum,proto3" json:"Checksum,omitempty"`
	SrcIP           string `protobuf:"bytes,6,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP           string `protobuf:"bytes,7,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
}

func (m *SCTP) Reset()         { *m = SCTP{} }
func (m *SCTP) String() string { return proto.CompactTextString(m) }
func (*SCTP) ProtoMessage()    {}
func (*SCTP) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{38}
}
func (m *SCTP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCTP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCTP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCTP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCTP.Merge(m, src)
}
func (m *SCTP) XXX_Size() int {
	return m.Size()
}
func (m *SCTP) XXX_DiscardUnknown() {
	xxx_messageInfo_SCTP.DiscardUnknown(m)
}

var xxx_messageInfo_SCTP proto.InternalMessageInfo

func (m *SCTP) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *SCTP) GetSrcPort() int32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *SCTP) GetDstPort() int32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

func (m *SCTP) GetVerificationTag() uint32 {
	if m != nil {
		return m.VerificationTag
	}
	return 0
}

func (m *SCTP) GetChecksum() uint32 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

func (m *SCTP) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *SCTP) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

// The Domain Name System (DNS) is a hierarchical and decentralized naming system
// for computers, services, or other resources connected to the Internet or a private
// network. It associates various information with domain names assigned to each of
// the participating entities. Most prominently, it translates more readily memorized
// domain names to the numerical IP addresses needed for locating and identifying
// computer services and devices with the underlying network protocols. By providing a
// worldwide, distributed directory service, the Domain Name System has been an essential
// component of the functionality of the Internet since 1985.
type DNS struct {
	Timestamp int64 `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	// Header fields
	ID           int32 `protobuf:"varint,2,opt,name=ID,proto3" json:"ID,omitempty"`
	QR           bool  `protobuf:"varint,3,opt,name=QR,proto3" json:"QR,omitempty"`
	OpCode       int32 `protobuf:"varint,4,opt,name=OpCode,proto3" json:"OpCode,omitempty"`
	AA           bool  `protobuf:"varint,5,opt,name=AA,proto3" json:"AA,omitempty"`
	TC           bool  `protobuf:"varint,6,opt,name=TC,proto3" json:"TC,omitempty"`
	RD           bool  `protobuf:"varint,7,opt,name=RD,proto3" json:"RD,omitempty"`
	RA           bool  `protobuf:"varint,8,opt,name=RA,proto3" json:"RA,omitempty"`
	Z            int32 `protobuf:"varint,9,opt,name=Z,proto3" json:"Z,omitempty"`
	ResponseCode int32 `protobuf:"varint,10,opt,name=ResponseCode,proto3" json:"ResponseCode,omitempty"`
	QDCount      int32 `protobuf:"varint,11,opt,name=QDCount,proto3" json:"QDCount,omitempty"`
	ANCount      int32 `protobuf:"varint,12,opt,name=ANCount,proto3" json:"ANCount,omitempty"`
	NSCount      int32 `protobuf:"varint,13,opt,name=NSCount,proto3" json:"NSCount,omitempty"`
	ARCount      int32 `protobuf:"varint,14,opt,name=ARCount,proto3" json:"ARCount,omitempty"`
	// Entries
	Questions   []*DNSQuestion       `protobuf:"bytes,15,rep,name=Questions,proto3" json:"Questions,omitempty"`
	Answers     []*DNSResourceRecord `protobuf:"bytes,16,rep,name=Answers,proto3" json:"Answers,omitempty"`
	Authorities []*DNSResourceRecord `protobuf:"bytes,17,rep,name=Authorities,proto3" json:"Authorities,omitempty"`
	Additionals []*DNSResourceRecord `protobuf:"bytes,18,rep,name=Additionals,proto3" json:"Additionals,omitempty"`
	SrcIP       string               `protobuf:"bytes,19,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP       string               `protobuf:"bytes,20,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
	SrcPort     int32                `protobuf:"varint,21,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	DstPort     int32                `protobuf:"varint,22,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
}

func (m *DNS) Reset()         { *m = DNS{} }
func (m *DNS) String() string { return proto.CompactTextString(m) }
func (*DNS) ProtoMessage()    {}
func (*DNS) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{39}
}
func (m *DNS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DNS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DNS.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DNS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DNS.Merge(m, src)
}
func (m *DNS) XXX_Size() int {
	return m.Size()
}
func (m *DNS) XXX_DiscardUnknown() {
	xxx_messageInfo_DNS.DiscardUnknown(m)
}

var xxx_messageInfo_DNS proto.InternalMessageInfo

func (m *DNS) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *DNS) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *DNS) GetQR() bool {
	if m != nil {
		return m.QR
	}
	return false
}

func (m *DNS) GetOpCode() int32 {
	if m != nil {
		return m.OpCode
	}
	return 0
}

func (m *DNS) GetAA() bool {
	if m != nil {
		return m.AA
	}
	return false
}

func (m *DNS) GetTC() bool {
	if m != nil {
		return m.TC
	}
	return false
}

func (m *DNS) GetRD() bool {
	if m != nil {
		return m.RD
	}
	return false
}

func (m *DNS) GetRA() bool {
	if m != nil {
		return m.RA
	}
	return false
}

func (m *DNS) GetZ() int32 {
	if m != nil {
		return m.Z
	}
	return 0
}

func (m *DNS) GetResponseCode() int32 {
	if m != nil {
		return m.ResponseCode
	}
	return 0
}

func (m *DNS) GetQDCount() int32 {
	if m != nil {
		return m.QDCount
	}
	return 0
}

func (m *DNS) GetANCount() int32 {
	if m != nil {
		return m.ANCount
	}
	return 0
}

func (m *DNS) GetNSCount() int32 {
	if m != nil {
		return m.NSCount
	}
	return 0
}

func (m *DNS) GetARCount() int32 {
	if m != nil {
		return m.ARCount
	}
	return 0
}

func (m *DNS) GetQuestions() []*DNSQuestion {
	if m != nil {
		return m.Questions
	}
	return nil
}

func (m *DNS) GetAnswers() []*DNSResourceRecord {
	if m != nil {
		return m.Answers
	}
	return nil
}

func (m *DNS) GetAuthorities() []*DNSResourceRecord {
	if m != nil {
		return m.Authorities
	}
	return nil
}

func (m *DNS) GetAdditionals() []*DNSResourceRecord {
	if m != nil {
		return m.Additionals
	}
	return nil
}

func (m *DNS) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *DNS) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

func (m *DNS) GetSrcPort() int32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *DNS) GetDstPort() int32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

type DNSResourceRecord struct {
	// Header
	Name  string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Type  int32  `protobuf:"varint,2,opt,name=Type,proto3" json:"Type,omitempty"`
	Class int32  `protobuf:"varint,3,opt,name=Class,proto3" json:"Class,omitempty"`
	TTL   uint32 `protobuf:"varint,4,opt,name=TTL,proto3" json:"TTL,omitempty"`
	// RDATA Raw Values
	DataLength int32  `protobuf:"varint,5,opt,name=DataLength,proto3" json:"DataLength,omitempty"`
	Data       []byte `protobuf:"bytes,6,opt,name=Data,proto3" json:"Data,omitempty"`
	// RDATA Decoded Values
	IP    string   `protobuf:"bytes,7,opt,name=IP,proto3" json:"IP,omitempty"`
	NS    []byte   `protobuf:"bytes,8,opt,name=NS,proto3" json:"NS,omitempty"`
	CNAME []byte   `protobuf:"bytes,9,opt,name=CNAME,proto3" json:"CNAME,omitempty"`
	PTR   []byte   `protobuf:"bytes,10,opt,name=PTR,proto3" json:"PTR,omitempty"`
	SOA   *DNSSOA  `protobuf:"bytes,11,opt,name=SOA,proto3" json:"SOA,omitempty"`
	SRV   *DNSSRV  `protobuf:"bytes,12,opt,name=SRV,proto3" json:"SRV,omitempty"`
	MX    *DNSMX   `protobuf:"bytes,13,opt,name=MX,proto3" json:"MX,omitempty"`
	TXTs  [][]byte `protobuf:"bytes,14,rep,name=TXTs,proto3" json:"TXTs,omitempty"`
}

func (m *DNSResourceRecord) Reset()         { *m = DNSResourceRecord{} }
func (m *DNSResourceRecord) String() string { return proto.CompactTextString(m) }
func (*DNSResourceRecord) ProtoMessage()    {}
func (*DNSResourceRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{40}
}
func (m *DNSResourceRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DNSResourceRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DNSResourceRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DNSResourceRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DNSResourceRecord.Merge(m, src)
}
func (m *DNSResourceRecord) XXX_Size() int {
	return m.Size()
}
func (m *DNSResourceRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_DNSResourceRecord.DiscardUnknown(m)
}

var xxx_messageInfo_DNSResourceRecord proto.InternalMessageInfo

func (m *DNSResourceRecord) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DNSResourceRecord) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *DNSResourceRecord) GetClass() int32 {
	if m != nil {
		return m.Class
	}
	return 0
}

func (m *DNSResourceRecord) GetTTL() uint32 {
	if m != nil {
		return m.TTL
	}
	return 0
}

func (m *DNSResourceRecord) GetDataLength() int32 {
	if m != nil {
		return m.DataLength
	}
	return 0
}

func (m *DNSResourceRecord) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *DNSResourceRecord) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

func (m *DNSResourceRecord) GetNS() []byte {
	if m != nil {
		return m.NS
	}
	return nil
}

func (m *DNSResourceRecord) GetCNAME() []byte {
	if m != nil {
		return m.CNAME
	}
	return nil
}

func (m *DNSResourceRecord) GetPTR() []byte {
	if m != nil {
		return m.PTR
	}
	return nil
}

func (m *DNSResourceRecord) GetSOA() *DNSSOA {
	if m != nil {
		return m.SOA
	}
	return nil
}

func (m *DNSResourceRecord) GetSRV() *DNSSRV {
	if m != nil {
		return m.SRV
	}
	return nil
}

func (m *DNSResourceRecord) GetMX() *DNSMX {
	if m != nil {
		return m.MX
	}
	return nil
}

func (m *DNSResourceRecord) GetTXTs() [][]byte {
	if m != nil {
		return m.TXTs
	}
	return nil
}

// DNSSOA is a Start of Authority record.
// Each domain requires a SOA record at the cutover where a domain is delegated from its parent.
type DNSSOA struct {
	MName   []byte `protobuf:"bytes,1,opt,name=MName,proto3" json:"MName,omitempty"`
	RName   []byte `protobuf:"bytes,2,opt,name=RName,proto3" json:"RName,omitempty"`
	Serial  uint32 `protobuf:"varint,3,opt,name=Serial,proto3" json:"Serial,omitempty"`
	Refresh uint32 `protobuf:"varint,4,opt,name=Refresh,proto3" json:"Refresh,omitempty"`
	Retry   uint32 `protobuf:"varint,5,opt,name=Retry,proto3" json:"Retry,omitempty"`
	Expire  uint32 `protobuf:"varint,6,opt,name=Expire,proto3" json:"Expire,omitempty"`
	Minimum uint32 `protobuf:"varint,7,opt,name=Minimum,proto3" json:"Minimum,omitempty"`
}

func (m *DNSSOA) Reset()         { *m = DNSSOA{} }
func (m *DNSSOA) String() string { return proto.CompactTextString(m) }
func (*DNSSOA) ProtoMessage()    {}
func (*DNSSOA) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{41}
}
func (m *DNSSOA) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DNSSOA) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DNSSOA.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DNSSOA) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DNSSOA.Merge(m, src)
}
func (m *DNSSOA) XXX_Size() int {
	return m.Size()
}
func (m *DNSSOA) XXX_DiscardUnknown() {
	xxx_messageInfo_DNSSOA.DiscardUnknown(m)
}

var xxx_messageInfo_DNSSOA proto.InternalMessageInfo

func (m *DNSSOA) GetMName() []byte {
	if m != nil {
		return m.MName
	}
	return nil
}

func (m *DNSSOA) GetRName() []byte {
	if m != nil {
		return m.RName
	}
	return nil
}

func (m *DNSSOA) GetSerial() uint32 {
	if m != nil {
		return m.Serial
	}
	return 0
}

func (m *DNSSOA) GetRefresh() uint32 {
	if m != nil {
		return m.Refresh
	}
	return 0
}

func (m *DNSSOA) GetRetry() uint32 {
	if m != nil {
		return m.Retry
	}
	return 0
}

func (m *DNSSOA) GetExpire() uint32 {
	if m != nil {
		return m.Expire
	}
	return 0
}

func (m *DNSSOA) GetMinimum() uint32 {
	if m != nil {
		return m.Minimum
	}
	return 0
}

// DNSSRV is a Service record, defining a location (hostname/port) of a server/service.
type DNSSRV struct {
	Priority int32  `protobuf:"varint,1,opt,name=Priority,proto3" json:"Priority,omitempty"`
	Weight   int32  `protobuf:"varint,2,opt,name=Weight,proto3" json:"Weight,omitempty"`
	Port     int32  `protobuf:"varint,3,opt,name=Port,proto3" json:"Port,omitempty"`
	Name     []byte `protobuf:"bytes,4,opt,name=Name,proto3" json:"Name,omitempty"`
}

func (m *DNSSRV) Reset()         { *m = DNSSRV{} }
func (m *DNSSRV) String() string { return proto.CompactTextString(m) }
func (*DNSSRV) ProtoMessage()    {}
func (*DNSSRV) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{42}
}
func (m *DNSSRV) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DNSSRV) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DNSSRV.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DNSSRV) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DNSSRV.Merge(m, src)
}
func (m *DNSSRV) XXX_Size() int {
	return m.Size()
}
func (m *DNSSRV) XXX_DiscardUnknown() {
	xxx_messageInfo_DNSSRV.DiscardUnknown(m)
}

var xxx_messageInfo_DNSSRV proto.InternalMessageInfo

func (m *DNSSRV) GetPriority() int32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *DNSSRV) GetWeight() int32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *DNSSRV) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *DNSSRV) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

// DNSMX is a mail exchange record, defining a mail server for a recipient's domain.
type DNSMX struct {
	Preference int32  `protobuf:"varint,1,opt,name=Preference,proto3" json:"Preference,omitempty"`
	Name       string `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
}

func (m *DNSMX) Reset()         { *m = DNSMX{} }
func (m *DNSMX) String() string { return proto.CompactTextString(m) }
func (*DNSMX) ProtoMessage()    {}
func (*DNSMX) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{43}
}
func (m *DNSMX) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DNSMX) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DNSMX.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DNSMX) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DNSMX.Merge(m, src)
}
func (m *DNSMX) XXX_Size() int {
	return m.Size()
}
func (m *DNSMX) XXX_DiscardUnknown() {
	xxx_messageInfo_DNSMX.DiscardUnknown(m)
}

var xxx_messageInfo_DNSMX proto.InternalMessageInfo

func (m *DNSMX) GetPreference() int32 {
	if m != nil {
		return m.Preference
	}
	return 0
}

func (m *DNSMX) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// DNSQuestion wraps a single request (question) within a DNS query.
type DNSQuestion struct {
	Name  string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Type  int32  `protobuf:"varint,2,opt,name=Type,proto3" json:"Type,omitempty"`
	Class int32  `protobuf:"varint,3,opt,name=Class,proto3" json:"Class,omitempty"`
}

func (m *DNSQuestion) Reset()         { *m = DNSQuestion{} }
func (m *DNSQuestion) String() string { return proto.CompactTextString(m) }
func (*DNSQuestion) ProtoMessage()    {}
func (*DNSQuestion) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{44}
}
func (m *DNSQuestion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DNSQuestion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DNSQuestion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DNSQuestion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DNSQuestion.Merge(m, src)
}
func (m *DNSQuestion) XXX_Size() int {
	return m.Size()
}
func (m *DNSQuestion) XXX_DiscardUnknown() {
	xxx_messageInfo_DNSQuestion.DiscardUnknown(m)
}

var xxx_messageInfo_DNSQuestion proto.InternalMessageInfo

func (m *DNSQuestion) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DNSQuestion) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *DNSQuestion) GetClass() int32 {
	if m != nil {
		return m.Class
	}
	return 0
}

type DHCPv4 struct {
	Timestamp    int64         `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Operation    int32         `protobuf:"varint,2,opt,name=Operation,proto3" json:"Operation,omitempty"`
	HardwareType int32         `protobuf:"varint,3,opt,name=HardwareType,proto3" json:"HardwareType,omitempty"`
	HardwareLen  int32         `protobuf:"varint,4,opt,name=HardwareLen,proto3" json:"HardwareLen,omitempty"`
	HardwareOpts int32         `protobuf:"varint,5,opt,name=HardwareOpts,proto3" json:"HardwareOpts,omitempty"`
	Xid          uint32        `protobuf:"varint,6,opt,name=Xid,proto3" json:"Xid,omitempty"`
	Secs         int32         `protobuf:"varint,7,opt,name=Secs,proto3" json:"Secs,omitempty"`
	Flags        int32         `protobuf:"varint,8,opt,name=Flags,proto3" json:"Flags,omitempty"`
	ClientIP     string        `protobuf:"bytes,9,opt,name=ClientIP,proto3" json:"ClientIP,omitempty"`
	YourClientIP string        `protobuf:"bytes,10,opt,name=YourClientIP,proto3" json:"YourClientIP,omitempty"`
	NextServerIP string        `protobuf:"bytes,11,opt,name=NextServerIP,proto3" json:"NextServerIP,omitempty"`
	RelayAgentIP string        `protobuf:"bytes,12,opt,name=RelayAgentIP,proto3" json:"RelayAgentIP,omitempty"`
	ClientHWAddr string        `protobuf:"bytes,13,opt,name=ClientHWAddr,proto3" json:"ClientHWAddr,omitempty"`
	ServerName   []byte        `protobuf:"bytes,14,opt,name=ServerName,proto3" json:"ServerName,omitempty"`
	File         []byte        `protobuf:"bytes,15,opt,name=File,proto3" json:"File,omitempty"`
	Options      []*DHCPOption `protobuf:"bytes,16,rep,name=Options,proto3" json:"Options,omitempty"`
	Fingerprint  string        `protobuf:"bytes,17,opt,name=Fingerprint,proto3" json:"Fingerprint,omitempty"`
	SrcIP        string        `protobuf:"bytes,18,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP        string        `protobuf:"bytes,19,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
	SrcPort      int32         `protobuf:"varint,20,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	DstPort      int32         `protobuf:"varint,21,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
}

func (m *DHCPv4) Reset()         { *m = DHCPv4{} }
func (m *DHCPv4) String() string { return proto.CompactTextString(m) }
func (*DHCPv4) ProtoMessage()    {}
func (*DHCPv4) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{45}
}
func (m *DHCPv4) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DHCPv4) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DHCPv4.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DHCPv4) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DHCPv4.Merge(m, src)
}
func (m *DHCPv4) XXX_Size() int {
	return m.Size()
}
func (m *DHCPv4) XXX_DiscardUnknown() {
	xxx_messageInfo_DHCPv4.DiscardUnknown(m)
}

var xxx_messageInfo_DHCPv4 proto.InternalMessageInfo

func (m *DHCPv4) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *DHCPv4) GetOperation() int32 {
	if m != nil {
		return m.Operation
	}
	return 0
}

func (m *DHCPv4) GetHardwareType() int32 {
	if m != nil {
		return m.HardwareType
	}
	return 0
}

func (m *DHCPv4) GetHardwareLen() int32 {
	if m != nil {
		return m.HardwareLen
	}
	return 0
}

func (m *DHCPv4) GetHardwareOpts() int32 {
	if m != nil {
		return m.HardwareOpts
	}
	return 0
}

func (m *DHCPv4) GetXid() uint32 {
	if m != nil {
		return m.Xid
	}
	return 0
}

func (m *DHCPv4) GetSecs() int32 {
	if m != nil {
		return m.Secs
	}
	return 0
}

func (m *DHCPv4) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *DHCPv4) GetClientIP() string {
	if m != nil {
		return m.ClientIP
	}
	return ""
}

func (m *DHCPv4) GetYourClientIP() string {
	if m != nil {
		return m.YourClientIP
	}
	return ""
}

func (m *DHCPv4) GetNextServerIP() string {
	if m != nil {
		return m.NextServerIP
	}
	return ""
}

func (m *DHCPv4) GetRelayAgentIP() string {
	if m != nil {
		return m.RelayAgentIP
	}
	return ""
}

func (m *DHCPv4) GetClientHWAddr() string {
	if m != nil {
		return m.ClientHWAddr
	}
	return ""
}

func (m *DHCPv4) GetServerName() []byte {
	if m != nil {
		return m.ServerName
	}
	return nil
}

func (m *DHCPv4) GetFile() []byte {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *DHCPv4) GetOptions() []*DHCPOption {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *DHCPv4) GetFingerprint() string {
	if m != nil {
		return m.Fingerprint
	}
	return ""
}

func (m *DHCPv4) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *DHCPv4) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

func (m *DHCPv4) GetSrcPort() int32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *DHCPv4) GetDstPort() int32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

type DHCPOption struct {
	Type   int32  `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Length int32  `protobuf:"varint,2,opt,name=Length,proto3" json:"Length,omitempty"`
	Data   string `protobuf:"bytes,3,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *DHCPOption) Reset()         { *m = DHCPOption{} }
func (m *DHCPOption) String() string { return proto.CompactTextString(m) }
func (*DHCPOption) ProtoMessage()    {}
func (*DHCPOption) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{46}
}
func (m *DHCPOption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DHCPOption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DHCPOption.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DHCPOption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DHCPOption.Merge(m, src)
}
func (m *DHCPOption) XXX_Size() int {
	return m.Size()
}
func (m *DHCPOption) XXX_DiscardUnknown() {
	xxx_messageInfo_DHCPOption.DiscardUnknown(m)
}

var xxx_messageInfo_DHCPOption proto.InternalMessageInfo

func (m *DHCPOption) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *DHCPOption) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *DHCPOption) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

type DHCPv6 struct {
	Timestamp     int64           `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	MsgType       int32           `protobuf:"varint,2,opt,name=MsgType,proto3" json:"MsgType,omitempty"`
	HopCount      int32           `protobuf:"varint,3,opt,name=HopCount,proto3" json:"HopCount,omitempty"`
	LinkAddr      string          `protobuf:"bytes,4,opt,name=LinkAddr,proto3" json:"LinkAddr,omitempty"`
	PeerAddr      string          `protobuf:"bytes,5,opt,name=PeerAddr,proto3" json:"PeerAddr,omitempty"`
	TransactionID []byte          `protobuf:"bytes,6,opt,name=TransactionID,proto3" json:"TransactionID,omitempty"`
	Options       []*DHCPv6Option `protobuf:"bytes,7,rep,name=Options,proto3" json:"Options,omitempty"`
	Fingerprint   string          `protobuf:"bytes,8,opt,name=Fingerprint,proto3" json:"Fingerprint,omitempty"`
	SrcIP         string          `protobuf:"bytes,9,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP         string          `protobuf:"bytes,10,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
	SrcPort       int32           `protobuf:"varint,11,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	DstPort       int32           `protobuf:"varint,12,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
}

func (m *DHCPv6) Reset()         { *m = DHCPv6{} }
func (m *DHCPv6) String() string { return proto.CompactTextString(m) }
func (*DHCPv6) ProtoMessage()    {}
func (*DHCPv6) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{47}
}
func (m *DHCPv6) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DHCPv6) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DHCPv6.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DHCPv6) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DHCPv6.Merge(m, src)
}
func (m *DHCPv6) XXX_Size() int {
	return m.Size()
}
func (m *DHCPv6) XXX_DiscardUnknown() {
	xxx_messageInfo_DHCPv6.DiscardUnknown(m)
}

var xxx_messageInfo_DHCPv6 proto.InternalMessageInfo

func (m *DHCPv6) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *DHCPv6) GetMsgType() int32 {
	if m != nil {
		return m.MsgType
	}
	return 0
}

func (m *DHCPv6) GetHopCount() int32 {
	if m != nil {
		return m.HopCount
	}
	return 0
}

func (m *DHCPv6) GetLinkAddr() string {
	if m != nil {
		return m.LinkAddr
	}
	return ""
}

func (m *DHCPv6) GetPeerAddr() string {
	if m != nil {
		return m.PeerAddr
	}
	return ""
}

func (m *DHCPv6) GetTransactionID() []byte {
	if m != nil {
		return m.TransactionID
	}
	return nil
}

func (m *DHCPv6) GetOptions() []*DHCPv6Option {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *DHCPv6) GetFingerprint() string {
	if m != nil {
		return m.Fingerprint
	}
	return ""
}

func (m *DHCPv6) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *DHCPv6) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

func (m *DHCPv6) GetSrcPort() int32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *DHCPv6) GetDstPort() int32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

type DHCPv6Option struct {
	Code   int32  `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Length int32  `protobuf:"varint,2,opt,name=Length,proto3" json:"Length,omitempty"`
	Data   string `protobuf:"bytes,3,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *DHCPv6Option) Reset()         { *m = DHCPv6Option{} }
func (m *DHCPv6Option) String() string { return proto.CompactTextString(m) }
func (*DHCPv6Option) ProtoMessage()    {}
func (*DHCPv6Option) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{48}
}
func (m *DHCPv6Option) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DHCPv6Option) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DHCPv6Option.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DHCPv6Option) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DHCPv6Option.Merge(m, src)
}
func (m *DHCPv6Option) XXX_Size() int {
	return m.Size()
}
func (m *DHCPv6Option) XXX_DiscardUnknown() {
	xxx_messageInfo_DHCPv6Option.DiscardUnknown(m)
}

var xxx_messageInfo_DHCPv6Option proto.InternalMessageInfo

func (m *DHCPv6Option) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *DHCPv6Option) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *DHCPv6Option) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

// LLC is the layer used for 802.2 Logical Link Control headers.
// See http://standards.ieee.org/getieee802/download/802.2-1998.pdf
type LLC struct {
	Timestamp int64 `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	DSAP      int32 `protobuf:"varint,2,opt,name=DSAP,proto3" json:"DSAP,omitempty"`
	IG        bool  `protobuf:"varint,3,opt,name=IG,proto3" json:"IG,omitempty"`
	SSAP      int32 `protobuf:"varint,4,opt,name=SSAP,proto3" json:"SSAP,omitempty"`
	CR        bool  `protobuf:"varint,5,opt,name=CR,proto3" json:"CR,omitempty"`
	Control   int32 `protobuf:"varint,6,opt,name=Control,proto3" json:"Control,omitempty"`
}

func (m *LLC) Reset()         { *m = LLC{} }
func (m *LLC) String() string { return proto.CompactTextString(m) }
func (*LLC) ProtoMessage()    {}
func (*LLC) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{49}
}
func (m *LLC) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LLC) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LLC.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LLC) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LLC.Merge(m, src)
}
func (m *LLC) XXX_Size() int {
	return m.Size()
}
func (m *LLC) XXX_DiscardUnknown() {
	xxx_messageInfo_LLC.DiscardUnknown(m)
}

var xxx_messageInfo_LLC proto.InternalMessageInfo

func (m *LLC) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *LLC) GetDSAP() int32 {
	if m != nil {
		return m.DSAP
	}
	return 0
}

func (m *LLC) GetIG() bool {
	if m != nil {
		return m.IG
	}
	return false
}

func (m *LLC) GetSSAP() int32 {
	if m != nil {
		return m.SSAP
	}
	return 0
}

func (m *LLC) GetCR() bool {
	if m != nil {
		return m.CR
	}
	return false
}

func (m *LLC) GetControl() int32 {
	if m != nil {
		return m.Control
	}
	return 0
}

// The Network Time Protocol (NTP) is a networking protocol for clock
// synchronization between computer systems over packet-switched, variable-latency
// data networks. In operation since before 1985, NTP is one of the oldest Internet
// protocols in current use. NTP was designed by David L. Mills of the University of Delaware.
type NTP struct {
	Timestamp          int64  `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	LeapIndicator      int32  `protobuf:"varint,2,opt,name=LeapIndicator,proto3" json:"LeapIndicator,omitempty"`
	Version            int32  `protobuf:"varint,3,opt,name=Version,proto3" json:"Version,omitempty"`
	Mode               int32  `protobuf:"varint,4,opt,name=Mode,proto3" json:"Mode,omitempty"`
	Stratum            int32  `protobuf:"varint,5,opt,name=Stratum,proto3" json:"Stratum,omitempty"`
	Poll               int32  `protobuf:"varint,6,opt,name=Poll,proto3" json:"Poll,omitempty"`
	Precision          int32  `protobuf:"varint,7,opt,name=Precision,proto3" json:"Precision,omitempty"`
	RootDelay          uint32 `protobuf:"varint,8,opt,name=RootDelay,proto3" json:"RootDelay,omitempty"`
	RootDispersion     uint32 `protobuf:"varint,9,opt,name=RootDispersion,proto3" json:"RootDispersion,omitempty"`
	ReferenceID        uint32 `protobuf:"varint,10,opt,name=ReferenceID,proto3" json:"ReferenceID,omitempty"`
	ReferenceTimestamp uint64 `protobuf:"varint,11,opt,name=ReferenceTimestamp,proto3" json:"ReferenceTimestamp,omitempty"`
	OriginTimestamp    uint64 `protobuf:"varint,12,opt,name=OriginTimestamp,proto3" json:"OriginTimestamp,omitempty"`
	ReceiveTimestamp   uint64 `protobuf:"varint,13,opt,name=ReceiveTimestamp,proto3" json:"ReceiveTimestamp,omitempty"`
	TransmitTimestamp  uint64 `protobuf:"varint,14,opt,name=TransmitTimestamp,proto3" json:"TransmitTimestamp,omitempty"`
	ExtensionBytes     []byte `protobuf:"bytes,15,opt,name=ExtensionBytes,proto3" json:"ExtensionBytes,omitempty"`
	SrcIP              string `protobuf:"bytes,16,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP              string `protobuf:"bytes,17,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
	SrcPort            int32  `protobuf:"varint,18,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	DstPort            int32  `protobuf:"varint,19,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
}

func (m *NTP) Reset()         { *m = NTP{} }
func (m *NTP) String() string { return proto.CompactTextString(m) }
func (*NTP) ProtoMessage()    {}
func (*NTP) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{50}
}
func (m *NTP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NTP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NTP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NTP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NTP.Merge(m, src)
}
func (m *NTP) XXX_Size() int {
	return m.Size()
}
func (m *NTP) XXX_DiscardUnknown() {
	xxx_messageInfo_NTP.DiscardUnknown(m)
}

var xxx_messageInfo_NTP proto.InternalMessageInfo

func (m *NTP) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *NTP) GetLeapIndicator() int32 {
	if m != nil {
		return m.LeapIndicator
	}
	return 0
}

func (m *NTP) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *NTP) GetMode() int32 {
	if m != nil {
		return m.Mode
	}
	return 0
}

func (m *NTP) GetStratum() int32 {
	if m != nil {
		return m.Stratum
	}
	return 0
}

func (m *NTP) GetPoll() int32 {
	if m != nil {
		return m.Poll
	}
	return 0
}

func (m *NTP) GetPrecision() int32 {
	if m != nil {
		return m.Precision
	}
	return 0
}

func (m *NTP) GetRootDelay() uint32 {
	if m != nil {
		return m.RootDelay
	}
	return 0
}

func (m *NTP) GetRootDispersion() uint32 {
	if m != nil {
		return m.RootDispersion
	}
	return 0
}

func (m *NTP) GetReferenceID() uint32 {
	if m != nil {
		return m.ReferenceID
	}
	return 0
}

func (m *NTP) GetReferenceTimestamp() uint64 {
	if m != nil {
		return m.ReferenceTimestamp
	}
	return 0
}

func (m *NTP) GetOriginTimestamp() uint64 {
	if m != nil {
		return m.OriginTimestamp
	}
	return 0
}

func (m *NTP) GetReceiveTimestamp() uint64 {
	if m != nil {
		return m.ReceiveTimestamp
	}
	return 0
}

func (m *NTP) GetTransmitTimestamp() uint64 {
	if m != nil {
		return m.TransmitTimestamp
	}
	return 0
}

func (m *NTP) GetExtensionBytes() []byte {
	if m != nil {
		return m.ExtensionBytes
	}
	return nil
}

func (m *NTP) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *NTP) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

func (m *NTP) GetSrcPort() int32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *NTP) GetDstPort() int32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

// The Session Initiation Protocol (SIP) is a signalling protocol used for initiating, maintaining, and terminating real-time sessions that include voice, video and messaging applications
type SIP struct {
	Timestamp int64 `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	// Base information
	Version int32 `protobuf:"varint,2,opt,name=Version,proto3" json:"Version,omitempty"`
	Method  int32 `protobuf:"varint,3,opt,name=Method,proto3" json:"Method,omitempty"`
	//map[string][]string Headers
	Headers []string `protobuf:"bytes,4,rep,name=Headers,proto3" json:"Headers,omitempty"`
	// Response
	IsResponse     bool   `protobuf:"varint,5,opt,name=IsResponse,proto3" json:"IsResponse,omitempty"`
	ResponseCode   int32  `protobuf:"varint,6,opt,name=ResponseCode,proto3" json:"ResponseCode,omitempty"`
	ResponseStatus string `protobuf:"bytes,7,opt,name=ResponseStatus,proto3" json:"ResponseStatus,omitempty"`
	SrcIP          string `protobuf:"bytes,8,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP          string `protobuf:"bytes,9,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
	SrcPort        int32  `protobuf:"varint,10,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	DstPort        int32  `protobuf:"varint,11,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
}

func (m *SIP) Reset()         { *m = SIP{} }
func (m *SIP) String() string { return proto.CompactTextString(m) }
func (*SIP) ProtoMessage()    {}
func (*SIP) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{51}
}
func (m *SIP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SIP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SIP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SIP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SIP.Merge(m, src)
}
func (m *SIP) XXX_Size() int {
	return m.Size()
}
func (m *SIP) XXX_DiscardUnknown() {
	xxx_messageInfo_SIP.DiscardUnknown(m)
}

var xxx_messageInfo_SIP proto.InternalMessageInfo

func (m *SIP) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *SIP) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *SIP) GetMethod() int32 {
	if m != nil {
		return m.Method
	}
	return 0
}

func (m *SIP) GetHeaders() []string {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *SIP) GetIsResponse() bool {
	if m != nil {
		return m.IsResponse
	}
	return false
}

func (m *SIP) GetResponseCode() int32 {
	if m != nil {
		return m.ResponseCode
	}
	return 0
}

func (m *SIP) GetResponseStatus() string {
	if m != nil {
		return m.ResponseStatus
	}
	return ""
}

func (m *SIP) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *SIP) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

func (m *SIP) GetSrcPort() int32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *SIP) GetDstPort() int32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

// The Internet Group Management Protocol (IGMP) is a communications protocol
// used by hosts and adjacent routers on IPv4 networks to establish multicast
// group memberships. IGMP is an integral part of IP multicast.
// IGMP can be used for one-to-many networking applications such as online streaming
// video and gaming, and allows more efficient use of resources when supporting these
// types of applications. IGMP is used on IPv4 networks. Multicast management on IPv6
// networks is handled by Multicast Listener Discovery (MLD) which is a part of ICMPv6
// in contrast to IGMP's bare IP encapsulation.
type IGMP struct {
	Timestamp               int64                `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Type                    int32                `protobuf:"varint,2,opt,name=Type,proto3" json:"Type,omitempty"`
	MaxResponseTime         uint64               `protobuf:"varint,3,opt,name=MaxResponseTime,proto3" json:"MaxResponseTime,omitempty"`
	Checksum                int32                `protobuf:"varint,4,opt,name=Checksum,proto3" json:"Checksum,omitempty"`
	GroupAddress            string               `protobuf:"bytes,5,opt,name=GroupAddress,proto3" json:"GroupAddress,omitempty"`
	SupressRouterProcessing bool                 `protobuf:"varint,6,opt,name=SupressRouterProcessing,proto3" json:"SupressRouterProcessing,omitempty"`
	RobustnessValue         int32                `protobuf:"varint,7,opt,name=RobustnessValue,proto3" json:"RobustnessValue,omitempty"`
	IntervalTime            uint64               `protobuf:"varint,8,opt,name=IntervalTime,proto3" json:"IntervalTime,omitempty"`
	SourceAddresses         []string             `protobuf:"bytes,9,rep,name=SourceAddresses,proto3" json:"SourceAddresses,omitempty"`
	NumberOfGroupRecords    int32                `protobuf:"varint,10,opt,name=NumberOfGroupRecords,proto3" json:"NumberOfGroupRecords,omitempty"`
	NumberOfSources         int32                `protobuf:"varint,11,opt,name=NumberOfSources,proto3" json:"NumberOfSources,omitempty"`
	GroupRecords            []*IGMPv3GroupRecord `protobuf:"bytes,12,rep,name=GroupRecords,proto3" json:"GroupRecords,omitempty"`
	Version                 int32                `protobuf:"varint,13,opt,name=Version,proto3" json:"Version,omitempty"`
	SrcIP                   string               `protobuf:"bytes,14,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP                   string               `protobuf:"bytes,15,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
}

func (m *IGMP) Reset()         { *m = IGMP{} }
func (m *IGMP) String() string { return proto.CompactTextString(m) }
func (*IGMP) ProtoMessage()    {}
func (*IGMP) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{52}
}
func (m *IGMP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IGMP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IGMP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IGMP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IGMP.Merge(m, src)
}
func (m *IGMP) XXX_Size() int {
	return m.Size()
}
func (m *IGMP) XXX_DiscardUnknown() {
	xxx_messageInfo_IGMP.DiscardUnknown(m)
}

var xxx_messageInfo_IGMP proto.InternalMessageInfo

func (m *IGMP) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *IGMP) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *IGMP) GetMaxResponseTime() uint64 {
	if m != nil {
		return m.MaxResponseTime
	}
	return 0
}

func (m *IGMP) GetChecksum() int32 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

func (m *IGMP) GetGroupAddress() string {
	if m != nil {
		return m.GroupAddress
	}
	return ""
}

func (m *IGMP) GetSupressRouterProcessing() bool {
	if m != nil {
		return m.SupressRouterProcessing
	}
	return false
}

func (m *IGMP) GetRobustnessValue() int32 {
	if m != nil {
		return m.RobustnessValue
	}
	return 0
}

func (m *IGMP) GetIntervalTime() uint64 {
	if m != nil {
		return m.IntervalTime
	}
	return 0
}

func (m *IGMP) GetSourceAddresses() []string {
	if m != nil {
		return m.SourceAddresses
	}
	return nil
}

func (m *IGMP) GetNumberOfGroupRecords() int32 {
	if m != nil {
		return m.NumberOfGroupRecords
	}
	return 0
}

func (m *IGMP) GetNumberOfSources() int32 {
	if m != nil {
		return m.NumberOfSources
	}
	return 0
}

func (m *IGMP) GetGroupRecords() []*IGMPv3GroupRecord {
	if m != nil {
		return m.GroupRecords
	}
	return nil
}

func (m *IGMP) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *IGMP) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *IGMP) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

type IGMPv3GroupRecord struct {
	Type             int32    `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	AuxDataLen       int32    `protobuf:"varint,2,opt,name=AuxDataLen,proto3" json:"AuxDataLen,omitempty"`
	NumberOfSources  int32    `protobuf:"varint,3,opt,name=NumberOfSources,proto3" json:"NumberOfSources,omitempty"`
	MulticastAddress string   `protobuf:"bytes,4,opt,name=MulticastAddress,proto3" json:"MulticastAddress,omitempty"`
	SourceAddresses  []string `protobuf:"bytes,5,rep,name=SourceAddresses,proto3" json:"SourceAddresses,omitempty"`
}

func (m *IGMPv3GroupRecord) Reset()         { *m = IGMPv3GroupRecord{} }
func (m *IGMPv3GroupRecord) String() string { return proto.CompactTextString(m) }
func (*IGMPv3GroupRecord) ProtoMessage()    {}
func (*IGMPv3GroupRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{53}
}
func (m *IGMPv3GroupRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IGMPv3GroupRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IGMPv3GroupRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IGMPv3GroupRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IGMPv3GroupRecord.Merge(m, src)
}
func (m *IGMPv3GroupRecord) XXX_Size() int {
	return m.Size()
}
func (m *IGMPv3GroupRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_IGMPv3GroupRecord.DiscardUnknown(m)
}

var xxx_messageInfo_IGMPv3GroupRecord proto.InternalMessageInfo

func (m *IGMPv3GroupRecord) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *IGMPv3GroupRecord) GetAuxDataLen() int32 {
	if m != nil {
		return m.AuxDataLen
	}
	return 0
}

func (m *IGMPv3GroupRecord) GetNumberOfSources() int32 {
	if m != nil {
		return m.NumberOfSources
	}
	return 0
}

func (m *IGMPv3GroupRecord) GetMulticastAddress() string {
	if m != nil {
		return m.MulticastAddress
	}
	return ""
}

func (m *IGMPv3GroupRecord) GetSourceAddresses() []string {
	if m != nil {
		return m.SourceAddresses
	}
	return nil
}

type IPv6HopByHop struct {
	Timestamp int64                 `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Options   []*IPv6HopByHopOption `protobuf:"bytes,2,rep,name=Options,proto3" json:"Options,omitempty"`
	SrcIP     string                `protobuf:"bytes,3,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP     string                `protobuf:"bytes,4,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
}

func (m *IPv6HopByHop) Reset()         { *m = IPv6HopByHop{} }
func (m *IPv6HopByHop) String() string { return proto.CompactTextString(m) }
func (*IPv6HopByHop) ProtoMessage()    {}
func (*IPv6HopByHop) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{54}
}
func (m *IPv6HopByHop) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPv6HopByHop) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPv6HopByHop.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPv6HopByHop) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPv6HopByHop.Merge(m, src)
}
func (m *IPv6HopByHop) XXX_Size() int {
	return m.Size()
}
func (m *IPv6HopByHop) XXX_DiscardUnknown() {
	xxx_messageInfo_IPv6HopByHop.DiscardUnknown(m)
}

var xxx_messageInfo_IPv6HopByHop proto.InternalMessageInfo

func (m *IPv6HopByHop) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *IPv6HopByHop) GetOptions() []*IPv6HopByHopOption {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *IPv6HopByHop) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *IPv6HopByHop) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

type IPv6HopByHopOption struct {
	OptionType      int32                        `protobuf:"varint,1,opt,name=OptionType,proto3" json:"OptionType,omitempty"`
	OptionLength    int32                        `protobuf:"varint,2,opt,name=OptionLength,proto3" json:"OptionLength,omitempty"`
	ActualLength    int32                        `protobuf:"varint,3,opt,name=ActualLength,proto3" json:"ActualLength,omitempty"`
	OptionData      []byte                       `protobuf:"bytes,4,opt,name=OptionData,proto3" json:"OptionData,omitempty"`
	OptionAlignment *IPv6HopByHopOptionAlignment `protobuf:"bytes,5,opt,name=OptionAlignment,proto3" json:"OptionAlignment,omitempty"`
}

func (m *IPv6HopByHopOption) Reset()         { *m = IPv6HopByHopOption{} }
func (m *IPv6HopByHopOption) String() string { return proto.CompactTextString(m) }
func (*IPv6HopByHopOption) ProtoMessage()    {}
func (*IPv6HopByHopOption) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{55}
}
func (m *IPv6HopByHopOption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPv6HopByHopOption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPv6HopByHopOption.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPv6HopByHopOption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPv6HopByHopOption.Merge(m, src)
}
func (m *IPv6HopByHopOption) XXX_Size() int {
	return m.Size()
}
func (m *IPv6HopByHopOption) XXX_DiscardUnknown() {
	xxx_messageInfo_IPv6HopByHopOption.DiscardUnknown(m)
}

var xxx_messageInfo_IPv6HopByHopOption proto.InternalMessageInfo

func (m *IPv6HopByHopOption) GetOptionType() int32 {
	if m != nil {
		return m.OptionType
	}
	return 0
}

func (m *IPv6HopByHopOption) GetOptionLength() int32 {
	if m != nil {
		return m.OptionLength
	}
	return 0
}

func (m *IPv6HopByHopOption) GetActualLength() int32 {
	if m != nil {
		return m.ActualLength
	}
	return 0
}

func (m *IPv6HopByHopOption) GetOptionData() []byte {
	if m != nil {
		return m.OptionData
	}
	return nil
}

func (m *IPv6HopByHopOption) GetOptionAlignment() *IPv6HopByHopOptionAlignment {
	if m != nil {
		return m.OptionAlignment
	}
	return nil
}

type IPv6HopByHopOptionAlignment struct {
	One int32 `protobuf:"varint,1,opt,name=One,proto3" json:"One,omitempty"`
	Two int32 `protobuf:"varint,2,opt,name=Two,proto3" json:"Two,omitempty"`
}

func (m *IPv6HopByHopOptionAlignment) Reset()         { *m = IPv6HopByHopOptionAlignment{} }
func (m *IPv6HopByHopOptionAlignment) String() string { return proto.CompactTextString(m) }
func (*IPv6HopByHopOptionAlignment) ProtoMessage()    {}
func (*IPv6HopByHopOptionAlignment) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{56}
}
func (m *IPv6HopByHopOptionAlignment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPv6HopByHopOptionAlignment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPv6HopByHopOptionAlignment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPv6HopByHopOptionAlignment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPv6HopByHopOptionAlignment.Merge(m, src)
}
func (m *IPv6HopByHopOptionAlignment) XXX_Size() int {
	return m.Size()
}
func (m *IPv6HopByHopOptionAlignment) XXX_DiscardUnknown() {
	xxx_messageInfo_IPv6HopByHopOptionAlignment.DiscardUnknown(m)
}

var xxx_messageInfo_IPv6HopByHopOptionAlignment proto.InternalMessageInfo

func (m *IPv6HopByHopOptionAlignment) GetOne() int32 {
	if m != nil {
		return m.One
	}
	return 0
}

func (m *IPv6HopByHopOptionAlignment) GetTwo() int32 {
	if m != nil {
		return m.Two
	}
	return 0
}

// SNAP is used inside LLC. See http://standards.ieee.org/getieee802/download/802-2001.pdf. From http://en.wikipedia.org/wiki/Subnetwork_Access_Protocol:
// "[T]he Subnetwork Access Protocol (SNAP) is a mechanism for multiplexing,
// on networks using IEEE 802.2 LLC, more protocols than can be distinguished
// by the 8-bit 802.2 Service Access Point (SAP) fields."
type SNAP struct {
	Timestamp          int64  `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	OrganizationalCode []byte `protobuf:"bytes,2,opt,name=OrganizationalCode,proto3" json:"OrganizationalCode,omitempty"`
	Type               int32  `protobuf:"varint,3,opt,name=Type,proto3" json:"Type,omitempty"`
}

func (m *SNAP) Reset()         { *m = SNAP{} }
func (m *SNAP) String() string { return proto.CompactTextString(m) }
func (*SNAP) ProtoMessage()    {}
func (*SNAP) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{57}
}
func (m *SNAP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SNAP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SNAP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SNAP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SNAP.Merge(m, src)
}
func (m *SNAP) XXX_Size() int {
	return m.Size()
}
func (m *SNAP) XXX_DiscardUnknown() {
	xxx_messageInfo_SNAP.DiscardUnknown(m)
}

var xxx_messageInfo_SNAP proto.InternalMessageInfo

func (m *SNAP) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *SNAP) GetOrganizationalCode() []byte {
	if m != nil {
		return m.OrganizationalCode
	}
	return nil
}

func (m *SNAP) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

type ICMPv6Echo struct {
	Timestamp  int64  `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Identifier int32  `protobuf:"varint,2,opt,name=Identifier,proto3" json:"Identifier,omitempty"`
	SeqNumber  int32  `protobuf:"varint,3,opt,name=SeqNumber,proto3" json:"SeqNumber,omitempty"`
	SrcIP      string `protobuf:"bytes,4,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP      string `protobuf:"bytes,5,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
}

func (m *ICMPv6Echo) Reset()         { *m = ICMPv6Echo{} }
func (m *ICMPv6Echo) String() string { return proto.CompactTextString(m) }
func (*ICMPv6Echo) ProtoMessage()    {}
func (*ICMPv6Echo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{58}
}
func (m *ICMPv6Echo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ICMPv6Echo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ICMPv6Echo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ICMPv6Echo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ICMPv6Echo.Merge(m, src)
}
func (m *ICMPv6Echo) XXX_Size() int {
	return m.Size()
}
func (m *ICMPv6Echo) XXX_DiscardUnknown() {
	xxx_messageInfo_ICMPv6Echo.DiscardUnknown(m)
}

var xxx_messageInfo_ICMPv6Echo proto.InternalMessageInfo

func (m *ICMPv6Echo) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *ICMPv6Echo) GetIdentifier() int32 {
	if m != nil {
		return m.Identifier
	}
	return 0
}

func (m *ICMPv6Echo) GetSeqNumber() int32 {
	if m != nil {
		return m.SeqNumber
	}
	return 0
}

func (m *ICMPv6Echo) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *ICMPv6Echo) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

type ICMPv6NeighborSolicitation struct {
	Timestamp     int64           `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	TargetAddress string          `protobuf:"bytes,2,opt,name=TargetAddress,proto3" json:"TargetAddress,omitempty"`
	Options       []*ICMPv6Option `protobuf:"bytes,3,rep,name=Options,proto3" json:"Options,omitempty"`
	SrcIP         string          `protobuf:"bytes,4,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP         string          `protobuf:"bytes,5,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
}

func (m *ICMPv6NeighborSolicitation) Reset()         { *m = ICMPv6NeighborSolicitation{} }
func (m *ICMPv6NeighborSolicitation) String() string { return proto.CompactTextString(m) }
func (*ICMPv6NeighborSolicitation) ProtoMessage()    {}
func (*ICMPv6NeighborSolicitation) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{59}
}
func (m *ICMPv6NeighborSolicitation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ICMPv6NeighborSolicitation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ICMPv6NeighborSolicitation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ICMPv6NeighborSolicitation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ICMPv6NeighborSolicitation.Merge(m, src)
}
func (m *ICMPv6NeighborSolicitation) XXX_Size() int {
	return m.Size()
}
func (m *ICMPv6NeighborSolicitation) XXX_DiscardUnknown() {
	xxx_messageInfo_ICMPv6NeighborSolicitation.DiscardUnknown(m)
}

var xxx_messageInfo_ICMPv6NeighborSolicitation proto.InternalMessageInfo

func (m *ICMPv6NeighborSolicitation) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *ICMPv6NeighborSolicitation) GetTargetAddress() string {
	if m != nil {
		return m.TargetAddress
	}
	return ""
}

func (m *ICMPv6NeighborSolicitation) GetOptions() []*ICMPv6Option {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *ICMPv6NeighborSolicitation) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *ICMPv6NeighborSolicitation) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

type ICMPv6RouterSolicitation struct {
	Timestamp int64           `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Options   []*ICMPv6Option `protobuf:"bytes,2,rep,name=Options,proto3" json:"Options,omitempty"`
	SrcIP     string          `protobuf:"bytes,3,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP     string          `protobuf:"bytes,4,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
}

func (m *ICMPv6RouterSolicitation) Reset()         { *m = ICMPv6RouterSolicitation{} }
func (m *ICMPv6RouterSolicitation) String() string { return proto.CompactTextString(m) }
func (*ICMPv6RouterSolicitation) ProtoMessage()    {}
func (*ICMPv6RouterSolicitation) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{60}
}
func (m *ICMPv6RouterSolicitation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ICMPv6RouterSolicitation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ICMPv6RouterSolicitation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ICMPv6RouterSolicitation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ICMPv6RouterSolicitation.Merge(m, src)
}
func (m *ICMPv6RouterSolicitation) XXX_Size() int {
	return m.Size()
}
func (m *ICMPv6RouterSolicitation) XXX_DiscardUnknown() {
	xxx_messageInfo_ICMPv6RouterSolicitation.DiscardUnknown(m)
}

var xxx_messageInfo_ICMPv6RouterSolicitation proto.InternalMessageInfo

func (m *ICMPv6RouterSolicitation) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *ICMPv6RouterSolicitation) GetOptions() []*ICMPv6Option {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *ICMPv6RouterSolicitation) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *ICMPv6RouterSolicitation) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

// The Hypertext Transfer Protocol (HTTP) is an application protocol for distributed,
// collaborative, hypermedia information systems. HTTP is the foundation of data
// communication for the World Wide Web.
type HTTP struct {
	Timestamp          int64         `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Proto              string        `protobuf:"bytes,2,opt,name=Proto,proto3" json:"Proto,omitempty"`
	Method             string        `protobuf:"bytes,3,opt,name=Method,proto3" json:"Method,omitempty"`
	Host               string        `protobuf:"bytes,4,opt,name=Host,proto3" json:"Host,omitempty"`
	UserAgent          string        `protobuf:"bytes,5,opt,name=UserAgent,proto3" json:"UserAgent,omitempty"`
	Referer            string        `protobuf:"bytes,6,opt,name=Referer,proto3" json:"Referer,omitempty"`
	ReqCookies         []*HTTPCookie `protobuf:"bytes,7,rep,name=ReqCookies,proto3" json:"ReqCookies,omitempty"`
	ReqContentLength   int32         `protobuf:"varint,8,opt,name=ReqContentLength,proto3" json:"ReqContentLength,omitempty"`
	URL                string        `protobuf:"bytes,9,opt,name=URL,proto3" json:"URL,omitempty"`
	ResContentLength   int32         `protobuf:"varint,10,opt,name=ResContentLength,proto3" json:"ResContentLength,omitempty"`
	ContentType        string        `protobuf:"bytes,11,opt,name=ContentType,proto3" json:"ContentType,omitempty"`
	StatusCode         int32         `protobuf:"varint,12,opt,name=StatusCode,proto3" json:"StatusCode,omitempty"`
	SrcIP              string        `protobuf:"bytes,13,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP              string        `protobuf:"bytes,14,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
	ReqContentEncoding string        `protobuf:"bytes,15,opt,name=ReqContentEncoding,proto3" json:"ReqContentEncoding,omitempty"`
	ResContentEncoding string        `protobuf:"bytes,16,opt,name=ResContentEncoding,proto3" json:"ResContentEncoding,omitempty"`
	ServerName         string        `protobuf:"bytes,17,opt,name=ServerName,proto3" json:"ServerName,omitempty"`
	ResCookies         []*HTTPCookie `protobuf:"bytes,18,rep,name=ResCookies,proto3" json:"ResCookies,omitempty"`
	ResContentType     string        `protobuf:"bytes,19,opt,name=ResContentType,proto3" json:"ResContentType,omitempty"`
	// Time Deltas (Nanoseconds)
	// currently only available when using the HTTP proxy with tracing enabled.
	DoneAfter              int64             `protobuf:"varint,20,opt,name=DoneAfter,proto3" json:"DoneAfter,omitempty"`
	DNSDoneAfter           int64             `protobuf:"varint,21,opt,name=DNSDoneAfter,proto3" json:"DNSDoneAfter,omitempty"`
	FirstByteAfter         int64             `protobuf:"varint,22,opt,name=FirstByteAfter,proto3" json:"FirstByteAfter,omitempty"`
	TLSDoneAfter           int64             `protobuf:"varint,23,opt,name=TLSDoneAfter,proto3" json:"TLSDoneAfter,omitempty"`
	ContentTypeDetected    string            `protobuf:"bytes,24,opt,name=ContentTypeDetected,proto3" json:"ContentTypeDetected,omitempty"`
	ResContentTypeDetected string            `protobuf:"bytes,25,opt,name=ResContentTypeDetected,proto3" json:"ResContentTypeDetected,omitempty"`
	RequestHeader          map[string]string `protobuf:"bytes,26,rep,name=RequestHeader,proto3" json:"RequestHeader,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ResponseHeader         map[string]string `protobuf:"bytes,27,rep,name=ResponseHeader,proto3" json:"ResponseHeader,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Parameters             map[string]string `protobuf:"bytes,28,rep,name=Parameters,proto3" json:"Parameters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	RequestBody            []byte            `protobuf:"bytes,29,opt,name=RequestBody,proto3" json:"RequestBody,omitempty"`
	ResponseBody           []byte            `protobuf:"bytes,30,opt,name=ResponseBody,proto3" json:"ResponseBody,omitempty"`
}

func (m *HTTP) Reset()         { *m = HTTP{} }
func (m *HTTP) String() string { return proto.CompactTextString(m) }
func (*HTTP) ProtoMessage()    {}
func (*HTTP) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{61}
}
func (m *HTTP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HTTP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HTTP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HTTP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HTTP.Merge(m, src)
}
func (m *HTTP) XXX_Size() int {
	return m.Size()
}
func (m *HTTP) XXX_DiscardUnknown() {
	xxx_messageInfo_HTTP.DiscardUnknown(m)
}

var xxx_messageInfo_HTTP proto.InternalMessageInfo

func (m *HTTP) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *HTTP) GetProto() string {
	if m != nil {
		return m.Proto
	}
	return ""
}

func (m *HTTP) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *HTTP) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *HTTP) GetUserAgent() string {
	if m != nil {
		return m.UserAgent
	}
	return ""
}

func (m *HTTP) GetReferer() string {
	if m != nil {
		return m.Referer
	}
	return ""
}

func (m *HTTP) GetReqCookies() []*HTTPCookie {
	if m != nil {
		return m.ReqCookies
	}
	return nil
}

func (m *HTTP) GetReqContentLength() int32 {
	if m != nil {
		return m.ReqContentLength
	}
	return 0
}

func (m *HTTP) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

func (m *HTTP) GetResContentLength() int32 {
	if m != nil {
		return m.ResContentLength
	}
	return 0
}

func (m *HTTP) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

func (m *HTTP) GetStatusCode() int32 {
	if m != nil {
		return m.StatusCode
	}
	return 0
}

func (m *HTTP) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *HTTP) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

func (m *HTTP) GetReqContentEncoding() string {
	if m != nil {
		return m.ReqContentEncoding
	}
	return ""
}

func (m *HTTP) GetResContentEncoding() string {
	if m != nil {
		return m.ResContentEncoding
	}
	return ""
}

func (m *HTTP) GetServerName() string {
	if m != nil {
		return m.ServerName
	}
	return ""
}

func (m *HTTP) GetResCookies() []*HTTPCookie {
	if m != nil {
		return m.ResCookies
	}
	return nil
}

func (m *HTTP) GetResContentType() string {
	if m != nil {
		return m.ResContentType
	}
	return ""
}

func (m *HTTP) GetDoneAfter() int64 {
	if m != nil {
		return m.DoneAfter
	}
	return 0
}

func (m *HTTP) GetDNSDoneAfter() int64 {
	if m != nil {
		return m.DNSDoneAfter
	}
	return 0
}

func (m *HTTP) GetFirstByteAfter() int64 {
	if m != nil {
		return m.FirstByteAfter
	}
	return 0
}

func (m *HTTP) GetTLSDoneAfter() int64 {
	if m != nil {
		return m.TLSDoneAfter
	}
	return 0
}

func (m *HTTP) GetContentTypeDetected() string {
	if m != nil {
		return m.ContentTypeDetected
	}
	return ""
}

func (m *HTTP) GetResContentTypeDetected() string {
	if m != nil {
		return m.ResContentTypeDetected
	}
	return ""
}

func (m *HTTP) GetRequestHeader() map[string]string {
	if m != nil {
		return m.RequestHeader
	}
	return nil
}

func (m *HTTP) GetResponseHeader() map[string]string {
	if m != nil {
		return m.ResponseHeader
	}
	return nil
}

func (m *HTTP) GetParameters() map[string]string {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *HTTP) GetRequestBody() []byte {
	if m != nil {
		return m.RequestBody
	}
	return nil
}

func (m *HTTP) GetResponseBody() []byte {
	if m != nil {
		return m.ResponseBody
	}
	return nil
}

type HTTPCookie struct {
	Name     string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Value    string `protobuf:"bytes,2,opt,name=Value,proto3" json:"Value,omitempty"`
	Path     string `protobuf:"bytes,3,opt,name=Path,proto3" json:"Path,omitempty"`
	Domain   string `protobuf:"bytes,4,opt,name=Domain,proto3" json:"Domain,omitempty"`
	Expires  uint64 `protobuf:"varint,5,opt,name=Expires,proto3" json:"Expires,omitempty"`
	MaxAge   int32  `protobuf:"varint,6,opt,name=MaxAge,proto3" json:"MaxAge,omitempty"`
	Secure   bool   `protobuf:"varint,7,opt,name=Secure,proto3" json:"Secure,omitempty"`
	HttpOnly bool   `protobuf:"varint,8,opt,name=HttpOnly,proto3" json:"HttpOnly,omitempty"`
	SameSite int32  `protobuf:"varint,9,opt,name=SameSite,proto3" json:"SameSite,omitempty"`
}

func (m *HTTPCookie) Reset()         { *m = HTTPCookie{} }
func (m *HTTPCookie) String() string { return proto.CompactTextString(m) }
func (*HTTPCookie) ProtoMessage()    {}
func (*HTTPCookie) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{62}
}
func (m *HTTPCookie) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HTTPCookie) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HTTPCookie.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HTTPCookie) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HTTPCookie.Merge(m, src)
}
func (m *HTTPCookie) XXX_Size() int {
	return m.Size()
}
func (m *HTTPCookie) XXX_DiscardUnknown() {
	xxx_messageInfo_HTTPCookie.DiscardUnknown(m)
}

var xxx_messageInfo_HTTPCookie proto.InternalMessageInfo

func (m *HTTPCookie) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HTTPCookie) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *HTTPCookie) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *HTTPCookie) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *HTTPCookie) GetExpires() uint64 {
	if m != nil {
		return m.Expires
	}
	return 0
}

func (m *HTTPCookie) GetMaxAge() int32 {
	if m != nil {
		return m.MaxAge
	}
	return 0
}

func (m *HTTPCookie) GetSecure() bool {
	if m != nil {
		return m.Secure
	}
	return false
}

func (m *HTTPCookie) GetHttpOnly() bool {
	if m != nil {
		return m.HttpOnly
	}
	return false
}

func (m *HTTPCookie) GetSameSite() int32 {
	if m != nil {
		return m.SameSite
	}
	return 0
}

type TLSClientHello struct {
	Timestamp        int64    `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Type             int32    `protobuf:"varint,2,opt,name=Type,proto3" json:"Type,omitempty"`
	Version          int32    `protobuf:"varint,3,opt,name=Version,proto3" json:"Version,omitempty"`
	MessageLen       int32    `protobuf:"varint,4,opt,name=MessageLen,proto3" json:"MessageLen,omitempty"`
	HandshakeType    int32    `protobuf:"varint,5,opt,name=HandshakeType,proto3" json:"HandshakeType,omitempty"`
	HandshakeLen     uint32   `protobuf:"varint,6,opt,name=HandshakeLen,proto3" json:"HandshakeLen,omitempty"`
	HandshakeVersion int32    `protobuf:"varint,7,opt,name=HandshakeVersion,proto3" json:"HandshakeVersion,omitempty"`
	Random           []byte   `protobuf:"bytes,8,opt,name=Random,proto3" json:"Random,omitempty"`
	SessionIDLen     uint32   `protobuf:"varint,9,opt,name=SessionIDLen,proto3" json:"SessionIDLen,omitempty"`
	SessionID        []byte   `protobuf:"bytes,10,opt,name=SessionID,proto3" json:"SessionID,omitempty"`
	CipherSuiteLen   int32    `protobuf:"varint,11,opt,name=CipherSuiteLen,proto3" json:"CipherSuiteLen,omitempty"`
	ExtensionLen     int32    `protobuf:"varint,12,opt,name=ExtensionLen,proto3" json:"ExtensionLen,omitempty"`
	SNI              string   `protobuf:"bytes,13,opt,name=SNI,proto3" json:"SNI,omitempty"`
	OSCP             bool     `protobuf:"varint,14,opt,name=OSCP,proto3" json:"OSCP,omitempty"`
	CipherSuites     []int32  `protobuf:"varint,15,rep,packed,name=CipherSuites,proto3" json:"CipherSuites,omitempty"`
	CompressMethods  []int32  `protobuf:"varint,16,rep,packed,name=CompressMethods,proto3" json:"CompressMethods,omitempty"`
	SignatureAlgs    []int32  `protobuf:"varint,17,rep,packed,name=SignatureAlgs,proto3" json:"SignatureAlgs,omitempty"`
	SupportedGroups  []int32  `protobuf:"varint,18,rep,packed,name=SupportedGroups,proto3" json:"SupportedGroups,omitempty"`
	SupportedPoints  []int32  `protobuf:"varint,19,rep,packed,name=SupportedPoints,proto3" json:"SupportedPoints,omitempty"`
	ALPNs            []string `protobuf:"bytes,20,rep,name=ALPNs,proto3" json:"ALPNs,omitempty"`
	Ja3              string   `protobuf:"bytes,21,opt,name=Ja3,proto3" json:"Ja3,omitempty"`
	SrcIP            string   `protobuf:"bytes,22,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP            string   `protobuf:"bytes,23,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
	SrcMAC           string   `protobuf:"bytes,24,opt,name=SrcMAC,proto3" json:"SrcMAC,omitempty"`
	DstMAC           string   `protobuf:"bytes,25,opt,name=DstMAC,proto3" json:"DstMAC,omitempty"`
	SrcPort          int32    `protobuf:"varint,26,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	DstPort          int32    `protobuf:"varint,27,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
	Extensions       []int32  `protobuf:"varint,28,rep,packed,name=Extensions,proto3" json:"Extensions,omitempty"`
}

func (m *TLSClientHello) Reset()         { *m = TLSClientHello{} }
func (m *TLSClientHello) String() string { return proto.CompactTextString(m) }
func (*TLSClientHello) ProtoMessage()    {}
func (*TLSClientHello) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{63}
}
func (m *TLSClientHello) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLSClientHello) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLSClientHello.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLSClientHello) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLSClientHello.Merge(m, src)
}
func (m *TLSClientHello) XXX_Size() int {
	return m.Size()
}
func (m *TLSClientHello) XXX_DiscardUnknown() {
	xxx_messageInfo_TLSClientHello.DiscardUnknown(m)
}

var xxx_messageInfo_TLSClientHello proto.InternalMessageInfo

func (m *TLSClientHello) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *TLSClientHello) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *TLSClientHello) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *TLSClientHello) GetMessageLen() int32 {
	if m != nil {
		return m.MessageLen
	}
	return 0
}

func (m *TLSClientHello) GetHandshakeType() int32 {
	if m != nil {
		return m.HandshakeType
	}
	return 0
}

func (m *TLSClientHello) GetHandshakeLen() uint32 {
	if m != nil {
		return m.HandshakeLen
	}
	return 0
}

func (m *TLSClientHello) GetHandshakeVersion() int32 {
	if m != nil {
		return m.HandshakeVersion
	}
	return 0
}

func (m *TLSClientHello) GetRandom() []byte {
	if m != nil {
		return m.Random
	}
	return nil
}

func (m *TLSClientHello) GetSessionIDLen() uint32 {
	if m != nil {
		return m.SessionIDLen
	}
	return 0
}

func (m *TLSClientHello) GetSessionID() []byte {
	if m != nil {
		return m.SessionID
	}
	return nil
}

func (m *TLSClientHello) GetCipherSuiteLen() int32 {
	if m != nil {
		return m.CipherSuiteLen
	}
	return 0
}

func (m *TLSClientHello) GetExtensionLen() int32 {
	if m != nil {
		return m.ExtensionLen
	}
	return 0
}

func (m *TLSClientHello) GetSNI() string {
	if m != nil {
		return m.SNI
	}
	return ""
}

func (m *TLSClientHello) GetOSCP() bool {
	if m != nil {
		return m.OSCP
	}
	return false
}

func (m *TLSClientHello) GetCipherSuites() []int32 {
	if m != nil {
		return m.CipherSuites
	}
	return nil
}

func (m *TLSClientHello) GetCompressMethods() []int32 {
	if m != nil {
		return m.CompressMethods
	}
	return nil
}

func (m *TLSClientHello) GetSignatureAlgs() []int32 {
	if m != nil {
		return m.SignatureAlgs
	}
	return nil
}

func (m *TLSClientHello) GetSupportedGroups() []int32 {
	if m != nil {
		return m.SupportedGroups
	}
	return nil
}

func (m *TLSClientHello) GetSupportedPoints() []int32 {
	if m != nil {
		return m.SupportedPoints
	}
	return nil
}

func (m *TLSClientHello) GetALPNs() []string {
	if m != nil {
		return m.ALPNs
	}
	return nil
}

func (m *TLSClientHello) GetJa3() string {
	if m != nil {
		return m.Ja3
	}
	return ""
}

func (m *TLSClientHello) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *TLSClientHello) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

func (m *TLSClientHello) GetSrcMAC() string {
	if m != nil {
		return m.SrcMAC
	}
	return ""
}

func (m *TLSClientHello) GetDstMAC() string {
	if m != nil {
		return m.DstMAC
	}
	return ""
}

func (m *TLSClientHello) GetSrcPort() int32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *TLSClientHello) GetDstPort() int32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

func (m *TLSClientHello) GetExtensions() []int32 {
	if m != nil {
		return m.Extensions
	}
	return nil
}

type TLSServerHello struct {
	Timestamp                    int64    `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Version                      int32    `protobuf:"varint,2,opt,name=Version,proto3" json:"Version,omitempty"`
	Random                       []byte   `protobuf:"bytes,3,opt,name=Random,proto3" json:"Random,omitempty"`
	SessionID                    []byte   `protobuf:"bytes,4,opt,name=SessionID,proto3" json:"SessionID,omitempty"`
	CipherSuite                  int32    `protobuf:"varint,5,opt,name=CipherSuite,proto3" json:"CipherSuite,omitempty"`
	CompressionMethod            int32    `protobuf:"varint,6,opt,name=CompressionMethod,proto3" json:"CompressionMethod,omitempty"`
	NextProtoNeg                 bool     `protobuf:"varint,7,opt,name=NextProtoNeg,proto3" json:"NextProtoNeg,omitempty"`
	NextProtos                   []string `protobuf:"bytes,8,rep,name=NextProtos,proto3" json:"NextProtos,omitempty"`
	OCSPStapling                 bool     `protobuf:"varint,9,opt,name=OCSPStapling,proto3" json:"OCSPStapling,omitempty"`
	TicketSupported              bool     `protobuf:"varint,10,opt,name=TicketSupported,proto3" json:"TicketSupported,omitempty"`
	SecureRenegotiationSupported bool     `protobuf:"varint,11,opt,name=SecureRenegotiationSupported,proto3" json:"SecureRenegotiationSupported,omitempty"`
	SecureRenegotiation          []byte   `protobuf:"bytes,12,opt,name=SecureRenegotiation,proto3" json:"SecureRenegotiation,omitempty"`
	AlpnProtocol                 string   `protobuf:"bytes,13,opt,name=AlpnProtocol,proto3" json:"AlpnProtocol,omitempty"`
	Ems                          bool     `protobuf:"varint,14,opt,name=Ems,proto3" json:"Ems,omitempty"`
	Scts                         [][]byte `protobuf:"bytes,15,rep,name=Scts,proto3" json:"Scts,omitempty"`
	SupportedVersion             int32    `protobuf:"varint,16,opt,name=SupportedVersion,proto3" json:"SupportedVersion,omitempty"`
	// KeyShare ServerShare            = 17; // fields are unexported by the stdlib unfortunately...
	SelectedIdentityPresent bool    `protobuf:"varint,18,opt,name=SelectedIdentityPresent,proto3" json:"SelectedIdentityPresent,omitempty"`
	SelectedIdentity        int32   `protobuf:"varint,19,opt,name=SelectedIdentity,proto3" json:"SelectedIdentity,omitempty"`
	Cookie                  []byte  `protobuf:"bytes,20,opt,name=Cookie,proto3" json:"Cookie,omitempty"`
	SelectedGroup           int32   `protobuf:"varint,21,opt,name=SelectedGroup,proto3" json:"SelectedGroup,omitempty"`
	Extensions              []int32 `protobuf:"varint,22,rep,packed,name=Extensions,proto3" json:"Extensions,omitempty"`
	SrcIP                   string  `protobuf:"bytes,23,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP                   string  `protobuf:"bytes,24,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
	SrcMAC                  string  `protobuf:"bytes,25,opt,name=SrcMAC,proto3" json:"SrcMAC,omitempty"`
	DstMAC                  string  `protobuf:"bytes,26,opt,name=DstMAC,proto3" json:"DstMAC,omitempty"`
	SrcPort                 int32   `protobuf:"varint,27,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	DstPort                 int32   `protobuf:"varint,28,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
	Ja3S                    string  `protobuf:"bytes,29,opt,name=Ja3s,proto3" json:"Ja3s,omitempty"`
}

func (m *TLSServerHello) Reset()         { *m = TLSServerHello{} }
func (m *TLSServerHello) String() string { return proto.CompactTextString(m) }
func (*TLSServerHello) ProtoMessage()    {}
func (*TLSServerHello) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{64}
}
func (m *TLSServerHello) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLSServerHello) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLSServerHello.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLSServerHello) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLSServerHello.Merge(m, src)
}
func (m *TLSServerHello) XXX_Size() int {
	return m.Size()
}
func (m *TLSServerHello) XXX_DiscardUnknown() {
	xxx_messageInfo_TLSServerHello.DiscardUnknown(m)
}

var xxx_messageInfo_TLSServerHello proto.InternalMessageInfo

func (m *TLSServerHello) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *TLSServerHello) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *TLSServerHello) GetRandom() []byte {
	if m != nil {
		return m.Random
	}
	return nil
}

func (m *TLSServerHello) GetSessionID() []byte {
	if m != nil {
		return m.SessionID
	}
	return nil
}

func (m *TLSServerHello) GetCipherSuite() int32 {
	if m != nil {
		return m.CipherSuite
	}
	return 0
}

func (m *TLSServerHello) GetCompressionMethod() int32 {
	if m != nil {
		return m.CompressionMethod
	}
	return 0
}

func (m *TLSServerHello) GetNextProtoNeg() bool {
	if m != nil {
		return m.NextProtoNeg
	}
	return false
}

func (m *TLSServerHello) GetNextProtos() []string {
	if m != nil {
		return m.NextProtos
	}
	return nil
}

func (m *TLSServerHello) GetOCSPStapling() bool {
	if m != nil {
		return m.OCSPStapling
	}
	return false
}

func (m *TLSServerHello) GetTicketSupported() bool {
	if m != nil {
		return m.TicketSupported
	}
	return false
}

func (m *TLSServerHello) GetSecureRenegotiationSupported() bool {
	if m != nil {
		return m.SecureRenegotiationSupported
	}
	return false
}

func (m *TLSServerHello) GetSecureRenegotiation() []byte {
	if m != nil {
		return m.SecureRenegotiation
	}
	return nil
}

func (m *TLSServerHello) GetAlpnProtocol() string {
	if m != nil {
		return m.AlpnProtocol
	}
	return ""
}

func (m *TLSServerHello) GetEms() bool {
	if m != nil {
		return m.Ems
	}
	return false
}

func (m *TLSServerHello) GetScts() [][]byte {
	if m != nil {
		return m.Scts
	}
	return nil
}

func (m *TLSServerHello) GetSupportedVersion() int32 {
	if m != nil {
		return m.SupportedVersion
	}
	return 0
}

func (m *TLSServerHello) GetSelectedIdentityPresent() bool {
	if m != nil {
		return m.SelectedIdentityPresent
	}
	return false
}

func (m *TLSServerHello) GetSelectedIdentity() int32 {
	if m != nil {
		return m.SelectedIdentity
	}
	return 0
}

func (m *TLSServerHello) GetCookie() []byte {
	if m != nil {
		return m.Cookie
	}
	return nil
}

func (m *TLSServerHello) GetSelectedGroup() int32 {
	if m != nil {
		return m.SelectedGroup
	}
	return 0
}

func (m *TLSServerHello) GetExtensions() []int32 {
	if m != nil {
		return m.Extensions
	}
	return nil
}

func (m *TLSServerHello) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *TLSServerHello) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

func (m *TLSServerHello) GetSrcMAC() string {
	if m != nil {
		return m.SrcMAC
	}
	return ""
}

func (m *TLSServerHello) GetDstMAC() string {
	if m != nil {
		return m.DstMAC
	}
	return ""
}

func (m *TLSServerHello) GetSrcPort() int32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *TLSServerHello) GetDstPort() int32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

func (m *TLSServerHello) GetJa3S() string {
	if m != nil {
		return m.Ja3S
	}
	return ""
}

type IPSecAH struct {
	Timestamp          int64  `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Reserved           int32  `protobuf:"varint,2,opt,name=Reserved,proto3" json:"Reserved,omitempty"`
	SPI                int32  `protobuf:"varint,3,opt,name=SPI,proto3" json:"SPI,omitempty"`
	Seq                int32  `protobuf:"varint,4,opt,name=Seq,proto3" json:"Seq,omitempty"`
	AuthenticationData []byte `protobuf:"bytes,5,opt,name=AuthenticationData,proto3" json:"AuthenticationData,omitempty"`
	SrcIP              string `protobuf:"bytes,6,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP              string `protobuf:"bytes,7,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
}

func (m *IPSecAH) Reset()         { *m = IPSecAH{} }
func (m *IPSecAH) String() string { return proto.CompactTextString(m) }
func (*IPSecAH) ProtoMessage()    {}
func (*IPSecAH) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{65}
}
func (m *IPSecAH) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPSecAH) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPSecAH.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPSecAH) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPSecAH.Merge(m, src)
}
func (m *IPSecAH) XXX_Size() int {
	return m.Size()
}
func (m *IPSecAH) XXX_DiscardUnknown() {
	xxx_messageInfo_IPSecAH.DiscardUnknown(m)
}

var xxx_messageInfo_IPSecAH proto.InternalMessageInfo

func (m *IPSecAH) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *IPSecAH) GetReserved() int32 {
	if m != nil {
		return m.Reserved
	}
	return 0
}

func (m *IPSecAH) GetSPI() int32 {
	if m != nil {
		return m.SPI
	}
	return 0
}

func (m *IPSecAH) GetSeq() int32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *IPSecAH) GetAuthenticationData() []byte {
	if m != nil {
		return m.AuthenticationData
	}
	return nil
}

func (m *IPSecAH) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *IPSecAH) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

type IPSecESP struct {
	Timestamp    int64  `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	SPI          int32  `protobuf:"varint,2,opt,name=SPI,proto3" json:"SPI,omitempty"`
	Seq          int32  `protobuf:"varint,3,opt,name=Seq,proto3" json:"Seq,omitempty"`
	LenEncrypted int32  `protobuf:"varint,4,opt,name=LenEncrypted,proto3" json:"LenEncrypted,omitempty"`
	SrcIP        string `protobuf:"bytes,5,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP        string `protobuf:"bytes,6,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
}

func (m *IPSecESP) Reset()         { *m = IPSecESP{} }
func (m *IPSecESP) String() string { return proto.CompactTextString(m) }
func (*IPSecESP) ProtoMessage()    {}
func (*IPSecESP) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{66}
}
func (m *IPSecESP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPSecESP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPSecESP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPSecESP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPSecESP.Merge(m, src)
}
func (m *IPSecESP) XXX_Size() int {
	return m.Size()
}
func (m *IPSecESP) XXX_DiscardUnknown() {
	xxx_messageInfo_IPSecESP.DiscardUnknown(m)
}

var xxx_messageInfo_IPSecESP proto.InternalMessageInfo

func (m *IPSecESP) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *IPSecESP) GetSPI() int32 {
	if m != nil {
		return m.SPI
	}
	return 0
}

func (m *IPSecESP) GetSeq() int32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *IPSecESP) GetLenEncrypted() int32 {
	if m != nil {
		return m.LenEncrypted
	}
	return 0
}

func (m *IPSecESP) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *IPSecESP) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

// The Generic Network Virtualization Encapsulation (Geneve) protocol offers a new approach to encapsulation
// designed to offer control-plane independence between tunnel endpoints.
// The protocol specifies only a data-plane schema using a number of variable length options.
type Geneve struct {
	Timestamp      int64           `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Version        int32           `protobuf:"varint,2,opt,name=Version,proto3" json:"Version,omitempty"`
	OptionsLength  int32           `protobuf:"varint,3,opt,name=OptionsLength,proto3" json:"OptionsLength,omitempty"`
	OAMPacket      bool            `protobuf:"varint,4,opt,name=OAMPacket,proto3" json:"OAMPacket,omitempty"`
	CriticalOption bool            `protobuf:"varint,5,opt,name=CriticalOption,proto3" json:"CriticalOption,omitempty"`
	Protocol       int32           `protobuf:"varint,6,opt,name=Protocol,proto3" json:"Protocol,omitempty"`
	VNI            uint32          `protobuf:"varint,7,opt,name=VNI,proto3" json:"VNI,omitempty"`
	Options        []*GeneveOption `protobuf:"bytes,8,rep,name=Options,proto3" json:"Options,omitempty"`
}

func (m *Geneve) Reset()         { *m = Geneve{} }
func (m *Geneve) String() string { return proto.CompactTextString(m) }
func (*Geneve) ProtoMessage()    {}
func (*Geneve) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{67}
}
func (m *Geneve) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Geneve) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Geneve.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Geneve) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Geneve.Merge(m, src)
}
func (m *Geneve) XXX_Size() int {
	return m.Size()
}
func (m *Geneve) XXX_DiscardUnknown() {
	xxx_messageInfo_Geneve.DiscardUnknown(m)
}

var xxx_messageInfo_Geneve proto.InternalMessageInfo

func (m *Geneve) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Geneve) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Geneve) GetOptionsLength() int32 {
	if m != nil {
		return m.OptionsLength
	}
	return 0
}

func (m *Geneve) GetOAMPacket() bool {
	if m != nil {
		return m.OAMPacket
	}
	return false
}

func (m *Geneve) GetCriticalOption() bool {
	if m != nil {
		return m.CriticalOption
	}
	return false
}

func (m *Geneve) GetProtocol() int32 {
	if m != nil {
		return m.Protocol
	}
	return 0
}

func (m *Geneve) GetVNI() uint32 {
	if m != nil {
		return m.VNI
	}
	return 0
}

func (m *Geneve) GetOptions() []*GeneveOption {
	if m != nil {
		return m.Options
	}
	return nil
}

type GeneveOption struct {
	Class  int32  `protobuf:"varint,1,opt,name=Class,proto3" json:"Class,omitempty"`
	Type   int32  `protobuf:"varint,2,opt,name=Type,proto3" json:"Type,omitempty"`
	Flags  int32  `protobuf:"varint,3,opt,name=Flags,proto3" json:"Flags,omitempty"`
	Length int32  `protobuf:"varint,4,opt,name=Length,proto3" json:"Length,omitempty"`
	Data   []byte `protobuf:"bytes,5,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *GeneveOption) Reset()         { *m = GeneveOption{} }
func (m *GeneveOption) String() string { return proto.CompactTextString(m) }
func (*GeneveOption) ProtoMessage()    {}
func (*GeneveOption) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{68}
}
func (m *GeneveOption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GeneveOption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GeneveOption.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GeneveOption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeneveOption.Merge(m, src)
}
func (m *GeneveOption) XXX_Size() int {
	return m.Size()
}
func (m *GeneveOption) XXX_DiscardUnknown() {
	xxx_messageInfo_GeneveOption.DiscardUnknown(m)
}

var xxx_messageInfo_GeneveOption proto.InternalMessageInfo

func (m *GeneveOption) GetClass() int32 {
	if m != nil {
		return m.Class
	}
	return 0
}

func (m *GeneveOption) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *GeneveOption) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *GeneveOption) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *GeneveOption) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// VXLAN is a VXLAN packet header
type VXLAN struct {
	Timestamp        int64  `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	ValidIDFlag      bool   `protobuf:"varint,2,opt,name=ValidIDFlag,proto3" json:"ValidIDFlag,omitempty"`
	VNI              uint32 `protobuf:"varint,3,opt,name=VNI,proto3" json:"VNI,omitempty"`
	GBPExtension     bool   `protobuf:"varint,4,opt,name=GBPExtension,proto3" json:"GBPExtension,omitempty"`
	GBPDontLearn     bool   `protobuf:"varint,5,opt,name=GBPDontLearn,proto3" json:"GBPDontLearn,omitempty"`
	GBPApplied       bool   `protobuf:"varint,6,opt,name=GBPApplied,proto3" json:"GBPApplied,omitempty"`
	GBPGroupPolicyID int32  `protobuf:"varint,7,opt,name=GBPGroupPolicyID,proto3" json:"GBPGroupPolicyID,omitempty"`
}

func (m *VXLAN) Reset()         { *m = VXLAN{} }
func (m *VXLAN) String() string { return proto.CompactTextString(m) }
func (*VXLAN) ProtoMessage()    {}
func (*VXLAN) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{69}
}
func (m *VXLAN) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VXLAN) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VXLAN.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VXLAN) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VXLAN.Merge(m, src)
}
func (m *VXLAN) XXX_Size() int {
	return m.Size()
}
func (m *VXLAN) XXX_DiscardUnknown() {
	xxx_messageInfo_VXLAN.DiscardUnknown(m)
}

var xxx_messageInfo_VXLAN proto.InternalMessageInfo

func (m *VXLAN) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *VXLAN) GetValidIDFlag() bool {
	if m != nil {
		return m.ValidIDFlag
	}
	return false
}

func (m *VXLAN) GetVNI() uint32 {
	if m != nil {
		return m.VNI
	}
	return 0
}

func (m *VXLAN) GetGBPExtension() bool {
	if m != nil {
		return m.GBPExtension
	}
	return false
}

func (m *VXLAN) GetGBPDontLearn() bool {
	if m != nil {
		return m.GBPDontLearn
	}
	return false
}

func (m *VXLAN) GetGBPApplied() bool {
	if m != nil {
		return m.GBPApplied
	}
	return false
}

func (m *VXLAN) GetGBPGroupPolicyID() int32 {
	if m != nil {
		return m.GBPGroupPolicyID
	}
	return 0
}

// Universal Serial Bus (USB) is an industry standard that establishes specifications
// for cables and connectors and protocols for connection, communication and power
// supply between computers, peripheral devices and other computers. Released in 1996,
// the USB standard is currently maintained by the USB Implementers Forum (USB-IF).
// There have been four generations of USB specifications: USB 1.x, USB 2.0, USB 3.x and USB4.
type USB struct {
	Timestamp              int64  `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	ID                     uint64 `protobuf:"varint,2,opt,name=ID,proto3" json:"ID,omitempty"`
	EventType              int32  `protobuf:"varint,3,opt,name=EventType,proto3" json:"EventType,omitempty"`
	TransferType           int32  `protobuf:"varint,4,opt,name=TransferType,proto3" json:"TransferType,omitempty"`
	Direction              int32  `protobuf:"varint,5,opt,name=Direction,proto3" json:"Direction,omitempty"`
	EndpointNumber         int32  `protobuf:"varint,6,opt,name=EndpointNumber,proto3" json:"EndpointNumber,omitempty"`
	DeviceAddress          int32  `protobuf:"varint,7,opt,name=DeviceAddress,proto3" json:"DeviceAddress,omitempty"`
	BusID                  int32  `protobuf:"varint,8,opt,name=BusID,proto3" json:"BusID,omitempty"`
	TimestampSec           int64  `protobuf:"varint,9,opt,name=TimestampSec,proto3" json:"TimestampSec,omitempty"`
	TimestampUsec          int32  `protobuf:"varint,10,opt,name=TimestampUsec,proto3" json:"TimestampUsec,omitempty"`
	Setup                  bool   `protobuf:"varint,11,opt,name=Setup,proto3" json:"Setup,omitempty"`
	Data                   bool   `protobuf:"varint,12,opt,name=Data,proto3" json:"Data,omitempty"`
	Status                 int32  `protobuf:"varint,13,opt,name=Status,proto3" json:"Status,omitempty"`
	UrbLength              uint32 `protobuf:"varint,14,opt,name=UrbLength,proto3" json:"UrbLength,omitempty"`
	UrbDataLength          uint32 `protobuf:"varint,15,opt,name=UrbDataLength,proto3" json:"UrbDataLength,omitempty"`
	UrbInterval            uint32 `protobuf:"varint,16,opt,name=UrbInterval,proto3" json:"UrbInterval,omitempty"`
	UrbStartFrame          uint32 `protobuf:"varint,17,opt,name=UrbStartFrame,proto3" json:"UrbStartFrame,omitempty"`
	UrbCopyOfTransferFlags uint32 `protobuf:"varint,18,opt,name=UrbCopyOfTransferFlags,proto3" json:"UrbCopyOfTransferFlags,omitempty"`
	IsoNumDesc             uint32 `protobuf:"varint,19,opt,name=IsoNumDesc,proto3" json:"IsoNumDesc,omitempty"`
	Payload                []byte `protobuf:"bytes,20,opt,name=Payload,proto3" json:"Payload,omitempty"`
}

func (m *USB) Reset()         { *m = USB{} }
func (m *USB) String() string { return proto.CompactTextString(m) }
func (*USB) ProtoMessage()    {}
func (*USB) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{70}
}
func (m *USB) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *USB) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_USB.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *USB) XXX_Merge(src proto.Message) {
	xxx_messageInfo_USB.Merge(m, src)
}
func (m *USB) XXX_Size() int {
	return m.Size()
}
func (m *USB) XXX_DiscardUnknown() {
	xxx_messageInfo_USB.DiscardUnknown(m)
}

var xxx_messageInfo_USB proto.InternalMessageInfo

func (m *USB) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *USB) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *USB) GetEventType() int32 {
	if m != nil {
		return m.EventType
	}
	return 0
}

func (m *USB) GetTransferType() int32 {
	if m != nil {
		return m.TransferType
	}
	return 0
}

func (m *USB) GetDirection() int32 {
	if m != nil {
		return m.Direction
	}
	return 0
}

func (m *USB) GetEndpointNumber() int32 {
	if m != nil {
		return m.EndpointNumber
	}
	return 0
}

func (m *USB) GetDeviceAddress() int32 {
	if m != nil {
		return m.DeviceAddress
	}
	return 0
}

func (m *USB) GetBusID() int32 {
	if m != nil {
		return m.BusID
	}
	return 0
}

func (m *USB) GetTimestampSec() int64 {
	if m != nil {
		return m.TimestampSec
	}
	return 0
}

func (m *USB) GetTimestampUsec() int32 {
	if m != nil {
		return m.TimestampUsec
	}
	return 0
}

func (m *USB) GetSetup() bool {
	if m != nil {
		return m.Setup
	}
	return false
}

func (m *USB) GetData() bool {
	if m != nil {
		return m.Data
	}
	return false
}

func (m *USB) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *USB) GetUrbLength() uint32 {
	if m != nil {
		return m.UrbLength
	}
	return 0
}

func (m *USB) GetUrbDataLength() uint32 {
	if m != nil {
		return m.UrbDataLength
	}
	return 0
}

func (m *USB) GetUrbInterval() uint32 {
	if m != nil {
		return m.UrbInterval
	}
	return 0
}

func (m *USB) GetUrbStartFrame() uint32 {
	if m != nil {
		return m.UrbStartFrame
	}
	return 0
}

func (m *USB) GetUrbCopyOfTransferFlags() uint32 {
	if m != nil {
		return m.UrbCopyOfTransferFlags
	}
	return 0
}

func (m *USB) GetIsoNumDesc() uint32 {
	if m != nil {
		return m.IsoNumDesc
	}
	return 0
}

func (m *USB) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type USBRequestBlockSetup struct {
	Timestamp   int64 `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	RequestType int32 `protobuf:"varint,2,opt,name=RequestType,proto3" json:"RequestType,omitempty"`
	Request     int32 `protobuf:"varint,3,opt,name=Request,proto3" json:"Request,omitempty"`
	Value       int32 `protobuf:"varint,4,opt,name=Value,proto3" json:"Value,omitempty"`
	Index       int32 `protobuf:"varint,5,opt,name=Index,proto3" json:"Index,omitempty"`
	Length      int32 `protobuf:"varint,6,opt,name=Length,proto3" json:"Length,omitempty"`
}

func (m *USBRequestBlockSetup) Reset()         { *m = USBRequestBlockSetup{} }
func (m *USBRequestBlockSetup) String() string { return proto.CompactTextString(m) }
func (*USBRequestBlockSetup) ProtoMessage()    {}
func (*USBRequestBlockSetup) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{71}
}
func (m *USBRequestBlockSetup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *USBRequestBlockSetup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_USBRequestBlockSetup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *USBRequestBlockSetup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_USBRequestBlockSetup.Merge(m, src)
}
func (m *USBRequestBlockSetup) XXX_Size() int {
	return m.Size()
}
func (m *USBRequestBlockSetup) XXX_DiscardUnknown() {
	xxx_messageInfo_USBRequestBlockSetup.DiscardUnknown(m)
}

var xxx_messageInfo_USBRequestBlockSetup proto.InternalMessageInfo

func (m *USBRequestBlockSetup) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *USBRequestBlockSetup) GetRequestType() int32 {
	if m != nil {
		return m.RequestType
	}
	return 0
}

func (m *USBRequestBlockSetup) GetRequest() int32 {
	if m != nil {
		return m.Request
	}
	return 0
}

func (m *USBRequestBlockSetup) GetValue() int32 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *USBRequestBlockSetup) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *USBRequestBlockSetup) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

// LCM (Lightweight Communications and Marshalling) is a set of libraries and tools for message passing and data marshalling,
// targeted at real-time systems where high-bandwidth and low latency are critical.
// It provides a publish/subscribe message passing model and automatic marshalling/unmarshalling
// code generation with bindings for applications in a variety of programming languages.
// References
// https://lcm-proj.github.io/
// https://github.com/lcm-proj/lcm
type LCM struct {
	Timestamp      int64  `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Magic          int32  `protobuf:"varint,2,opt,name=Magic,proto3" json:"Magic,omitempty"`
	SequenceNumber int32  `protobuf:"varint,3,opt,name=SequenceNumber,proto3" json:"SequenceNumber,omitempty"`
	PayloadSize    int32  `protobuf:"varint,4,opt,name=PayloadSize,proto3" json:"PayloadSize,omitempty"`
	FragmentOffset int32  `protobuf:"varint,5,opt,name=FragmentOffset,proto3" json:"FragmentOffset,omitempty"`
	FragmentNumber int32  `protobuf:"varint,6,opt,name=FragmentNumber,proto3" json:"FragmentNumber,omitempty"`
	TotalFragments int32  `protobuf:"varint,7,opt,name=TotalFragments,proto3" json:"TotalFragments,omitempty"`
	ChannelName    string `protobuf:"bytes,8,opt,name=ChannelName,proto3" json:"ChannelName,omitempty"`
	Fragmented     bool   `protobuf:"varint,9,opt,name=Fragmented,proto3" json:"Fragmented,omitempty"`
	SrcIP          string `protobuf:"bytes,10,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP          string `protobuf:"bytes,11,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
	SrcPort        int32  `protobuf:"varint,12,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	DstPort        int32  `protobuf:"varint,13,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
}

func (m *LCM) Reset()         { *m = LCM{} }
func (m *LCM) String() string { return proto.CompactTextString(m) }
func (*LCM) ProtoMessage()    {}
func (*LCM) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{72}
}
func (m *LCM) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LCM) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LCM.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LCM) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LCM.Merge(m, src)
}
func (m *LCM) XXX_Size() int {
	return m.Size()
}
func (m *LCM) XXX_DiscardUnknown() {
	xxx_messageInfo_LCM.DiscardUnknown(m)
}

var xxx_messageInfo_LCM proto.InternalMessageInfo

func (m *LCM) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *LCM) GetMagic() int32 {
	if m != nil {
		return m.Magic
	}
	return 0
}

func (m *LCM) GetSequenceNumber() int32 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *LCM) GetPayloadSize() int32 {
	if m != nil {
		return m.PayloadSize
	}
	return 0
}

func (m *LCM) GetFragmentOffset() int32 {
	if m != nil {
		return m.FragmentOffset
	}
	return 0
}

func (m *LCM) GetFragmentNumber() int32 {
	if m != nil {
		return m.FragmentNumber
	}
	return 0
}

func (m *LCM) GetTotalFragments() int32 {
	if m != nil {
		return m.TotalFragments
	}
	return 0
}

func (m *LCM) GetChannelName() string {
	if m != nil {
		return m.ChannelName
	}
	return ""
}

func (m *LCM) GetFragmented() bool {
	if m != nil {
		return m.Fragmented
	}
	return false
}

func (m *LCM) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *LCM) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

func (m *LCM) GetSrcPort() int32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *LCM) GetDstPort() int32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

type MPLS struct {
	Timestamp    int64 `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Label        int32 `protobuf:"varint,2,opt,name=Label,proto3" json:"Label,omitempty"`
	TrafficClass int32 `protobuf:"varint,3,opt,name=TrafficClass,proto3" json:"TrafficClass,omitempty"`
	StackBottom  bool  `protobuf:"varint,4,opt,name=StackBottom,proto3" json:"StackBottom,omitempty"`
	TTL          int32 `protobuf:"varint,5,opt,name=TTL,proto3" json:"TTL,omitempty"`
}

func (m *MPLS) Reset()         { *m = MPLS{} }
func (m *MPLS) String() string { return proto.CompactTextString(m) }
func (*MPLS) ProtoMessage()    {}
func (*MPLS) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{73}
}
func (m *MPLS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MPLS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MPLS.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MPLS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MPLS.Merge(m, src)
}
func (m *MPLS) XXX_Size() int {
	return m.Size()
}
func (m *MPLS) XXX_DiscardUnknown() {
	xxx_messageInfo_MPLS.DiscardUnknown(m)
}

var xxx_messageInfo_MPLS proto.InternalMessageInfo

func (m *MPLS) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *MPLS) GetLabel() int32 {
	if m != nil {
		return m.Label
	}
	return 0
}

func (m *MPLS) GetTrafficClass() int32 {
	if m != nil {
		return m.TrafficClass
	}
	return 0
}

func (m *MPLS) GetStackBottom() bool {
	if m != nil {
		return m.StackBottom
	}
	return false
}

func (m *MPLS) GetTTL() int32 {
	if m != nil {
		return m.TTL
	}
	return 0
}

// Modbus is a serial communications protocol originally published by Modicon
// (now Schneider Electric) in 1979 for use with its programmable logic controllers (PLCs).
// Modbus has become a de facto standard communication protocol and is now a commonly
// available means of connecting industrial electronic devices. Modbus is popular
// in industrial environments because it is openly published and royalty-free.
// It was developed for industrial applications, is relatively easy to deploy and
// maintain compared to other standards, and places few restrictions other than the
// size on the format of the data to be transmitted. The Modbus uses the RS485 as its physical layer.
// It is possible to use the DC-BUS as power line communication physical layer to save wires.
type Modbus struct {
	Timestamp     int64  `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	TransactionID int32  `protobuf:"varint,2,opt,name=TransactionID,proto3" json:"TransactionID,omitempty"`
	ProtocolID    int32  `protobuf:"varint,3,opt,name=ProtocolID,proto3" json:"ProtocolID,omitempty"`
	Length        int32  `protobuf:"varint,4,opt,name=Length,proto3" json:"Length,omitempty"`
	UnitID        int32  `protobuf:"varint,5,opt,name=UnitID,proto3" json:"UnitID,omitempty"`
	Payload       []byte `protobuf:"bytes,6,opt,name=Payload,proto3" json:"Payload,omitempty"`
	Exception     bool   `protobuf:"varint,7,opt,name=Exception,proto3" json:"Exception,omitempty"`
	FunctionCode  int32  `protobuf:"varint,8,opt,name=FunctionCode,proto3" json:"FunctionCode,omitempty"`
	// in case of ModbusTCP:
	SrcIP   string `protobuf:"bytes,9,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP   string `protobuf:"bytes,10,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
	SrcPort int32  `protobuf:"varint,11,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	DstPort int32  `protobuf:"varint,12,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
}

func (m *Modbus) Reset()         { *m = Modbus{} }
func (m *Modbus) String() string { return proto.CompactTextString(m) }
func (*Modbus) ProtoMessage()    {}
func (*Modbus) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{74}
}
func (m *Modbus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Modbus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Modbus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Modbus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Modbus.Merge(m, src)
}
func (m *Modbus) XXX_Size() int {
	return m.Size()
}
func (m *Modbus) XXX_DiscardUnknown() {
	xxx_messageInfo_Modbus.DiscardUnknown(m)
}

var xxx_messageInfo_Modbus proto.InternalMessageInfo

func (m *Modbus) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Modbus) GetTransactionID() int32 {
	if m != nil {
		return m.TransactionID
	}
	return 0
}

func (m *Modbus) GetProtocolID() int32 {
	if m != nil {
		return m.ProtocolID
	}
	return 0
}

func (m *Modbus) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *Modbus) GetUnitID() int32 {
	if m != nil {
		return m.UnitID
	}
	return 0
}

func (m *Modbus) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *Modbus) GetException() bool {
	if m != nil {
		return m.Exception
	}
	return false
}

func (m *Modbus) GetFunctionCode() int32 {
	if m != nil {
		return m.FunctionCode
	}
	return 0
}

func (m *Modbus) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *Modbus) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

func (m *Modbus) GetSrcPort() int32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *Modbus) GetDstPort() int32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

// Open Shortest Path First (OSPF) is a routing protocol for Internet Protocol (IP) networks.
// It uses a link state routing (LSR) algorithm and falls into the group of interior gateway protocols (IGPs),
// operating within a single autonomous system (AS).
// OSPFv2 is defined as OSPF Version 2 in RFC 2328 (1998) for IPv4.
type OSPFv2 struct {
	Timestamp      int64  `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Version        int32  `protobuf:"varint,2,opt,name=Version,proto3" json:"Version,omitempty"`
	Type           int32  `protobuf:"varint,3,opt,name=Type,proto3" json:"Type,omitempty"`
	PacketLength   int32  `protobuf:"varint,4,opt,name=PacketLength,proto3" json:"PacketLength,omitempty"`
	RouterID       uint32 `protobuf:"varint,5,opt,name=RouterID,proto3" json:"RouterID,omitempty"`
	AreaID         uint32 `protobuf:"varint,6,opt,name=AreaID,proto3" json:"AreaID,omitempty"`
	Checksum       int32  `protobuf:"varint,7,opt,name=Checksum,proto3" json:"Checksum,omitempty"`
	AuType         int32  `protobuf:"varint,8,opt,name=AuType,proto3" json:"AuType,omitempty"`
	Authentication int64  `protobuf:"varint,9,opt,name=Authentication,proto3" json:"Authentication,omitempty"`
	// interface Content
	LSAs    []*LSAheader `protobuf:"bytes,10,rep,name=LSAs,proto3" json:"LSAs,omitempty"`
	LSU     *LSUpdate    `protobuf:"bytes,11,opt,name=LSU,proto3" json:"LSU,omitempty"`
	LSR     []*LSReq     `protobuf:"bytes,12,rep,name=LSR,proto3" json:"LSR,omitempty"`
	DbDesc  *DbDescPkg   `protobuf:"bytes,13,opt,name=DbDesc,proto3" json:"DbDesc,omitempty"`
	HelloV2 *HelloPkgV2  `protobuf:"bytes,14,opt,name=HelloV2,proto3" json:"HelloV2,omitempty"`
	SrcIP   string       `protobuf:"bytes,15,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP   string       `protobuf:"bytes,16,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
}

func (m *OSPFv2) Reset()         { *m = OSPFv2{} }
func (m *OSPFv2) String() string { return proto.CompactTextString(m) }
func (*OSPFv2) ProtoMessage()    {}
func (*OSPFv2) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{75}
}
func (m *OSPFv2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OSPFv2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OSPFv2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OSPFv2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OSPFv2.Merge(m, src)
}
func (m *OSPFv2) XXX_Size() int {
	return m.Size()
}
func (m *OSPFv2) XXX_DiscardUnknown() {
	xxx_messageInfo_OSPFv2.DiscardUnknown(m)
}

var xxx_messageInfo_OSPFv2 proto.InternalMessageInfo

func (m *OSPFv2) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *OSPFv2) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *OSPFv2) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *OSPFv2) GetPacketLength() int32 {
	if m != nil {
		return m.PacketLength
	}
	return 0
}

func (m *OSPFv2) GetRouterID() uint32 {
	if m != nil {
		return m.RouterID
	}
	return 0
}

func (m *OSPFv2) GetAreaID() uint32 {
	if m != nil {
		return m.AreaID
	}
	return 0
}

func (m *OSPFv2) GetChecksum() int32 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

func (m *OSPFv2) GetAuType() int32 {
	if m != nil {
		return m.AuType
	}
	return 0
}

func (m *OSPFv2) GetAuthentication() int64 {
	if m != nil {
		return m.Authentication
	}
	return 0
}

func (m *OSPFv2) GetLSAs() []*LSAheader {
	if m != nil {
		return m.LSAs
	}
	return nil
}

func (m *OSPFv2) GetLSU() *LSUpdate {
	if m != nil {
		return m.LSU
	}
	return nil
}

func (m *OSPFv2) GetLSR() []*LSReq {
	if m != nil {
		return m.LSR
	}
	return nil
}

func (m *OSPFv2) GetDbDesc() *DbDescPkg {
	if m != nil {
		return m.DbDesc
	}
	return nil
}

func (m *OSPFv2) GetHelloV2() *HelloPkgV2 {
	if m != nil {
		return m.HelloV2
	}
	return nil
}

func (m *OSPFv2) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *OSPFv2) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

type HelloPkg struct {
	InterfaceID              uint32   `protobuf:"varint,1,opt,name=InterfaceID,proto3" json:"InterfaceID,omitempty"`
	RtrPriority              int32    `protobuf:"varint,2,opt,name=RtrPriority,proto3" json:"RtrPriority,omitempty"`
	Options                  uint32   `protobuf:"varint,3,opt,name=Options,proto3" json:"Options,omitempty"`
	HelloInterval            int32    `protobuf:"varint,4,opt,name=HelloInterval,proto3" json:"HelloInterval,omitempty"`
	RouterDeadInterval       uint32   `protobuf:"varint,5,opt,name=RouterDeadInterval,proto3" json:"RouterDeadInterval,omitempty"`
	DesignatedRouterID       uint32   `protobuf:"varint,6,opt,name=DesignatedRouterID,proto3" json:"DesignatedRouterID,omitempty"`
	BackupDesignatedRouterID uint32   `protobuf:"varint,7,opt,name=BackupDesignatedRouterID,proto3" json:"BackupDesignatedRouterID,omitempty"`
	NeighborID               []uint32 `protobuf:"varint,8,rep,packed,name=NeighborID,proto3" json:"NeighborID,omitempty"`
}

func (m *HelloPkg) Reset()         { *m = HelloPkg{} }
func (m *HelloPkg) String() string { return proto.CompactTextString(m) }
func (*HelloPkg) ProtoMessage()    {}
func (*HelloPkg) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{76}
}
func (m *HelloPkg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HelloPkg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HelloPkg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HelloPkg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HelloPkg.Merge(m, src)
}
func (m *HelloPkg) XXX_Size() int {
	return m.Size()
}
func (m *HelloPkg) XXX_DiscardUnknown() {
	xxx_messageInfo_HelloPkg.DiscardUnknown(m)
}

var xxx_messageInfo_HelloPkg proto.InternalMessageInfo

func (m *HelloPkg) GetInterfaceID() uint32 {
	if m != nil {
		return m.InterfaceID
	}
	return 0
}

func (m *HelloPkg) GetRtrPriority() int32 {
	if m != nil {
		return m.RtrPriority
	}
	return 0
}

func (m *HelloPkg) GetOptions() uint32 {
	if m != nil {
		return m.Options
	}
	return 0
}

func (m *HelloPkg) GetHelloInterval() int32 {
	if m != nil {
		return m.HelloInterval
	}
	return 0
}

func (m *HelloPkg) GetRouterDeadInterval() uint32 {
	if m != nil {
		return m.RouterDeadInterval
	}
	return 0
}

func (m *HelloPkg) GetDesignatedRouterID() uint32 {
	if m != nil {
		return m.DesignatedRouterID
	}
	return 0
}

func (m *HelloPkg) GetBackupDesignatedRouterID() uint32 {
	if m != nil {
		return m.BackupDesignatedRouterID
	}
	return 0
}

func (m *HelloPkg) GetNeighborID() []uint32 {
	if m != nil {
		return m.NeighborID
	}
	return nil
}

type HelloPkgV2 struct {
	InterfaceID              uint32   `protobuf:"varint,1,opt,name=InterfaceID,proto3" json:"InterfaceID,omitempty"`
	RtrPriority              int32    `protobuf:"varint,2,opt,name=RtrPriority,proto3" json:"RtrPriority,omitempty"`
	Options                  uint32   `protobuf:"varint,3,opt,name=Options,proto3" json:"Options,omitempty"`
	HelloInterval            int32    `protobuf:"varint,4,opt,name=HelloInterval,proto3" json:"HelloInterval,omitempty"`
	RouterDeadInterval       uint32   `protobuf:"varint,5,opt,name=RouterDeadInterval,proto3" json:"RouterDeadInterval,omitempty"`
	DesignatedRouterID       uint32   `protobuf:"varint,6,opt,name=DesignatedRouterID,proto3" json:"DesignatedRouterID,omitempty"`
	BackupDesignatedRouterID uint32   `protobuf:"varint,7,opt,name=BackupDesignatedRouterID,proto3" json:"BackupDesignatedRouterID,omitempty"`
	NeighborID               []uint32 `protobuf:"varint,8,rep,packed,name=NeighborID,proto3" json:"NeighborID,omitempty"`
	NetworkMask              uint32   `protobuf:"varint,9,opt,name=NetworkMask,proto3" json:"NetworkMask,omitempty"`
}

func (m *HelloPkgV2) Reset()         { *m = HelloPkgV2{} }
func (m *HelloPkgV2) String() string { return proto.CompactTextString(m) }
func (*HelloPkgV2) ProtoMessage()    {}
func (*HelloPkgV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{77}
}
func (m *HelloPkgV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HelloPkgV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HelloPkgV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HelloPkgV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HelloPkgV2.Merge(m, src)
}
func (m *HelloPkgV2) XXX_Size() int {
	return m.Size()
}
func (m *HelloPkgV2) XXX_DiscardUnknown() {
	xxx_messageInfo_HelloPkgV2.DiscardUnknown(m)
}

var xxx_messageInfo_HelloPkgV2 proto.InternalMessageInfo

func (m *HelloPkgV2) GetInterfaceID() uint32 {
	if m != nil {
		return m.InterfaceID
	}
	return 0
}

func (m *HelloPkgV2) GetRtrPriority() int32 {
	if m != nil {
		return m.RtrPriority
	}
	return 0
}

func (m *HelloPkgV2) GetOptions() uint32 {
	if m != nil {
		return m.Options
	}
	return 0
}

func (m *HelloPkgV2) GetHelloInterval() int32 {
	if m != nil {
		return m.HelloInterval
	}
	return 0
}

func (m *HelloPkgV2) GetRouterDeadInterval() uint32 {
	if m != nil {
		return m.RouterDeadInterval
	}
	return 0
}

func (m *HelloPkgV2) GetDesignatedRouterID() uint32 {
	if m != nil {
		return m.DesignatedRouterID
	}
	return 0
}

func (m *HelloPkgV2) GetBackupDesignatedRouterID() uint32 {
	if m != nil {
		return m.BackupDesignatedRouterID
	}
	return 0
}

func (m *HelloPkgV2) GetNeighborID() []uint32 {
	if m != nil {
		return m.NeighborID
	}
	return nil
}

func (m *HelloPkgV2) GetNetworkMask() uint32 {
	if m != nil {
		return m.NetworkMask
	}
	return 0
}

type DbDescPkg struct {
	Options      uint32       `protobuf:"varint,1,opt,name=Options,proto3" json:"Options,omitempty"`
	InterfaceMTU int32        `protobuf:"varint,2,opt,name=InterfaceMTU,proto3" json:"InterfaceMTU,omitempty"`
	Flags        int32        `protobuf:"varint,3,opt,name=Flags,proto3" json:"Flags,omitempty"`
	DDSeqNumber  uint32       `protobuf:"varint,4,opt,name=DDSeqNumber,proto3" json:"DDSeqNumber,omitempty"`
	LSAinfo      []*LSAheader `protobuf:"bytes,5,rep,name=LSAinfo,proto3" json:"LSAinfo,omitempty"`
}

func (m *DbDescPkg) Reset()         { *m = DbDescPkg{} }
func (m *DbDescPkg) String() string { return proto.CompactTextString(m) }
func (*DbDescPkg) ProtoMessage()    {}
func (*DbDescPkg) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{78}
}
func (m *DbDescPkg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DbDescPkg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DbDescPkg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DbDescPkg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DbDescPkg.Merge(m, src)
}
func (m *DbDescPkg) XXX_Size() int {
	return m.Size()
}
func (m *DbDescPkg) XXX_DiscardUnknown() {
	xxx_messageInfo_DbDescPkg.DiscardUnknown(m)
}

var xxx_messageInfo_DbDescPkg proto.InternalMessageInfo

func (m *DbDescPkg) GetOptions() uint32 {
	if m != nil {
		return m.Options
	}
	return 0
}

func (m *DbDescPkg) GetInterfaceMTU() int32 {
	if m != nil {
		return m.InterfaceMTU
	}
	return 0
}

func (m *DbDescPkg) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *DbDescPkg) GetDDSeqNumber() uint32 {
	if m != nil {
		return m.DDSeqNumber
	}
	return 0
}

func (m *DbDescPkg) GetLSAinfo() []*LSAheader {
	if m != nil {
		return m.LSAinfo
	}
	return nil
}

// Open Shortest Path First (OSPF) is a routing protocol for Internet Protocol (IP) networks.
// It uses a link state routing (LSR) algorithm and falls into the group of interior gateway protocols (IGPs),
// operating within a single autonomous system (AS).
// The updates for IPv6 are specified as OSPF Version 3 in RFC 5340 (2008).
type OSPFv3 struct {
	Timestamp    int64  `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Version      int32  `protobuf:"varint,2,opt,name=Version,proto3" json:"Version,omitempty"`
	Type         int32  `protobuf:"varint,3,opt,name=Type,proto3" json:"Type,omitempty"`
	PacketLength int32  `protobuf:"varint,4,opt,name=PacketLength,proto3" json:"PacketLength,omitempty"`
	RouterID     uint32 `protobuf:"varint,5,opt,name=RouterID,proto3" json:"RouterID,omitempty"`
	AreaID       uint32 `protobuf:"varint,6,opt,name=AreaID,proto3" json:"AreaID,omitempty"`
	Checksum     int32  `protobuf:"varint,7,opt,name=Checksum,proto3" json:"Checksum,omitempty"`
	Instance     int32  `protobuf:"varint,8,opt,name=Instance,proto3" json:"Instance,omitempty"`
	Reserved     int32  `protobuf:"varint,9,opt,name=Reserved,proto3" json:"Reserved,omitempty"`
	// interface Content
	Hello  *HelloPkg    `protobuf:"bytes,10,opt,name=Hello,proto3" json:"Hello,omitempty"`
	DbDesc *DbDescPkg   `protobuf:"bytes,11,opt,name=DbDesc,proto3" json:"DbDesc,omitempty"`
	LSR    []*LSReq     `protobuf:"bytes,12,rep,name=LSR,proto3" json:"LSR,omitempty"`
	LSU    *LSUpdate    `protobuf:"bytes,13,opt,name=LSU,proto3" json:"LSU,omitempty"`
	LSAs   []*LSAheader `protobuf:"bytes,14,rep,name=LSAs,proto3" json:"LSAs,omitempty"`
	SrcIP  string       `protobuf:"bytes,15,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP  string       `protobuf:"bytes,16,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
}

func (m *OSPFv3) Reset()         { *m = OSPFv3{} }
func (m *OSPFv3) String() string { return proto.CompactTextString(m) }
func (*OSPFv3) ProtoMessage()    {}
func (*OSPFv3) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{79}
}
func (m *OSPFv3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OSPFv3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OSPFv3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OSPFv3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OSPFv3.Merge(m, src)
}
func (m *OSPFv3) XXX_Size() int {
	return m.Size()
}
func (m *OSPFv3) XXX_DiscardUnknown() {
	xxx_messageInfo_OSPFv3.DiscardUnknown(m)
}

var xxx_messageInfo_OSPFv3 proto.InternalMessageInfo

func (m *OSPFv3) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *OSPFv3) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *OSPFv3) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *OSPFv3) GetPacketLength() int32 {
	if m != nil {
		return m.PacketLength
	}
	return 0
}

func (m *OSPFv3) GetRouterID() uint32 {
	if m != nil {
		return m.RouterID
	}
	return 0
}

func (m *OSPFv3) GetAreaID() uint32 {
	if m != nil {
		return m.AreaID
	}
	return 0
}

func (m *OSPFv3) GetChecksum() int32 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

func (m *OSPFv3) GetInstance() int32 {
	if m != nil {
		return m.Instance
	}
	return 0
}

func (m *OSPFv3) GetReserved() int32 {
	if m != nil {
		return m.Reserved
	}
	return 0
}

func (m *OSPFv3) GetHello() *HelloPkg {
	if m != nil {
		return m.Hello
	}
	return nil
}

func (m *OSPFv3) GetDbDesc() *DbDescPkg {
	if m != nil {
		return m.DbDesc
	}
	return nil
}

func (m *OSPFv3) GetLSR() []*LSReq {
	if m != nil {
		return m.LSR
	}
	return nil
}

func (m *OSPFv3) GetLSU() *LSUpdate {
	if m != nil {
		return m.LSU
	}
	return nil
}

func (m *OSPFv3) GetLSAs() []*LSAheader {
	if m != nil {
		return m.LSAs
	}
	return nil
}

func (m *OSPFv3) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *OSPFv3) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

type LSAheader struct {
	LSAge       int32  `protobuf:"varint,1,opt,name=LSAge,proto3" json:"LSAge,omitempty"`
	LSType      int32  `protobuf:"varint,2,opt,name=LSType,proto3" json:"LSType,omitempty"`
	LinkStateID uint32 `protobuf:"varint,3,opt,name=LinkStateID,proto3" json:"LinkStateID,omitempty"`
	AdvRouter   uint32 `protobuf:"varint,4,opt,name=AdvRouter,proto3" json:"AdvRouter,omitempty"`
	LSSeqNumber uint32 `protobuf:"varint,5,opt,name=LSSeqNumber,proto3" json:"LSSeqNumber,omitempty"`
	LSChecksum  int32  `protobuf:"varint,6,opt,name=LSChecksum,proto3" json:"LSChecksum,omitempty"`
	Length      int32  `protobuf:"varint,7,opt,name=Length,proto3" json:"Length,omitempty"`
	LSOptions   int32  `protobuf:"varint,8,opt,name=LSOptions,proto3" json:"LSOptions,omitempty"`
}

func (m *LSAheader) Reset()         { *m = LSAheader{} }
func (m *LSAheader) String() string { return proto.CompactTextString(m) }
func (*LSAheader) ProtoMessage()    {}
func (*LSAheader) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{80}
}
func (m *LSAheader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LSAheader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LSAheader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LSAheader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LSAheader.Merge(m, src)
}
func (m *LSAheader) XXX_Size() int {
	return m.Size()
}
func (m *LSAheader) XXX_DiscardUnknown() {
	xxx_messageInfo_LSAheader.DiscardUnknown(m)
}

var xxx_messageInfo_LSAheader proto.InternalMessageInfo

func (m *LSAheader) GetLSAge() int32 {
	if m != nil {
		return m.LSAge
	}
	return 0
}

func (m *LSAheader) GetLSType() int32 {
	if m != nil {
		return m.LSType
	}
	return 0
}

func (m *LSAheader) GetLinkStateID() uint32 {
	if m != nil {
		return m.LinkStateID
	}
	return 0
}

func (m *LSAheader) GetAdvRouter() uint32 {
	if m != nil {
		return m.AdvRouter
	}
	return 0
}

func (m *LSAheader) GetLSSeqNumber() uint32 {
	if m != nil {
		return m.LSSeqNumber
	}
	return 0
}

func (m *LSAheader) GetLSChecksum() int32 {
	if m != nil {
		return m.LSChecksum
	}
	return 0
}

func (m *LSAheader) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *LSAheader) GetLSOptions() int32 {
	if m != nil {
		return m.LSOptions
	}
	return 0
}

// The link-state advertisement (LSA) is a basic communication means of the OSPF routing protocol for the Internet Protocol (IP).
// It communicates the router's local routing topology to all other local routers in the same OSPF area.
// OSPF is designed for scalability, so some LSAs are not flooded out on all interfaces, but only on those that belong to the appropriate area.
// In this way detailed information can be kept localized, while summary information is flooded to the rest of the network.
// The original IPv4-only OSPFv2 and the newer IPv6-compatible OSPFv3 have broadly similar LSA types.
type LSA struct {
	Header *LSAheader `protobuf:"bytes,1,opt,name=Header,proto3" json:"Header,omitempty"`
	// interface Content
	RLSAV2          *RouterLSAV2        `protobuf:"bytes,2,opt,name=RLSAV2,proto3" json:"RLSAV2,omitempty"`
	ASELSAV2        *ASExternalLSAV2    `protobuf:"bytes,3,opt,name=ASELSAV2,proto3" json:"ASELSAV2,omitempty"`
	RLSA            *RouterLSA          `protobuf:"bytes,4,opt,name=RLSA,proto3" json:"RLSA,omitempty"`
	NLSA            *NetworkLSA         `protobuf:"bytes,5,opt,name=NLSA,proto3" json:"NLSA,omitempty"`
	InterAPrefixLSA *InterAreaPrefixLSA `protobuf:"bytes,6,opt,name=InterAPrefixLSA,proto3" json:"InterAPrefixLSA,omitempty"`
	IARouterLSA     *InterAreaRouterLSA `protobuf:"bytes,7,opt,name=IARouterLSA,proto3" json:"IARouterLSA,omitempty"`
	ASELSA          *ASExternalLSA      `protobuf:"bytes,8,opt,name=ASELSA,proto3" json:"ASELSA,omitempty"`
	LLSA            *LinkLSA            `protobuf:"bytes,9,opt,name=LLSA,proto3" json:"LLSA,omitempty"`
	IntraAPrefixLSA *IntraAreaPrefixLSA `protobuf:"bytes,10,opt,name=IntraAPrefixLSA,proto3" json:"IntraAPrefixLSA,omitempty"`
	SrcIP           string              `protobuf:"bytes,11,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP           string              `protobuf:"bytes,12,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
}

func (m *LSA) Reset()         { *m = LSA{} }
func (m *LSA) String() string { return proto.CompactTextString(m) }
func (*LSA) ProtoMessage()    {}
func (*LSA) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{81}
}
func (m *LSA) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LSA) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LSA.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LSA) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LSA.Merge(m, src)
}
func (m *LSA) XXX_Size() int {
	return m.Size()
}
func (m *LSA) XXX_DiscardUnknown() {
	xxx_messageInfo_LSA.DiscardUnknown(m)
}

var xxx_messageInfo_LSA proto.InternalMessageInfo

func (m *LSA) GetHeader() *LSAheader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *LSA) GetRLSAV2() *RouterLSAV2 {
	if m != nil {
		return m.RLSAV2
	}
	return nil
}

func (m *LSA) GetASELSAV2() *ASExternalLSAV2 {
	if m != nil {
		return m.ASELSAV2
	}
	return nil
}

func (m *LSA) GetRLSA() *RouterLSA {
	if m != nil {
		return m.RLSA
	}
	return nil
}

func (m *LSA) GetNLSA() *NetworkLSA {
	if m != nil {
		return m.NLSA
	}
	return nil
}

func (m *LSA) GetInterAPrefixLSA() *InterAreaPrefixLSA {
	if m != nil {
		return m.InterAPrefixLSA
	}
	return nil
}

func (m *LSA) GetIARouterLSA() *InterAreaRouterLSA {
	if m != nil {
		return m.IARouterLSA
	}
	return nil
}

func (m *LSA) GetASELSA() *ASExternalLSA {
	if m != nil {
		return m.ASELSA
	}
	return nil
}

func (m *LSA) GetLLSA() *LinkLSA {
	if m != nil {
		return m.LLSA
	}
	return nil
}

func (m *LSA) GetIntraAPrefixLSA() *IntraAreaPrefixLSA {
	if m != nil {
		return m.IntraAPrefixLSA
	}
	return nil
}

func (m *LSA) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *LSA) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

type LSReq struct {
	LSType    int32  `protobuf:"varint,1,opt,name=LSType,proto3" json:"LSType,omitempty"`
	LSID      uint32 `protobuf:"varint,2,opt,name=LSID,proto3" json:"LSID,omitempty"`
	AdvRouter uint32 `protobuf:"varint,3,opt,name=AdvRouter,proto3" json:"AdvRouter,omitempty"`
}

func (m *LSReq) Reset()         { *m = LSReq{} }
func (m *LSReq) String() string { return proto.CompactTextString(m) }
func (*LSReq) ProtoMessage()    {}
func (*LSReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{82}
}
func (m *LSReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LSReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LSReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LSReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LSReq.Merge(m, src)
}
func (m *LSReq) XXX_Size() int {
	return m.Size()
}
func (m *LSReq) XXX_DiscardUnknown() {
	xxx_messageInfo_LSReq.DiscardUnknown(m)
}

var xxx_messageInfo_LSReq proto.InternalMessageInfo

func (m *LSReq) GetLSType() int32 {
	if m != nil {
		return m.LSType
	}
	return 0
}

func (m *LSReq) GetLSID() uint32 {
	if m != nil {
		return m.LSID
	}
	return 0
}

func (m *LSReq) GetAdvRouter() uint32 {
	if m != nil {
		return m.AdvRouter
	}
	return 0
}

type LSUpdate struct {
	NumOfLSAs uint32 `protobuf:"varint,1,opt,name=NumOfLSAs,proto3" json:"NumOfLSAs,omitempty"`
	LSAs      []*LSA `protobuf:"bytes,2,rep,name=LSAs,proto3" json:"LSAs,omitempty"`
}

func (m *LSUpdate) Reset()         { *m = LSUpdate{} }
func (m *LSUpdate) String() string { return proto.CompactTextString(m) }
func (*LSUpdate) ProtoMessage()    {}
func (*LSUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{83}
}
func (m *LSUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LSUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LSUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LSUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LSUpdate.Merge(m, src)
}
func (m *LSUpdate) XXX_Size() int {
	return m.Size()
}
func (m *LSUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_LSUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_LSUpdate proto.InternalMessageInfo

func (m *LSUpdate) GetNumOfLSAs() uint32 {
	if m != nil {
		return m.NumOfLSAs
	}
	return 0
}

func (m *LSUpdate) GetLSAs() []*LSA {
	if m != nil {
		return m.LSAs
	}
	return nil
}

type IntraAreaPrefixLSA struct {
	NumOfPrefixes  int32        `protobuf:"varint,1,opt,name=NumOfPrefixes,proto3" json:"NumOfPrefixes,omitempty"`
	RefLSType      int32        `protobuf:"varint,2,opt,name=RefLSType,proto3" json:"RefLSType,omitempty"`
	RefLinkStateID uint32       `protobuf:"varint,3,opt,name=RefLinkStateID,proto3" json:"RefLinkStateID,omitempty"`
	RefAdvRouter   uint32       `protobuf:"varint,4,opt,name=RefAdvRouter,proto3" json:"RefAdvRouter,omitempty"`
	Prefixes       []*LSAPrefix `protobuf:"bytes,5,rep,name=Prefixes,proto3" json:"Prefixes,omitempty"`
}

func (m *IntraAreaPrefixLSA) Reset()         { *m = IntraAreaPrefixLSA{} }
func (m *IntraAreaPrefixLSA) String() string { return proto.CompactTextString(m) }
func (*IntraAreaPrefixLSA) ProtoMessage()    {}
func (*IntraAreaPrefixLSA) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{84}
}
func (m *IntraAreaPrefixLSA) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IntraAreaPrefixLSA) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IntraAreaPrefixLSA.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IntraAreaPrefixLSA) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IntraAreaPrefixLSA.Merge(m, src)
}
func (m *IntraAreaPrefixLSA) XXX_Size() int {
	return m.Size()
}
func (m *IntraAreaPrefixLSA) XXX_DiscardUnknown() {
	xxx_messageInfo_IntraAreaPrefixLSA.DiscardUnknown(m)
}

var xxx_messageInfo_IntraAreaPrefixLSA proto.InternalMessageInfo

func (m *IntraAreaPrefixLSA) GetNumOfPrefixes() int32 {
	if m != nil {
		return m.NumOfPrefixes
	}
	return 0
}

func (m *IntraAreaPrefixLSA) GetRefLSType() int32 {
	if m != nil {
		return m.RefLSType
	}
	return 0
}

func (m *IntraAreaPrefixLSA) GetRefLinkStateID() uint32 {
	if m != nil {
		return m.RefLinkStateID
	}
	return 0
}

func (m *IntraAreaPrefixLSA) GetRefAdvRouter() uint32 {
	if m != nil {
		return m.RefAdvRouter
	}
	return 0
}

func (m *IntraAreaPrefixLSA) GetPrefixes() []*LSAPrefix {
	if m != nil {
		return m.Prefixes
	}
	return nil
}

type ASExternalLSA struct {
	Flags             int32  `protobuf:"varint,1,opt,name=Flags,proto3" json:"Flags,omitempty"`
	Metric            uint32 `protobuf:"varint,2,opt,name=Metric,proto3" json:"Metric,omitempty"`
	PrefixLength      int32  `protobuf:"varint,3,opt,name=PrefixLength,proto3" json:"PrefixLength,omitempty"`
	PrefixOptions     int32  `protobuf:"varint,4,opt,name=PrefixOptions,proto3" json:"PrefixOptions,omitempty"`
	RefLSType         int32  `protobuf:"varint,5,opt,name=RefLSType,proto3" json:"RefLSType,omitempty"`
	AddressPrefix     []byte `protobuf:"bytes,6,opt,name=AddressPrefix,proto3" json:"AddressPrefix,omitempty"`
	ForwardingAddress []byte `protobuf:"bytes,7,opt,name=ForwardingAddress,proto3" json:"ForwardingAddress,omitempty"`
	ExternalRouteTag  uint32 `protobuf:"varint,8,opt,name=ExternalRouteTag,proto3" json:"ExternalRouteTag,omitempty"`
	RefLinkStateID    uint32 `protobuf:"varint,9,opt,name=RefLinkStateID,proto3" json:"RefLinkStateID,omitempty"`
}

func (m *ASExternalLSA) Reset()         { *m = ASExternalLSA{} }
func (m *ASExternalLSA) String() string { return proto.CompactTextString(m) }
func (*ASExternalLSA) ProtoMessage()    {}
func (*ASExternalLSA) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{85}
}
func (m *ASExternalLSA) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ASExternalLSA) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ASExternalLSA.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ASExternalLSA) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ASExternalLSA.Merge(m, src)
}
func (m *ASExternalLSA) XXX_Size() int {
	return m.Size()
}
func (m *ASExternalLSA) XXX_DiscardUnknown() {
	xxx_messageInfo_ASExternalLSA.DiscardUnknown(m)
}

var xxx_messageInfo_ASExternalLSA proto.InternalMessageInfo

func (m *ASExternalLSA) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *ASExternalLSA) GetMetric() uint32 {
	if m != nil {
		return m.Metric
	}
	return 0
}

func (m *ASExternalLSA) GetPrefixLength() int32 {
	if m != nil {
		return m.PrefixLength
	}
	return 0
}

func (m *ASExternalLSA) GetPrefixOptions() int32 {
	if m != nil {
		return m.PrefixOptions
	}
	return 0
}

func (m *ASExternalLSA) GetRefLSType() int32 {
	if m != nil {
		return m.RefLSType
	}
	return 0
}

func (m *ASExternalLSA) GetAddressPrefix() []byte {
	if m != nil {
		return m.AddressPrefix
	}
	return nil
}

func (m *ASExternalLSA) GetForwardingAddress() []byte {
	if m != nil {
		return m.ForwardingAddress
	}
	return nil
}

func (m *ASExternalLSA) GetExternalRouteTag() uint32 {
	if m != nil {
		return m.ExternalRouteTag
	}
	return 0
}

func (m *ASExternalLSA) GetRefLinkStateID() uint32 {
	if m != nil {
		return m.RefLinkStateID
	}
	return 0
}

type InterAreaPrefixLSA struct {
	Metric        uint32 `protobuf:"varint,1,opt,name=Metric,proto3" json:"Metric,omitempty"`
	PrefixLength  int32  `protobuf:"varint,2,opt,name=PrefixLength,proto3" json:"PrefixLength,omitempty"`
	PrefixOptions int32  `protobuf:"varint,3,opt,name=PrefixOptions,proto3" json:"PrefixOptions,omitempty"`
	AddressPrefix []byte `protobuf:"bytes,4,opt,name=AddressPrefix,proto3" json:"AddressPrefix,omitempty"`
}

func (m *InterAreaPrefixLSA) Reset()         { *m = InterAreaPrefixLSA{} }
func (m *InterAreaPrefixLSA) String() string { return proto.CompactTextString(m) }
func (*InterAreaPrefixLSA) ProtoMessage()    {}
func (*InterAreaPrefixLSA) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{86}
}
func (m *InterAreaPrefixLSA) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterAreaPrefixLSA) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterAreaPrefixLSA.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterAreaPrefixLSA) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterAreaPrefixLSA.Merge(m, src)
}
func (m *InterAreaPrefixLSA) XXX_Size() int {
	return m.Size()
}
func (m *InterAreaPrefixLSA) XXX_DiscardUnknown() {
	xxx_messageInfo_InterAreaPrefixLSA.DiscardUnknown(m)
}

var xxx_messageInfo_InterAreaPrefixLSA proto.InternalMessageInfo

func (m *InterAreaPrefixLSA) GetMetric() uint32 {
	if m != nil {
		return m.Metric
	}
	return 0
}

func (m *InterAreaPrefixLSA) GetPrefixLength() int32 {
	if m != nil {
		return m.PrefixLength
	}
	return 0
}

func (m *InterAreaPrefixLSA) GetPrefixOptions() int32 {
	if m != nil {
		return m.PrefixOptions
	}
	return 0
}

func (m *InterAreaPrefixLSA) GetAddressPrefix() []byte {
	if m != nil {
		return m.AddressPrefix
	}
	return nil
}

type InterAreaRouterLSA struct {
	Options             uint32 `protobuf:"varint,1,opt,name=Options,proto3" json:"Options,omitempty"`
	Metric              uint32 `protobuf:"varint,2,opt,name=Metric,proto3" json:"Metric,omitempty"`
	DestinationRouterID uint32 `protobuf:"varint,3,opt,name=DestinationRouterID,proto3" json:"DestinationRouterID,omitempty"`
}

func (m *InterAreaRouterLSA) Reset()         { *m = InterAreaRouterLSA{} }
func (m *InterAreaRouterLSA) String() string { return proto.CompactTextString(m) }
func (*InterAreaRouterLSA) ProtoMessage()    {}
func (*InterAreaRouterLSA) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{87}
}
func (m *InterAreaRouterLSA) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterAreaRouterLSA) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterAreaRouterLSA.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterAreaRouterLSA) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterAreaRouterLSA.Merge(m, src)
}
func (m *InterAreaRouterLSA) XXX_Size() int {
	return m.Size()
}
func (m *InterAreaRouterLSA) XXX_DiscardUnknown() {
	xxx_messageInfo_InterAreaRouterLSA.DiscardUnknown(m)
}

var xxx_messageInfo_InterAreaRouterLSA proto.InternalMessageInfo

func (m *InterAreaRouterLSA) GetOptions() uint32 {
	if m != nil {
		return m.Options
	}
	return 0
}

func (m *InterAreaRouterLSA) GetMetric() uint32 {
	if m != nil {
		return m.Metric
	}
	return 0
}

func (m *InterAreaRouterLSA) GetDestinationRouterID() uint32 {
	if m != nil {
		return m.DestinationRouterID
	}
	return 0
}

type ASExternalLSAV2 struct {
	NetworkMask       uint32 `protobuf:"varint,1,opt,name=NetworkMask,proto3" json:"NetworkMask,omitempty"`
	ExternalBit       int32  `protobuf:"varint,2,opt,name=ExternalBit,proto3" json:"ExternalBit,omitempty"`
	Metric            uint32 `protobuf:"varint,3,opt,name=Metric,proto3" json:"Metric,omitempty"`
	ForwardingAddress uint32 `protobuf:"varint,4,opt,name=ForwardingAddress,proto3" json:"ForwardingAddress,omitempty"`
	ExternalRouteTag  uint32 `protobuf:"varint,5,opt,name=ExternalRouteTag,proto3" json:"ExternalRouteTag,omitempty"`
}

func (m *ASExternalLSAV2) Reset()         { *m = ASExternalLSAV2{} }
func (m *ASExternalLSAV2) String() string { return proto.CompactTextString(m) }
func (*ASExternalLSAV2) ProtoMessage()    {}
func (*ASExternalLSAV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{88}
}
func (m *ASExternalLSAV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ASExternalLSAV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ASExternalLSAV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ASExternalLSAV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ASExternalLSAV2.Merge(m, src)
}
func (m *ASExternalLSAV2) XXX_Size() int {
	return m.Size()
}
func (m *ASExternalLSAV2) XXX_DiscardUnknown() {
	xxx_messageInfo_ASExternalLSAV2.DiscardUnknown(m)
}

var xxx_messageInfo_ASExternalLSAV2 proto.InternalMessageInfo

func (m *ASExternalLSAV2) GetNetworkMask() uint32 {
	if m != nil {
		return m.NetworkMask
	}
	return 0
}

func (m *ASExternalLSAV2) GetExternalBit() int32 {
	if m != nil {
		return m.ExternalBit
	}
	return 0
}

func (m *ASExternalLSAV2) GetMetric() uint32 {
	if m != nil {
		return m.Metric
	}
	return 0
}

func (m *ASExternalLSAV2) GetForwardingAddress() uint32 {
	if m != nil {
		return m.ForwardingAddress
	}
	return 0
}

func (m *ASExternalLSAV2) GetExternalRouteTag() uint32 {
	if m != nil {
		return m.ExternalRouteTag
	}
	return 0
}

type RouterLSA struct {
	Flags   int32     `protobuf:"varint,1,opt,name=Flags,proto3" json:"Flags,omitempty"`
	Options uint32    `protobuf:"varint,2,opt,name=Options,proto3" json:"Options,omitempty"`
	Routers []*Router `protobuf:"bytes,3,rep,name=Routers,proto3" json:"Routers,omitempty"`
}

func (m *RouterLSA) Reset()         { *m = RouterLSA{} }
func (m *RouterLSA) String() string { return proto.CompactTextString(m) }
func (*RouterLSA) ProtoMessage()    {}
func (*RouterLSA) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{89}
}
func (m *RouterLSA) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouterLSA) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouterLSA.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouterLSA) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouterLSA.Merge(m, src)
}
func (m *RouterLSA) XXX_Size() int {
	return m.Size()
}
func (m *RouterLSA) XXX_DiscardUnknown() {
	xxx_messageInfo_RouterLSA.DiscardUnknown(m)
}

var xxx_messageInfo_RouterLSA proto.InternalMessageInfo

func (m *RouterLSA) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *RouterLSA) GetOptions() uint32 {
	if m != nil {
		return m.Options
	}
	return 0
}

func (m *RouterLSA) GetRouters() []*Router {
	if m != nil {
		return m.Routers
	}
	return nil
}

type Router struct {
	Type                int32  `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Metric              int32  `protobuf:"varint,2,opt,name=Metric,proto3" json:"Metric,omitempty"`
	InterfaceID         uint32 `protobuf:"varint,3,opt,name=InterfaceID,proto3" json:"InterfaceID,omitempty"`
	NeighborInterfaceID uint32 `protobuf:"varint,4,opt,name=NeighborInterfaceID,proto3" json:"NeighborInterfaceID,omitempty"`
	NeighborRouterID    uint32 `protobuf:"varint,5,opt,name=NeighborRouterID,proto3" json:"NeighborRouterID,omitempty"`
}

func (m *Router) Reset()         { *m = Router{} }
func (m *Router) String() string { return proto.CompactTextString(m) }
func (*Router) ProtoMessage()    {}
func (*Router) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{90}
}
func (m *Router) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Router) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Router.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Router) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Router.Merge(m, src)
}
func (m *Router) XXX_Size() int {
	return m.Size()
}
func (m *Router) XXX_DiscardUnknown() {
	xxx_messageInfo_Router.DiscardUnknown(m)
}

var xxx_messageInfo_Router proto.InternalMessageInfo

func (m *Router) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Router) GetMetric() int32 {
	if m != nil {
		return m.Metric
	}
	return 0
}

func (m *Router) GetInterfaceID() uint32 {
	if m != nil {
		return m.InterfaceID
	}
	return 0
}

func (m *Router) GetNeighborInterfaceID() uint32 {
	if m != nil {
		return m.NeighborInterfaceID
	}
	return 0
}

func (m *Router) GetNeighborRouterID() uint32 {
	if m != nil {
		return m.NeighborRouterID
	}
	return 0
}

type RouterLSAV2 struct {
	Flags   int32       `protobuf:"varint,1,opt,name=Flags,proto3" json:"Flags,omitempty"`
	Links   int32       `protobuf:"varint,2,opt,name=Links,proto3" json:"Links,omitempty"`
	Routers []*RouterV2 `protobuf:"bytes,3,rep,name=Routers,proto3" json:"Routers,omitempty"`
}

func (m *RouterLSAV2) Reset()         { *m = RouterLSAV2{} }
func (m *RouterLSAV2) String() string { return proto.CompactTextString(m) }
func (*RouterLSAV2) ProtoMessage()    {}
func (*RouterLSAV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{91}
}
func (m *RouterLSAV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouterLSAV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouterLSAV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouterLSAV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouterLSAV2.Merge(m, src)
}
func (m *RouterLSAV2) XXX_Size() int {
	return m.Size()
}
func (m *RouterLSAV2) XXX_DiscardUnknown() {
	xxx_messageInfo_RouterLSAV2.DiscardUnknown(m)
}

var xxx_messageInfo_RouterLSAV2 proto.InternalMessageInfo

func (m *RouterLSAV2) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *RouterLSAV2) GetLinks() int32 {
	if m != nil {
		return m.Links
	}
	return 0
}

func (m *RouterLSAV2) GetRouters() []*RouterV2 {
	if m != nil {
		return m.Routers
	}
	return nil
}

type RouterV2 struct {
	Type     int32  `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	LinkID   uint32 `protobuf:"varint,2,opt,name=LinkID,proto3" json:"LinkID,omitempty"`
	LinkData uint32 `protobuf:"varint,3,opt,name=LinkData,proto3" json:"LinkData,omitempty"`
	Metric   uint32 `protobuf:"varint,4,opt,name=Metric,proto3" json:"Metric,omitempty"`
}

func (m *RouterV2) Reset()         { *m = RouterV2{} }
func (m *RouterV2) String() string { return proto.CompactTextString(m) }
func (*RouterV2) ProtoMessage()    {}
func (*RouterV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{92}
}
func (m *RouterV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouterV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouterV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouterV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouterV2.Merge(m, src)
}
func (m *RouterV2) XXX_Size() int {
	return m.Size()
}
func (m *RouterV2) XXX_DiscardUnknown() {
	xxx_messageInfo_RouterV2.DiscardUnknown(m)
}

var xxx_messageInfo_RouterV2 proto.InternalMessageInfo

func (m *RouterV2) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *RouterV2) GetLinkID() uint32 {
	if m != nil {
		return m.LinkID
	}
	return 0
}

func (m *RouterV2) GetLinkData() uint32 {
	if m != nil {
		return m.LinkData
	}
	return 0
}

func (m *RouterV2) GetMetric() uint32 {
	if m != nil {
		return m.Metric
	}
	return 0
}

type NetworkLSA struct {
	Options        uint32   `protobuf:"varint,1,opt,name=Options,proto3" json:"Options,omitempty"`
	AttachedRouter []uint32 `protobuf:"varint,2,rep,packed,name=AttachedRouter,proto3" json:"AttachedRouter,omitempty"`
}

func (m *NetworkLSA) Reset()         { *m = NetworkLSA{} }
func (m *NetworkLSA) String() string { return proto.CompactTextString(m) }
func (*NetworkLSA) ProtoMessage()    {}
func (*NetworkLSA) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{93}
}
func (m *NetworkLSA) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkLSA) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkLSA.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkLSA) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkLSA.Merge(m, src)
}
func (m *NetworkLSA) XXX_Size() int {
	return m.Size()
}
func (m *NetworkLSA) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkLSA.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkLSA proto.InternalMessageInfo

func (m *NetworkLSA) GetOptions() uint32 {
	if m != nil {
		return m.Options
	}
	return 0
}

func (m *NetworkLSA) GetAttachedRouter() []uint32 {
	if m != nil {
		return m.AttachedRouter
	}
	return nil
}

type LinkLSA struct {
	RtrPriority      int32        `protobuf:"varint,1,opt,name=RtrPriority,proto3" json:"RtrPriority,omitempty"`
	Options          uint32       `protobuf:"varint,2,opt,name=Options,proto3" json:"Options,omitempty"`
	LinkLocalAddress []byte       `protobuf:"bytes,3,opt,name=LinkLocalAddress,proto3" json:"LinkLocalAddress,omitempty"`
	NumOfPrefixes    uint32       `protobuf:"varint,4,opt,name=NumOfPrefixes,proto3" json:"NumOfPrefixes,omitempty"`
	Prefixes         []*LSAPrefix `protobuf:"bytes,5,rep,name=Prefixes,proto3" json:"Prefixes,omitempty"`
}

func (m *LinkLSA) Reset()         { *m = LinkLSA{} }
func (m *LinkLSA) String() string { return proto.CompactTextString(m) }
func (*LinkLSA) ProtoMessage()    {}
func (*LinkLSA) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{94}
}
func (m *LinkLSA) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LinkLSA) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LinkLSA.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LinkLSA) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LinkLSA.Merge(m, src)
}
func (m *LinkLSA) XXX_Size() int {
	return m.Size()
}
func (m *LinkLSA) XXX_DiscardUnknown() {
	xxx_messageInfo_LinkLSA.DiscardUnknown(m)
}

var xxx_messageInfo_LinkLSA proto.InternalMessageInfo

func (m *LinkLSA) GetRtrPriority() int32 {
	if m != nil {
		return m.RtrPriority
	}
	return 0
}

func (m *LinkLSA) GetOptions() uint32 {
	if m != nil {
		return m.Options
	}
	return 0
}

func (m *LinkLSA) GetLinkLocalAddress() []byte {
	if m != nil {
		return m.LinkLocalAddress
	}
	return nil
}

func (m *LinkLSA) GetNumOfPrefixes() uint32 {
	if m != nil {
		return m.NumOfPrefixes
	}
	return 0
}

func (m *LinkLSA) GetPrefixes() []*LSAPrefix {
	if m != nil {
		return m.Prefixes
	}
	return nil
}

type LSAPrefix struct {
	PrefixLength  int32  `protobuf:"varint,1,opt,name=PrefixLength,proto3" json:"PrefixLength,omitempty"`
	PrefixOptions int32  `protobuf:"varint,2,opt,name=PrefixOptions,proto3" json:"PrefixOptions,omitempty"`
	Metric        int32  `protobuf:"varint,3,opt,name=Metric,proto3" json:"Metric,omitempty"`
	AddressPrefix []byte `protobuf:"bytes,4,opt,name=AddressPrefix,proto3" json:"AddressPrefix,omitempty"`
}

func (m *LSAPrefix) Reset()         { *m = LSAPrefix{} }
func (m *LSAPrefix) String() string { return proto.CompactTextString(m) }
func (*LSAPrefix) ProtoMessage()    {}
func (*LSAPrefix) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{95}
}
func (m *LSAPrefix) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LSAPrefix) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LSAPrefix.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LSAPrefix) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LSAPrefix.Merge(m, src)
}
func (m *LSAPrefix) XXX_Size() int {
	return m.Size()
}
func (m *LSAPrefix) XXX_DiscardUnknown() {
	xxx_messageInfo_LSAPrefix.DiscardUnknown(m)
}

var xxx_messageInfo_LSAPrefix proto.InternalMessageInfo

func (m *LSAPrefix) GetPrefixLength() int32 {
	if m != nil {
		return m.PrefixLength
	}
	return 0
}

func (m *LSAPrefix) GetPrefixOptions() int32 {
	if m != nil {
		return m.PrefixOptions
	}
	return 0
}

func (m *LSAPrefix) GetMetric() int32 {
	if m != nil {
		return m.Metric
	}
	return 0
}

func (m *LSAPrefix) GetAddressPrefix() []byte {
	if m != nil {
		return m.AddressPrefix
	}
	return nil
}

// BFD is a detection protocol designed to provide fast forwarding path
// failure detection times for all media types, encapsulations, topologies,
// and routing protocols. In addition to fast forwarding path failure detection,
// BFD provides a consistent failure detection method for network administrators.
type BFD struct {
	Timestamp                 int64          `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Version                   int32          `protobuf:"varint,2,opt,name=Version,proto3" json:"Version,omitempty"`
	Diagnostic                int32          `protobuf:"varint,3,opt,name=Diagnostic,proto3" json:"Diagnostic,omitempty"`
	State                     int32          `protobuf:"varint,4,opt,name=State,proto3" json:"State,omitempty"`
	Poll                      bool           `protobuf:"varint,5,opt,name=Poll,proto3" json:"Poll,omitempty"`
	Final                     bool           `protobuf:"varint,6,opt,name=Final,proto3" json:"Final,omitempty"`
	ControlPlaneIndependent   bool           `protobuf:"varint,7,opt,name=ControlPlaneIndependent,proto3" json:"ControlPlaneIndependent,omitempty"`
	AuthPresent               bool           `protobuf:"varint,8,opt,name=AuthPresent,proto3" json:"AuthPresent,omitempty"`
	Demand                    bool           `protobuf:"varint,9,opt,name=Demand,proto3" json:"Demand,omitempty"`
	Multipoint                bool           `protobuf:"varint,10,opt,name=Multipoint,proto3" json:"Multipoint,omitempty"`
	DetectMultiplier          int32          `protobuf:"varint,11,opt,name=DetectMultiplier,proto3" json:"DetectMultiplier,omitempty"`
	MyDiscriminator           int32          `protobuf:"varint,12,opt,name=MyDiscriminator,proto3" json:"MyDiscriminator,omitempty"`
	YourDiscriminator         int32          `protobuf:"varint,13,opt,name=YourDiscriminator,proto3" json:"YourDiscriminator,omitempty"`
	DesiredMinTxInterval      int32          `protobuf:"varint,14,opt,name=DesiredMinTxInterval,proto3" json:"DesiredMinTxInterval,omitempty"`
	RequiredMinRxInterval     int32          `protobuf:"varint,15,opt,name=RequiredMinRxInterval,proto3" json:"RequiredMinRxInterval,omitempty"`
	RequiredMinEchoRxInterval int32          `protobuf:"varint,16,opt,name=RequiredMinEchoRxInterval,proto3" json:"RequiredMinEchoRxInterval,omitempty"`
	AuthHeader                *BFDAuthHeader `protobuf:"bytes,17,opt,name=AuthHeader,proto3" json:"AuthHeader,omitempty"`
}

func (m *BFD) Reset()         { *m = BFD{} }
func (m *BFD) String() string { return proto.CompactTextString(m) }
func (*BFD) ProtoMessage()    {}
func (*BFD) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{96}
}
func (m *BFD) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BFD) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BFD.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BFD) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BFD.Merge(m, src)
}
func (m *BFD) XXX_Size() int {
	return m.Size()
}
func (m *BFD) XXX_DiscardUnknown() {
	xxx_messageInfo_BFD.DiscardUnknown(m)
}

var xxx_messageInfo_BFD proto.InternalMessageInfo

func (m *BFD) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *BFD) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *BFD) GetDiagnostic() int32 {
	if m != nil {
		return m.Diagnostic
	}
	return 0
}

func (m *BFD) GetState() int32 {
	if m != nil {
		return m.State
	}
	return 0
}

func (m *BFD) GetPoll() bool {
	if m != nil {
		return m.Poll
	}
	return false
}

func (m *BFD) GetFinal() bool {
	if m != nil {
		return m.Final
	}
	return false
}

func (m *BFD) GetControlPlaneIndependent() bool {
	if m != nil {
		return m.ControlPlaneIndependent
	}
	return false
}

func (m *BFD) GetAuthPresent() bool {
	if m != nil {
		return m.AuthPresent
	}
	return false
}

func (m *BFD) GetDemand() bool {
	if m != nil {
		return m.Demand
	}
	return false
}

func (m *BFD) GetMultipoint() bool {
	if m != nil {
		return m.Multipoint
	}
	return false
}

func (m *BFD) GetDetectMultiplier() int32 {
	if m != nil {
		return m.DetectMultiplier
	}
	return 0
}

func (m *BFD) GetMyDiscriminator() int32 {
	if m != nil {
		return m.MyDiscriminator
	}
	return 0
}

func (m *BFD) GetYourDiscriminator() int32 {
	if m != nil {
		return m.YourDiscriminator
	}
	return 0
}

func (m *BFD) GetDesiredMinTxInterval() int32 {
	if m != nil {
		return m.DesiredMinTxInterval
	}
	return 0
}

func (m *BFD) GetRequiredMinRxInterval() int32 {
	if m != nil {
		return m.RequiredMinRxInterval
	}
	return 0
}

func (m *BFD) GetRequiredMinEchoRxInterval() int32 {
	if m != nil {
		return m.RequiredMinEchoRxInterval
	}
	return 0
}

func (m *BFD) GetAuthHeader() *BFDAuthHeader {
	if m != nil {
		return m.AuthHeader
	}
	return nil
}

type BFDAuthHeader struct {
	AuthType       int32  `protobuf:"varint,1,opt,name=AuthType,proto3" json:"AuthType,omitempty"`
	KeyID          int32  `protobuf:"varint,2,opt,name=KeyID,proto3" json:"KeyID,omitempty"`
	SequenceNumber int32  `protobuf:"varint,3,opt,name=SequenceNumber,proto3" json:"SequenceNumber,omitempty"`
	Data           []byte `protobuf:"bytes,4,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *BFDAuthHeader) Reset()         { *m = BFDAuthHeader{} }
func (m *BFDAuthHeader) String() string { return proto.CompactTextString(m) }
func (*BFDAuthHeader) ProtoMessage()    {}
func (*BFDAuthHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{97}
}
func (m *BFDAuthHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BFDAuthHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BFDAuthHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BFDAuthHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BFDAuthHeader.Merge(m, src)
}
func (m *BFDAuthHeader) XXX_Size() int {
	return m.Size()
}
func (m *BFDAuthHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_BFDAuthHeader.DiscardUnknown(m)
}

var xxx_messageInfo_BFDAuthHeader proto.InternalMessageInfo

func (m *BFDAuthHeader) GetAuthType() int32 {
	if m != nil {
		return m.AuthType
	}
	return 0
}

func (m *BFDAuthHeader) GetKeyID() int32 {
	if m != nil {
		return m.KeyID
	}
	return 0
}

func (m *BFDAuthHeader) GetSequenceNumber() int32 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *BFDAuthHeader) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// Generic Routing Encapsulation is a tunneling protocol developed by
// Cisco Systems that can encapsulate a wide variety of network layer
// protocols inside virtual point-to-point links or point-to-multipoint
// links over an Internet Protocol network.
type GRE struct {
	Timestamp         int64       `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	ChecksumPresent   bool        `protobuf:"varint,2,opt,name=ChecksumPresent,proto3" json:"ChecksumPresent,omitempty"`
	RoutingPresent    bool        `protobuf:"varint,3,opt,name=RoutingPresent,proto3" json:"RoutingPresent,omitempty"`
	KeyPresent        bool        `protobuf:"varint,4,opt,name=KeyPresent,proto3" json:"KeyPresent,omitempty"`
	SeqPresent        bool        `protobuf:"varint,5,opt,name=SeqPresent,proto3" json:"SeqPresent,omitempty"`
	StrictSourceRoute bool        `protobuf:"varint,6,opt,name=StrictSourceRoute,proto3" json:"StrictSourceRoute,omitempty"`
	AckPresent        bool        `protobuf:"varint,7,opt,name=AckPresent,proto3" json:"AckPresent,omitempty"`
	RecursionControl  int32       `protobuf:"varint,8,opt,name=RecursionControl,proto3" json:"RecursionControl,omitempty"`
	Flags             int32       `protobuf:"varint,9,opt,name=Flags,proto3" json:"Flags,omitempty"`
	Version           int32       `protobuf:"varint,10,opt,name=Version,proto3" json:"Version,omitempty"`
	Protocol          int32       `protobuf:"varint,11,opt,name=Protocol,proto3" json:"Protocol,omitempty"`
	Checksum          int32       `protobuf:"varint,12,opt,name=Checksum,proto3" json:"Checksum,omitempty"`
	Offset            int32       `protobuf:"varint,13,opt,name=Offset,proto3" json:"Offset,omitempty"`
	Key               uint32      `protobuf:"varint,14,opt,name=Key,proto3" json:"Key,omitempty"`
	Seq               uint32      `protobuf:"varint,15,opt,name=Seq,proto3" json:"Seq,omitempty"`
	Ack               uint32      `protobuf:"varint,16,opt,name=Ack,proto3" json:"Ack,omitempty"`
	Routing           *GRERouting `protobuf:"bytes,17,opt,name=Routing,proto3" json:"Routing,omitempty"`
	SrcIP             string      `protobuf:"bytes,18,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP             string      `protobuf:"bytes,19,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
}

func (m *GRE) Reset()         { *m = GRE{} }
func (m *GRE) String() string { return proto.CompactTextString(m) }
func (*GRE) ProtoMessage()    {}
func (*GRE) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{98}
}
func (m *GRE) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GRE) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GRE.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GRE) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GRE.Merge(m, src)
}
func (m *GRE) XXX_Size() int {
	return m.Size()
}
func (m *GRE) XXX_DiscardUnknown() {
	xxx_messageInfo_GRE.DiscardUnknown(m)
}

var xxx_messageInfo_GRE proto.InternalMessageInfo

func (m *GRE) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *GRE) GetChecksumPresent() bool {
	if m != nil {
		return m.ChecksumPresent
	}
	return false
}

func (m *GRE) GetRoutingPresent() bool {
	if m != nil {
		return m.RoutingPresent
	}
	return false
}

func (m *GRE) GetKeyPresent() bool {
	if m != nil {
		return m.KeyPresent
	}
	return false
}

func (m *GRE) GetSeqPresent() bool {
	if m != nil {
		return m.SeqPresent
	}
	return false
}

func (m *GRE) GetStrictSourceRoute() bool {
	if m != nil {
		return m.StrictSourceRoute
	}
	return false
}

func (m *GRE) GetAckPresent() bool {
	if m != nil {
		return m.AckPresent
	}
	return false
}

func (m *GRE) GetRecursionControl() int32 {
	if m != nil {
		return m.RecursionControl
	}
	return 0
}

func (m *GRE) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *GRE) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *GRE) GetProtocol() int32 {
	if m != nil {
		return m.Protocol
	}
	return 0
}

func (m *GRE) GetChecksum() int32 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

func (m *GRE) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *GRE) GetKey() uint32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *GRE) GetSeq() uint32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *GRE) GetAck() uint32 {
	if m != nil {
		return m.Ack
	}
	return 0
}

func (m *GRE) GetRouting() *GRERouting {
	if m != nil {
		return m.Routing
	}
	return nil
}

func (m *GRE) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *GRE) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

type GRERouting struct {
	AddressFamily      int32       `protobuf:"varint,1,opt,name=AddressFamily,proto3" json:"AddressFamily,omitempty"`
	SREOffset          int32       `protobuf:"varint,2,opt,name=SREOffset,proto3" json:"SREOffset,omitempty"`
	SRELength          int32       `protobuf:"varint,3,opt,name=SRELength,proto3" json:"SRELength,omitempty"`
	RoutingInformation []byte      `protobuf:"bytes,4,opt,name=RoutingInformation,proto3" json:"RoutingInformation,omitempty"`
	Next               *GRERouting `protobuf:"bytes,5,opt,name=Next,proto3" json:"Next,omitempty"`
}

func (m *GRERouting) Reset()         { *m = GRERouting{} }
func (m *GRERouting) String() string { return proto.CompactTextString(m) }
func (*GRERouting) ProtoMessage()    {}
func (*GRERouting) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{99}
}
func (m *GRERouting) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GRERouting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GRERouting.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GRERouting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GRERouting.Merge(m, src)
}
func (m *GRERouting) XXX_Size() int {
	return m.Size()
}
func (m *GRERouting) XXX_DiscardUnknown() {
	xxx_messageInfo_GRERouting.DiscardUnknown(m)
}

var xxx_messageInfo_GRERouting proto.InternalMessageInfo

func (m *GRERouting) GetAddressFamily() int32 {
	if m != nil {
		return m.AddressFamily
	}
	return 0
}

func (m *GRERouting) GetSREOffset() int32 {
	if m != nil {
		return m.SREOffset
	}
	return 0
}

func (m *GRERouting) GetSRELength() int32 {
	if m != nil {
		return m.SRELength
	}
	return 0
}

func (m *GRERouting) GetRoutingInformation() []byte {
	if m != nil {
		return m.RoutingInformation
	}
	return nil
}

func (m *GRERouting) GetNext() *GRERouting {
	if m != nil {
		return m.Next
	}
	return nil
}

type FDDI struct {
	Timestamp    int64  `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	FrameControl int32  `protobuf:"varint,2,opt,name=FrameControl,proto3" json:"FrameControl,omitempty"`
	Priority     int32  `protobuf:"varint,3,opt,name=Priority,proto3" json:"Priority,omitempty"`
	SrcMAC       string `protobuf:"bytes,4,opt,name=SrcMAC,proto3" json:"SrcMAC,omitempty"`
	DstMAC       string `protobuf:"bytes,5,opt,name=DstMAC,proto3" json:"DstMAC,omitempty"`
}

func (m *FDDI) Reset()         { *m = FDDI{} }
func (m *FDDI) String() string { return proto.CompactTextString(m) }
func (*FDDI) ProtoMessage()    {}
func (*FDDI) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{100}
}
func (m *FDDI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FDDI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FDDI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FDDI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FDDI.Merge(m, src)
}
func (m *FDDI) XXX_Size() int {
	return m.Size()
}
func (m *FDDI) XXX_DiscardUnknown() {
	xxx_messageInfo_FDDI.DiscardUnknown(m)
}

var xxx_messageInfo_FDDI proto.InternalMessageInfo

func (m *FDDI) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *FDDI) GetFrameControl() int32 {
	if m != nil {
		return m.FrameControl
	}
	return 0
}

func (m *FDDI) GetPriority() int32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *FDDI) GetSrcMAC() string {
	if m != nil {
		return m.SrcMAC
	}
	return ""
}

func (m *FDDI) GetDstMAC() string {
	if m != nil {
		return m.DstMAC
	}
	return ""
}

// EAP defines an Extensible Authentication Protocol (rfc 3748) layer.
type EAP struct {
	Timestamp int64  `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Code      int32  `protobuf:"varint,2,opt,name=Code,proto3" json:"Code,omitempty"`
	Id        int32  `protobuf:"varint,3,opt,name=Id,proto3" json:"Id,omitempty"`
	Length    int32  `protobuf:"varint,4,opt,name=Length,proto3" json:"Length,omitempty"`
	Type      int32  `protobuf:"varint,5,opt,name=Type,proto3" json:"Type,omitempty"`
	TypeData  []byte `protobuf:"bytes,6,opt,name=TypeData,proto3" json:"TypeData,omitempty"`
}

func (m *EAP) Reset()         { *m = EAP{} }
func (m *EAP) String() string { return proto.CompactTextString(m) }
func (*EAP) ProtoMessage()    {}
func (*EAP) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{101}
}
func (m *EAP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EAP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EAP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EAP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EAP.Merge(m, src)
}
func (m *EAP) XXX_Size() int {
	return m.Size()
}
func (m *EAP) XXX_DiscardUnknown() {
	xxx_messageInfo_EAP.DiscardUnknown(m)
}

var xxx_messageInfo_EAP proto.InternalMessageInfo

func (m *EAP) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *EAP) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *EAP) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *EAP) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *EAP) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *EAP) GetTypeData() []byte {
	if m != nil {
		return m.TypeData
	}
	return nil
}

// EAPOL defines an EAP over LAN (802.1x) layer.
type EAPOL struct {
	Timestamp int64 `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Version   int32 `protobuf:"varint,2,opt,name=Version,proto3" json:"Version,omitempty"`
	Type      int32 `protobuf:"varint,3,opt,name=Type,proto3" json:"Type,omitempty"`
	Length    int32 `protobuf:"varint,4,opt,name=Length,proto3" json:"Length,omitempty"`
}

func (m *EAPOL) Reset()         { *m = EAPOL{} }
func (m *EAPOL) String() string { return proto.CompactTextString(m) }
func (*EAPOL) ProtoMessage()    {}
func (*EAPOL) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{102}
}
func (m *EAPOL) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EAPOL) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EAPOL.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EAPOL) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EAPOL.Merge(m, src)
}
func (m *EAPOL) XXX_Size() int {
	return m.Size()
}
func (m *EAPOL) XXX_DiscardUnknown() {
	xxx_messageInfo_EAPOL.DiscardUnknown(m)
}

var xxx_messageInfo_EAPOL proto.InternalMessageInfo

func (m *EAPOL) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *EAPOL) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *EAPOL) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *EAPOL) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

// EAPOLKey defines an EAPOL-Key frame for 802.1x authentication
type EAPOLKey struct {
	Timestamp            int64  `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	KeyDescriptorType    int32  `protobuf:"varint,2,opt,name=KeyDescriptorType,proto3" json:"KeyDescriptorType,omitempty"`
	KeyDescriptorVersion int32  `protobuf:"varint,3,opt,name=KeyDescriptorVersion,proto3" json:"KeyDescriptorVersion,omitempty"`
	KeyType              int32  `protobuf:"varint,4,opt,name=KeyType,proto3" json:"KeyType,omitempty"`
	KeyIndex             int32  `protobuf:"varint,5,opt,name=KeyIndex,proto3" json:"KeyIndex,omitempty"`
	Install              bool   `protobuf:"varint,6,opt,name=Install,proto3" json:"Install,omitempty"`
	KeyACK               bool   `protobuf:"varint,7,opt,name=KeyACK,proto3" json:"KeyACK,omitempty"`
	KeyMIC               bool   `protobuf:"varint,8,opt,name=KeyMIC,proto3" json:"KeyMIC,omitempty"`
	Secure               bool   `protobuf:"varint,9,opt,name=Secure,proto3" json:"Secure,omitempty"`
	MICError             bool   `protobuf:"varint,10,opt,name=MICError,proto3" json:"MICError,omitempty"`
	Request              bool   `protobuf:"varint,11,opt,name=Request,proto3" json:"Request,omitempty"`
	HasEncryptedKeyData  bool   `protobuf:"varint,12,opt,name=HasEncryptedKeyData,proto3" json:"HasEncryptedKeyData,omitempty"`
	SMKMessage           bool   `protobuf:"varint,13,opt,name=SMKMessage,proto3" json:"SMKMessage,omitempty"`
	KeyLength            int32  `protobuf:"varint,14,opt,name=KeyLength,proto3" json:"KeyLength,omitempty"`
	ReplayCounter        uint64 `protobuf:"varint,15,opt,name=ReplayCounter,proto3" json:"ReplayCounter,omitempty"`
	Nonce                []byte `protobuf:"bytes,16,opt,name=Nonce,proto3" json:"Nonce,omitempty"`
	IV                   []byte `protobuf:"bytes,17,opt,name=IV,proto3" json:"IV,omitempty"`
	RSC                  uint64 `protobuf:"varint,18,opt,name=RSC,proto3" json:"RSC,omitempty"`
	ID                   uint64 `protobuf:"varint,19,opt,name=ID,proto3" json:"ID,omitempty"`
	MIC                  []byte `protobuf:"bytes,20,opt,name=MIC,proto3" json:"MIC,omitempty"`
	KeyDataLength        int32  `protobuf:"varint,21,opt,name=KeyDataLength,proto3" json:"KeyDataLength,omitempty"`
	EncryptedKeyData     []byte `protobuf:"bytes,22,opt,name=EncryptedKeyData,proto3" json:"EncryptedKeyData,omitempty"`
}

func (m *EAPOLKey) Reset()         { *m = EAPOLKey{} }
func (m *EAPOLKey) String() string { return proto.CompactTextString(m) }
func (*EAPOLKey) ProtoMessage()    {}
func (*EAPOLKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{103}
}
func (m *EAPOLKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EAPOLKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EAPOLKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EAPOLKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EAPOLKey.Merge(m, src)
}
func (m *EAPOLKey) XXX_Size() int {
	return m.Size()
}
func (m *EAPOLKey) XXX_DiscardUnknown() {
	xxx_messageInfo_EAPOLKey.DiscardUnknown(m)
}

var xxx_messageInfo_EAPOLKey proto.InternalMessageInfo

func (m *EAPOLKey) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *EAPOLKey) GetKeyDescriptorType() int32 {
	if m != nil {
		return m.KeyDescriptorType
	}
	return 0
}

func (m *EAPOLKey) GetKeyDescriptorVersion() int32 {
	if m != nil {
		return m.KeyDescriptorVersion
	}
	return 0
}

func (m *EAPOLKey) GetKeyType() int32 {
	if m != nil {
		return m.KeyType
	}
	return 0
}

func (m *EAPOLKey) GetKeyIndex() int32 {
	if m != nil {
		return m.KeyIndex
	}
	return 0
}

func (m *EAPOLKey) GetInstall() bool {
	if m != nil {
		return m.Install
	}
	return false
}

func (m *EAPOLKey) GetKeyACK() bool {
	if m != nil {
		return m.KeyACK
	}
	return false
}

func (m *EAPOLKey) GetKeyMIC() bool {
	if m != nil {
		return m.KeyMIC
	}
	return false
}

func (m *EAPOLKey) GetSecure() bool {
	if m != nil {
		return m.Secure
	}
	return false
}

func (m *EAPOLKey) GetMICError() bool {
	if m != nil {
		return m.MICError
	}
	return false
}

func (m *EAPOLKey) GetRequest() bool {
	if m != nil {
		return m.Request
	}
	return false
}

func (m *EAPOLKey) GetHasEncryptedKeyData() bool {
	if m != nil {
		return m.HasEncryptedKeyData
	}
	return false
}

func (m *EAPOLKey) GetSMKMessage() bool {
	if m != nil {
		return m.SMKMessage
	}
	return false
}

func (m *EAPOLKey) GetKeyLength() int32 {
	if m != nil {
		return m.KeyLength
	}
	return 0
}

func (m *EAPOLKey) GetReplayCounter() uint64 {
	if m != nil {
		return m.ReplayCounter
	}
	return 0
}

func (m *EAPOLKey) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

func (m *EAPOLKey) GetIV() []byte {
	if m != nil {
		return m.IV
	}
	return nil
}

func (m *EAPOLKey) GetRSC() uint64 {
	if m != nil {
		return m.RSC
	}
	return 0
}

func (m *EAPOLKey) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *EAPOLKey) GetMIC() []byte {
	if m != nil {
		return m.MIC
	}
	return nil
}

func (m *EAPOLKey) GetKeyDataLength() int32 {
	if m != nil {
		return m.KeyDataLength
	}
	return 0
}

func (m *EAPOLKey) GetEncryptedKeyData() []byte {
	if m != nil {
		return m.EncryptedKeyData
	}
	return nil
}

// The Virtual Router Redundancy Protocol (VRRP) is a computer
// networking protocol that provides for automatic assignment of
// available Internet Protocol (IP) routers to participating hosts.
// This increases the availability and reliability of routing paths via
// automatic default gateway selections on an IP subnetwork.
type VRRPv2 struct {
	Timestamp    int64    `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Version      int32    `protobuf:"varint,2,opt,name=Version,proto3" json:"Version,omitempty"`
	Type         int32    `protobuf:"varint,3,opt,name=Type,proto3" json:"Type,omitempty"`
	VirtualRtrID int32    `protobuf:"varint,4,opt,name=VirtualRtrID,proto3" json:"VirtualRtrID,omitempty"`
	Priority     int32    `protobuf:"varint,5,opt,name=Priority,proto3" json:"Priority,omitempty"`
	CountIPAddr  int32    `protobuf:"varint,6,opt,name=CountIPAddr,proto3" json:"CountIPAddr,omitempty"`
	AuthType     int32    `protobuf:"varint,7,opt,name=AuthType,proto3" json:"AuthType,omitempty"`
	AdverInt     int32    `protobuf:"varint,8,opt,name=AdverInt,proto3" json:"AdverInt,omitempty"`
	Checksum     int32    `protobuf:"varint,9,opt,name=Checksum,proto3" json:"Checksum,omitempty"`
	IPAddress    []string `protobuf:"bytes,10,rep,name=IPAddress,proto3" json:"IPAddress,omitempty"`
	SrcIP        string   `protobuf:"bytes,11,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP        string   `protobuf:"bytes,12,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
}

func (m *VRRPv2) Reset()         { *m = VRRPv2{} }
func (m *VRRPv2) String() string { return proto.CompactTextString(m) }
func (*VRRPv2) ProtoMessage()    {}
func (*VRRPv2) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{104}
}
func (m *VRRPv2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VRRPv2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VRRPv2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VRRPv2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VRRPv2.Merge(m, src)
}
func (m *VRRPv2) XXX_Size() int {
	return m.Size()
}
func (m *VRRPv2) XXX_DiscardUnknown() {
	xxx_messageInfo_VRRPv2.DiscardUnknown(m)
}

var xxx_messageInfo_VRRPv2 proto.InternalMessageInfo

func (m *VRRPv2) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *VRRPv2) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *VRRPv2) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *VRRPv2) GetVirtualRtrID() int32 {
	if m != nil {
		return m.VirtualRtrID
	}
	return 0
}

func (m *VRRPv2) GetPriority() int32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *VRRPv2) GetCountIPAddr() int32 {
	if m != nil {
		return m.CountIPAddr
	}
	return 0
}

func (m *VRRPv2) GetAuthType() int32 {
	if m != nil {
		return m.AuthType
	}
	return 0
}

func (m *VRRPv2) GetAdverInt() int32 {
	if m != nil {
		return m.AdverInt
	}
	return 0
}

func (m *VRRPv2) GetChecksum() int32 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

func (m *VRRPv2) GetIPAddress() []string {
	if m != nil {
		return m.IPAddress
	}
	return nil
}

func (m *VRRPv2) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *VRRPv2) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

// Cisco Discovery Protocol is a proprietary Data Link Layer protocol
// developed by Cisco Systems in 1994 by Keith McCloghrie and Dino Farinacci.
// It is used to share information about other directly connected Cisco equipment,
// such as the operating system version and IP address.
type CiscoDiscovery struct {
	Timestamp int64                  `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Version   int32                  `protobuf:"varint,2,opt,name=Version,proto3" json:"Version,omitempty"`
	TTL       int32                  `protobuf:"varint,3,opt,name=TTL,proto3" json:"TTL,omitempty"`
	Checksum  int32                  `protobuf:"varint,4,opt,name=Checksum,proto3" json:"Checksum,omitempty"`
	Values    []*CiscoDiscoveryValue `protobuf:"bytes,5,rep,name=Values,proto3" json:"Values,omitempty"`
}

func (m *CiscoDiscovery) Reset()         { *m = CiscoDiscovery{} }
func (m *CiscoDiscovery) String() string { return proto.CompactTextString(m) }
func (*CiscoDiscovery) ProtoMessage()    {}
func (*CiscoDiscovery) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{105}
}
func (m *CiscoDiscovery) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CiscoDiscovery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CiscoDiscovery.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CiscoDiscovery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CiscoDiscovery.Merge(m, src)
}
func (m *CiscoDiscovery) XXX_Size() int {
	return m.Size()
}
func (m *CiscoDiscovery) XXX_DiscardUnknown() {
	xxx_messageInfo_CiscoDiscovery.DiscardUnknown(m)
}

var xxx_messageInfo_CiscoDiscovery proto.InternalMessageInfo

func (m *CiscoDiscovery) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *CiscoDiscovery) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *CiscoDiscovery) GetTTL() int32 {
	if m != nil {
		return m.TTL
	}
	return 0
}

func (m *CiscoDiscovery) GetChecksum() int32 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

func (m *CiscoDiscovery) GetValues() []*CiscoDiscoveryValue {
	if m != nil {
		return m.Values
	}
	return nil
}

type CiscoDiscoveryValue struct {
	Type   int32  `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Length int32  `protobuf:"varint,2,opt,name=Length,proto3" json:"Length,omitempty"`
	Value  []byte `protobuf:"bytes,3,opt,name=Value,proto3" json:"Value,omitempty"`
}

func (m *CiscoDiscoveryValue) Reset()         { *m = CiscoDiscoveryValue{} }
func (m *CiscoDiscoveryValue) String() string { return proto.CompactTextString(m) }
func (*CiscoDiscoveryValue) ProtoMessage()    {}
func (*CiscoDiscoveryValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{106}
}
func (m *CiscoDiscoveryValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CiscoDiscoveryValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CiscoDiscoveryValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CiscoDiscoveryValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CiscoDiscoveryValue.Merge(m, src)
}
func (m *CiscoDiscoveryValue) XXX_Size() int {
	return m.Size()
}
func (m *CiscoDiscoveryValue) XXX_DiscardUnknown() {
	xxx_messageInfo_CiscoDiscoveryValue.DiscardUnknown(m)
}

var xxx_messageInfo_CiscoDiscoveryValue proto.InternalMessageInfo

func (m *CiscoDiscoveryValue) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *CiscoDiscoveryValue) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *CiscoDiscoveryValue) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type CDPVLANDialogue struct {
	ID   int32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	VLAN int32 `protobuf:"varint,2,opt,name=VLAN,proto3" json:"VLAN,omitempty"`
}

func (m *CDPVLANDialogue) Reset()         { *m = CDPVLANDialogue{} }
func (m *CDPVLANDialogue) String() string { return proto.CompactTextString(m) }
func (*CDPVLANDialogue) ProtoMessage()    {}
func (*CDPVLANDialogue) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{107}
}
func (m *CDPVLANDialogue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDPVLANDialogue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CDPVLANDialogue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CDPVLANDialogue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDPVLANDialogue.Merge(m, src)
}
func (m *CDPVLANDialogue) XXX_Size() int {
	return m.Size()
}
func (m *CDPVLANDialogue) XXX_DiscardUnknown() {
	xxx_messageInfo_CDPVLANDialogue.DiscardUnknown(m)
}

var xxx_messageInfo_CDPVLANDialogue proto.InternalMessageInfo

func (m *CDPVLANDialogue) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *CDPVLANDialogue) GetVLAN() int32 {
	if m != nil {
		return m.VLAN
	}
	return 0
}

type CDPLocation struct {
	Type     int32  `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Location string `protobuf:"bytes,2,opt,name=Location,proto3" json:"Location,omitempty"`
}

func (m *CDPLocation) Reset()         { *m = CDPLocation{} }
func (m *CDPLocation) String() string { return proto.CompactTextString(m) }
func (*CDPLocation) ProtoMessage()    {}
func (*CDPLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{108}
}
func (m *CDPLocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDPLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CDPLocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CDPLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDPLocation.Merge(m, src)
}
func (m *CDPLocation) XXX_Size() int {
	return m.Size()
}
func (m *CDPLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_CDPLocation.DiscardUnknown(m)
}

var xxx_messageInfo_CDPLocation proto.InternalMessageInfo

func (m *CDPLocation) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *CDPLocation) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

type CDPPowerDialogue struct {
	ID     int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	MgmtID int32    `protobuf:"varint,2,opt,name=MgmtID,proto3" json:"MgmtID,omitempty"`
	Values []uint32 `protobuf:"varint,3,rep,packed,name=Values,proto3" json:"Values,omitempty"`
}

func (m *CDPPowerDialogue) Reset()         { *m = CDPPowerDialogue{} }
func (m *CDPPowerDialogue) String() string { return proto.CompactTextString(m) }
func (*CDPPowerDialogue) ProtoMessage()    {}
func (*CDPPowerDialogue) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{109}
}
func (m *CDPPowerDialogue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDPPowerDialogue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CDPPowerDialogue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CDPPowerDialogue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDPPowerDialogue.Merge(m, src)
}
func (m *CDPPowerDialogue) XXX_Size() int {
	return m.Size()
}
func (m *CDPPowerDialogue) XXX_DiscardUnknown() {
	xxx_messageInfo_CDPPowerDialogue.DiscardUnknown(m)
}

var xxx_messageInfo_CDPPowerDialogue proto.InternalMessageInfo

func (m *CDPPowerDialogue) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *CDPPowerDialogue) GetMgmtID() int32 {
	if m != nil {
		return m.MgmtID
	}
	return 0
}

func (m *CDPPowerDialogue) GetValues() []uint32 {
	if m != nil {
		return m.Values
	}
	return nil
}

type CDPSparePairPoE struct {
	PSEFourWire  bool `protobuf:"varint,1,opt,name=PSEFourWire,proto3" json:"PSEFourWire,omitempty"`
	PDArchShared bool `protobuf:"varint,2,opt,name=PDArchShared,proto3" json:"PDArchShared,omitempty"`
	PDRequestOn  bool `protobuf:"varint,3,opt,name=PDRequestOn,proto3" json:"PDRequestOn,omitempty"`
	PSEOn        bool `protobuf:"varint,4,opt,name=PSEOn,proto3" json:"PSEOn,omitempty"`
}

func (m *CDPSparePairPoE) Reset()         { *m = CDPSparePairPoE{} }
func (m *CDPSparePairPoE) String() string { return proto.CompactTextString(m) }
func (*CDPSparePairPoE) ProtoMessage()    {}
func (*CDPSparePairPoE) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{110}
}
func (m *CDPSparePairPoE) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDPSparePairPoE) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CDPSparePairPoE.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CDPSparePairPoE) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDPSparePairPoE.Merge(m, src)
}
func (m *CDPSparePairPoE) XXX_Size() int {
	return m.Size()
}
func (m *CDPSparePairPoE) XXX_DiscardUnknown() {
	xxx_messageInfo_CDPSparePairPoE.DiscardUnknown(m)
}

var xxx_messageInfo_CDPSparePairPoE proto.InternalMessageInfo

func (m *CDPSparePairPoE) GetPSEFourWire() bool {
	if m != nil {
		return m.PSEFourWire
	}
	return false
}

func (m *CDPSparePairPoE) GetPDArchShared() bool {
	if m != nil {
		return m.PDArchShared
	}
	return false
}

func (m *CDPSparePairPoE) GetPDRequestOn() bool {
	if m != nil {
		return m.PDRequestOn
	}
	return false
}

func (m *CDPSparePairPoE) GetPSEOn() bool {
	if m != nil {
		return m.PSEOn
	}
	return false
}

type CiscoDiscoveryInfo struct {
	Timestamp        int64                  `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	CDPHello         *CDPHello              `protobuf:"bytes,2,opt,name=CDPHello,proto3" json:"CDPHello,omitempty"`
	DeviceID         string                 `protobuf:"bytes,3,opt,name=DeviceID,proto3" json:"DeviceID,omitempty"`
	Addresses        []string               `protobuf:"bytes,4,rep,name=Addresses,proto3" json:"Addresses,omitempty"`
	PortID           string                 `protobuf:"bytes,5,opt,name=PortID,proto3" json:"PortID,omitempty"`
	Capabilities     *CDPCapabilities       `protobuf:"bytes,6,opt,name=Capabilities,proto3" json:"Capabilities,omitempty"`
	Version          string                 `protobuf:"bytes,7,opt,name=Version,proto3" json:"Version,omitempty"`
	Platform         string                 `protobuf:"bytes,8,opt,name=Platform,proto3" json:"Platform,omitempty"`
	IPPrefixes       []*IPNet               `protobuf:"bytes,9,rep,name=IPPrefixes,proto3" json:"IPPrefixes,omitempty"`
	VTPDomain        string                 `protobuf:"bytes,10,opt,name=VTPDomain,proto3" json:"VTPDomain,omitempty"`
	NativeVLAN       int32                  `protobuf:"varint,11,opt,name=NativeVLAN,proto3" json:"NativeVLAN,omitempty"`
	FullDuplex       bool                   `protobuf:"varint,12,opt,name=FullDuplex,proto3" json:"FullDuplex,omitempty"`
	VLANReply        *CDPVLANDialogue       `protobuf:"bytes,13,opt,name=VLANReply,proto3" json:"VLANReply,omitempty"`
	VLANQuery        *CDPVLANDialogue       `protobuf:"bytes,14,opt,name=VLANQuery,proto3" json:"VLANQuery,omitempty"`
	PowerConsumption int32                  `protobuf:"varint,15,opt,name=PowerConsumption,proto3" json:"PowerConsumption,omitempty"`
	MTU              uint32                 `protobuf:"varint,16,opt,name=MTU,proto3" json:"MTU,omitempty"`
	ExtendedTrust    int32                  `protobuf:"varint,17,opt,name=ExtendedTrust,proto3" json:"ExtendedTrust,omitempty"`
	UntrustedCOS     int32                  `protobuf:"varint,18,opt,name=UntrustedCOS,proto3" json:"UntrustedCOS,omitempty"`
	SysName          string                 `protobuf:"bytes,19,opt,name=SysName,proto3" json:"SysName,omitempty"`
	SysOID           string                 `protobuf:"bytes,20,opt,name=SysOID,proto3" json:"SysOID,omitempty"`
	MgmtAddresses    []string               `protobuf:"bytes,21,rep,name=MgmtAddresses,proto3" json:"MgmtAddresses,omitempty"`
	Location         *CDPLocation           `protobuf:"bytes,22,opt,name=Location,proto3" json:"Location,omitempty"`
	PowerRequest     *CDPPowerDialogue      `protobuf:"bytes,23,opt,name=PowerRequest,proto3" json:"PowerRequest,omitempty"`
	PowerAvailable   *CDPPowerDialogue      `protobuf:"bytes,24,opt,name=PowerAvailable,proto3" json:"PowerAvailable,omitempty"`
	SparePairPoe     *CDPSparePairPoE       `protobuf:"bytes,25,opt,name=SparePairPoe,proto3" json:"SparePairPoe,omitempty"`
	EnergyWise       *CDPEnergyWise         `protobuf:"bytes,26,opt,name=EnergyWise,proto3" json:"EnergyWise,omitempty"`
	Unknown          []*CiscoDiscoveryValue `protobuf:"bytes,27,rep,name=Unknown,proto3" json:"Unknown,omitempty"`
}

func (m *CiscoDiscoveryInfo) Reset()         { *m = CiscoDiscoveryInfo{} }
func (m *CiscoDiscoveryInfo) String() string { return proto.CompactTextString(m) }
func (*CiscoDiscoveryInfo) ProtoMessage()    {}
func (*CiscoDiscoveryInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{111}
}
func (m *CiscoDiscoveryInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CiscoDiscoveryInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CiscoDiscoveryInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CiscoDiscoveryInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CiscoDiscoveryInfo.Merge(m, src)
}
func (m *CiscoDiscoveryInfo) XXX_Size() int {
	return m.Size()
}
func (m *CiscoDiscoveryInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CiscoDiscoveryInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CiscoDiscoveryInfo proto.InternalMessageInfo

func (m *CiscoDiscoveryInfo) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *CiscoDiscoveryInfo) GetCDPHello() *CDPHello {
	if m != nil {
		return m.CDPHello
	}
	return nil
}

func (m *CiscoDiscoveryInfo) GetDeviceID() string {
	if m != nil {
		return m.DeviceID
	}
	return ""
}

func (m *CiscoDiscoveryInfo) GetAddresses() []string {
	if m != nil {
		return m.Addresses
	}
	return nil
}

func (m *CiscoDiscoveryInfo) GetPortID() string {
	if m != nil {
		return m.PortID
	}
	return ""
}

func (m *CiscoDiscoveryInfo) GetCapabilities() *CDPCapabilities {
	if m != nil {
		return m.Capabilities
	}
	return nil
}

func (m *CiscoDiscoveryInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *CiscoDiscoveryInfo) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *CiscoDiscoveryInfo) GetIPPrefixes() []*IPNet {
	if m != nil {
		return m.IPPrefixes
	}
	return nil
}

func (m *CiscoDiscoveryInfo) GetVTPDomain() string {
	if m != nil {
		return m.VTPDomain
	}
	return ""
}

func (m *CiscoDiscoveryInfo) GetNativeVLAN() int32 {
	if m != nil {
		return m.NativeVLAN
	}
	return 0
}

func (m *CiscoDiscoveryInfo) GetFullDuplex() bool {
	if m != nil {
		return m.FullDuplex
	}
	return false
}

func (m *CiscoDiscoveryInfo) GetVLANReply() *CDPVLANDialogue {
	if m != nil {
		return m.VLANReply
	}
	return nil
}

func (m *CiscoDiscoveryInfo) GetVLANQuery() *CDPVLANDialogue {
	if m != nil {
		return m.VLANQuery
	}
	return nil
}

func (m *CiscoDiscoveryInfo) GetPowerConsumption() int32 {
	if m != nil {
		return m.PowerConsumption
	}
	return 0
}

func (m *CiscoDiscoveryInfo) GetMTU() uint32 {
	if m != nil {
		return m.MTU
	}
	return 0
}

func (m *CiscoDiscoveryInfo) GetExtendedTrust() int32 {
	if m != nil {
		return m.ExtendedTrust
	}
	return 0
}

func (m *CiscoDiscoveryInfo) GetUntrustedCOS() int32 {
	if m != nil {
		return m.UntrustedCOS
	}
	return 0
}

func (m *CiscoDiscoveryInfo) GetSysName() string {
	if m != nil {
		return m.SysName
	}
	return ""
}

func (m *CiscoDiscoveryInfo) GetSysOID() string {
	if m != nil {
		return m.SysOID
	}
	return ""
}

func (m *CiscoDiscoveryInfo) GetMgmtAddresses() []string {
	if m != nil {
		return m.MgmtAddresses
	}
	return nil
}

func (m *CiscoDiscoveryInfo) GetLocation() *CDPLocation {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *CiscoDiscoveryInfo) GetPowerRequest() *CDPPowerDialogue {
	if m != nil {
		return m.PowerRequest
	}
	return nil
}

func (m *CiscoDiscoveryInfo) GetPowerAvailable() *CDPPowerDialogue {
	if m != nil {
		return m.PowerAvailable
	}
	return nil
}

func (m *CiscoDiscoveryInfo) GetSparePairPoe() *CDPSparePairPoE {
	if m != nil {
		return m.SparePairPoe
	}
	return nil
}

func (m *CiscoDiscoveryInfo) GetEnergyWise() *CDPEnergyWise {
	if m != nil {
		return m.EnergyWise
	}
	return nil
}

func (m *CiscoDiscoveryInfo) GetUnknown() []*CiscoDiscoveryValue {
	if m != nil {
		return m.Unknown
	}
	return nil
}

type CDPHello struct {
	OUI              []byte `protobuf:"bytes,1,opt,name=OUI,proto3" json:"OUI,omitempty"`
	ProtocolID       int32  `protobuf:"varint,2,opt,name=ProtocolID,proto3" json:"ProtocolID,omitempty"`
	ClusterMaster    string `protobuf:"bytes,3,opt,name=ClusterMaster,proto3" json:"ClusterMaster,omitempty"`
	Unknown1         string `protobuf:"bytes,4,opt,name=Unknown1,proto3" json:"Unknown1,omitempty"`
	Version          int32  `protobuf:"varint,5,opt,name=Version,proto3" json:"Version,omitempty"`
	SubVersion       int32  `protobuf:"varint,6,opt,name=SubVersion,proto3" json:"SubVersion,omitempty"`
	Status           int32  `protobuf:"varint,7,opt,name=Status,proto3" json:"Status,omitempty"`
	Unknown2         int32  `protobuf:"varint,8,opt,name=Unknown2,proto3" json:"Unknown2,omitempty"`
	ClusterCommander string `protobuf:"bytes,9,opt,name=ClusterCommander,proto3" json:"ClusterCommander,omitempty"`
	SwitchMAC        string `protobuf:"bytes,10,opt,name=SwitchMAC,proto3" json:"SwitchMAC,omitempty"`
	Unknown3         int32  `protobuf:"varint,11,opt,name=Unknown3,proto3" json:"Unknown3,omitempty"`
	ManagementVLAN   int32  `protobuf:"varint,12,opt,name=ManagementVLAN,proto3" json:"ManagementVLAN,omitempty"`
}

func (m *CDPHello) Reset()         { *m = CDPHello{} }
func (m *CDPHello) String() string { return proto.CompactTextString(m) }
func (*CDPHello) ProtoMessage()    {}
func (*CDPHello) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{112}
}
func (m *CDPHello) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDPHello) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CDPHello.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CDPHello) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDPHello.Merge(m, src)
}
func (m *CDPHello) XXX_Size() int {
	return m.Size()
}
func (m *CDPHello) XXX_DiscardUnknown() {
	xxx_messageInfo_CDPHello.DiscardUnknown(m)
}

var xxx_messageInfo_CDPHello proto.InternalMessageInfo

func (m *CDPHello) GetOUI() []byte {
	if m != nil {
		return m.OUI
	}
	return nil
}

func (m *CDPHello) GetProtocolID() int32 {
	if m != nil {
		return m.ProtocolID
	}
	return 0
}

func (m *CDPHello) GetClusterMaster() string {
	if m != nil {
		return m.ClusterMaster
	}
	return ""
}

func (m *CDPHello) GetUnknown1() string {
	if m != nil {
		return m.Unknown1
	}
	return ""
}

func (m *CDPHello) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *CDPHello) GetSubVersion() int32 {
	if m != nil {
		return m.SubVersion
	}
	return 0
}

func (m *CDPHello) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *CDPHello) GetUnknown2() int32 {
	if m != nil {
		return m.Unknown2
	}
	return 0
}

func (m *CDPHello) GetClusterCommander() string {
	if m != nil {
		return m.ClusterCommander
	}
	return ""
}

func (m *CDPHello) GetSwitchMAC() string {
	if m != nil {
		return m.SwitchMAC
	}
	return ""
}

func (m *CDPHello) GetUnknown3() int32 {
	if m != nil {
		return m.Unknown3
	}
	return 0
}

func (m *CDPHello) GetManagementVLAN() int32 {
	if m != nil {
		return m.ManagementVLAN
	}
	return 0
}

type CDPEnergyWise struct {
	EncryptedData  []byte `protobuf:"bytes,1,opt,name=EncryptedData,proto3" json:"EncryptedData,omitempty"`
	Unknown1       uint32 `protobuf:"varint,2,opt,name=Unknown1,proto3" json:"Unknown1,omitempty"`
	SequenceNumber uint32 `protobuf:"varint,3,opt,name=SequenceNumber,proto3" json:"SequenceNumber,omitempty"`
	ModelNumber    string `protobuf:"bytes,4,opt,name=ModelNumber,proto3" json:"ModelNumber,omitempty"`
	Unknown2       int32  `protobuf:"varint,5,opt,name=Unknown2,proto3" json:"Unknown2,omitempty"`
	HardwareID     string `protobuf:"bytes,6,opt,name=HardwareID,proto3" json:"HardwareID,omitempty"`
	SerialNum      string `protobuf:"bytes,7,opt,name=SerialNum,proto3" json:"SerialNum,omitempty"`
	Unknown3       []byte `protobuf:"bytes,8,opt,name=Unknown3,proto3" json:"Unknown3,omitempty"`
	Role           string `protobuf:"bytes,9,opt,name=Role,proto3" json:"Role,omitempty"`
	Domain         string `protobuf:"bytes,10,opt,name=Domain,proto3" json:"Domain,omitempty"`
	Name           string `protobuf:"bytes,11,opt,name=Name,proto3" json:"Name,omitempty"`
	ReplyUnknown1  []byte `protobuf:"bytes,12,opt,name=ReplyUnknown1,proto3" json:"ReplyUnknown1,omitempty"`
	ReplyPort      []byte `protobuf:"bytes,13,opt,name=ReplyPort,proto3" json:"ReplyPort,omitempty"`
	ReplyAddress   []byte `protobuf:"bytes,14,opt,name=ReplyAddress,proto3" json:"ReplyAddress,omitempty"`
	ReplyUnknown2  []byte `protobuf:"bytes,15,opt,name=ReplyUnknown2,proto3" json:"ReplyUnknown2,omitempty"`
	ReplyUnknown3  []byte `protobuf:"bytes,16,opt,name=ReplyUnknown3,proto3" json:"ReplyUnknown3,omitempty"`
}

func (m *CDPEnergyWise) Reset()         { *m = CDPEnergyWise{} }
func (m *CDPEnergyWise) String() string { return proto.CompactTextString(m) }
func (*CDPEnergyWise) ProtoMessage()    {}
func (*CDPEnergyWise) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{113}
}
func (m *CDPEnergyWise) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDPEnergyWise) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CDPEnergyWise.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CDPEnergyWise) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDPEnergyWise.Merge(m, src)
}
func (m *CDPEnergyWise) XXX_Size() int {
	return m.Size()
}
func (m *CDPEnergyWise) XXX_DiscardUnknown() {
	xxx_messageInfo_CDPEnergyWise.DiscardUnknown(m)
}

var xxx_messageInfo_CDPEnergyWise proto.InternalMessageInfo

func (m *CDPEnergyWise) GetEncryptedData() []byte {
	if m != nil {
		return m.EncryptedData
	}
	return nil
}

func (m *CDPEnergyWise) GetUnknown1() uint32 {
	if m != nil {
		return m.Unknown1
	}
	return 0
}

func (m *CDPEnergyWise) GetSequenceNumber() uint32 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *CDPEnergyWise) GetModelNumber() string {
	if m != nil {
		return m.ModelNumber
	}
	return ""
}

func (m *CDPEnergyWise) GetUnknown2() int32 {
	if m != nil {
		return m.Unknown2
	}
	return 0
}

func (m *CDPEnergyWise) GetHardwareID() string {
	if m != nil {
		return m.HardwareID
	}
	return ""
}

func (m *CDPEnergyWise) GetSerialNum() string {
	if m != nil {
		return m.SerialNum
	}
	return ""
}

func (m *CDPEnergyWise) GetUnknown3() []byte {
	if m != nil {
		return m.Unknown3
	}
	return nil
}

func (m *CDPEnergyWise) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *CDPEnergyWise) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *CDPEnergyWise) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CDPEnergyWise) GetReplyUnknown1() []byte {
	if m != nil {
		return m.ReplyUnknown1
	}
	return nil
}

func (m *CDPEnergyWise) GetReplyPort() []byte {
	if m != nil {
		return m.ReplyPort
	}
	return nil
}

func (m *CDPEnergyWise) GetReplyAddress() []byte {
	if m != nil {
		return m.ReplyAddress
	}
	return nil
}

func (m *CDPEnergyWise) GetReplyUnknown2() []byte {
	if m != nil {
		return m.ReplyUnknown2
	}
	return nil
}

func (m *CDPEnergyWise) GetReplyUnknown3() []byte {
	if m != nil {
		return m.ReplyUnknown3
	}
	return nil
}

type CDPCapabilities struct {
	L3Router        bool `protobuf:"varint,1,opt,name=L3Router,proto3" json:"L3Router,omitempty"`
	TBBridge        bool `protobuf:"varint,2,opt,name=TBBridge,proto3" json:"TBBridge,omitempty"`
	SPBridge        bool `protobuf:"varint,3,opt,name=SPBridge,proto3" json:"SPBridge,omitempty"`
	L2Switch        bool `protobuf:"varint,4,opt,name=L2Switch,proto3" json:"L2Switch,omitempty"`
	IsHost          bool `protobuf:"varint,5,opt,name=IsHost,proto3" json:"IsHost,omitempty"`
	IGMPFilter      bool `protobuf:"varint,6,opt,name=IGMPFilter,proto3" json:"IGMPFilter,omitempty"`
	L1Repeater      bool `protobuf:"varint,7,opt,name=L1Repeater,proto3" json:"L1Repeater,omitempty"`
	IsPhone         bool `protobuf:"varint,8,opt,name=IsPhone,proto3" json:"IsPhone,omitempty"`
	RemotelyManaged bool `protobuf:"varint,9,opt,name=RemotelyManaged,proto3" json:"RemotelyManaged,omitempty"`
}

func (m *CDPCapabilities) Reset()         { *m = CDPCapabilities{} }
func (m *CDPCapabilities) String() string { return proto.CompactTextString(m) }
func (*CDPCapabilities) ProtoMessage()    {}
func (*CDPCapabilities) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{114}
}
func (m *CDPCapabilities) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDPCapabilities) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CDPCapabilities.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CDPCapabilities) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDPCapabilities.Merge(m, src)
}
func (m *CDPCapabilities) XXX_Size() int {
	return m.Size()
}
func (m *CDPCapabilities) XXX_DiscardUnknown() {
	xxx_messageInfo_CDPCapabilities.DiscardUnknown(m)
}

var xxx_messageInfo_CDPCapabilities proto.InternalMessageInfo

func (m *CDPCapabilities) GetL3Router() bool {
	if m != nil {
		return m.L3Router
	}
	return false
}

func (m *CDPCapabilities) GetTBBridge() bool {
	if m != nil {
		return m.TBBridge
	}
	return false
}

func (m *CDPCapabilities) GetSPBridge() bool {
	if m != nil {
		return m.SPBridge
	}
	return false
}

func (m *CDPCapabilities) GetL2Switch() bool {
	if m != nil {
		return m.L2Switch
	}
	return false
}

func (m *CDPCapabilities) GetIsHost() bool {
	if m != nil {
		return m.IsHost
	}
	return false
}

func (m *CDPCapabilities) GetIGMPFilter() bool {
	if m != nil {
		return m.IGMPFilter
	}
	return false
}

func (m *CDPCapabilities) GetL1Repeater() bool {
	if m != nil {
		return m.L1Repeater
	}
	return false
}

func (m *CDPCapabilities) GetIsPhone() bool {
	if m != nil {
		return m.IsPhone
	}
	return false
}

func (m *CDPCapabilities) GetRemotelyManaged() bool {
	if m != nil {
		return m.RemotelyManaged
	}
	return false
}

type IPNet struct {
	IP     string `protobuf:"bytes,1,opt,name=IP,proto3" json:"IP,omitempty"`
	IPMask string `protobuf:"bytes,2,opt,name=IPMask,proto3" json:"IPMask,omitempty"`
}

func (m *IPNet) Reset()         { *m = IPNet{} }
func (m *IPNet) String() string { return proto.CompactTextString(m) }
func (*IPNet) ProtoMessage()    {}
func (*IPNet) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{115}
}
func (m *IPNet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPNet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPNet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPNet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPNet.Merge(m, src)
}
func (m *IPNet) XXX_Size() int {
	return m.Size()
}
func (m *IPNet) XXX_DiscardUnknown() {
	xxx_messageInfo_IPNet.DiscardUnknown(m)
}

var xxx_messageInfo_IPNet proto.InternalMessageInfo

func (m *IPNet) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

func (m *IPNet) GetIPMask() string {
	if m != nil {
		return m.IPMask
	}
	return ""
}

// The Nortel Discovery Protocol (NDP) is a Data Link Layer (OSI Layer 2) network protocol for discovery of Nortel networking devices and certain products from Avaya and Ciena.
// The device and topology information may be graphically displayed network management software.
type NortelDiscovery struct {
	Timestamp int64  `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	IPAddress string `protobuf:"bytes,2,opt,name=IPAddress,proto3" json:"IPAddress,omitempty"`
	SegmentID []byte `protobuf:"bytes,3,opt,name=SegmentID,proto3" json:"SegmentID,omitempty"`
	Chassis   int32  `protobuf:"varint,4,opt,name=Chassis,proto3" json:"Chassis,omitempty"`
	Backplane int32  `protobuf:"varint,5,opt,name=Backplane,proto3" json:"Backplane,omitempty"`
	State     int32  `protobuf:"varint,6,opt,name=State,proto3" json:"State,omitempty"`
	NumLinks  int32  `protobuf:"varint,7,opt,name=NumLinks,proto3" json:"NumLinks,omitempty"`
	SrcMac    string `protobuf:"bytes,8,opt,name=SrcMac,proto3" json:"SrcMac,omitempty"`
	DstMac    string `protobuf:"bytes,9,opt,name=DstMac,proto3" json:"DstMac,omitempty"`
}

func (m *NortelDiscovery) Reset()         { *m = NortelDiscovery{} }
func (m *NortelDiscovery) String() string { return proto.CompactTextString(m) }
func (*NortelDiscovery) ProtoMessage()    {}
func (*NortelDiscovery) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{116}
}
func (m *NortelDiscovery) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NortelDiscovery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NortelDiscovery.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NortelDiscovery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NortelDiscovery.Merge(m, src)
}
func (m *NortelDiscovery) XXX_Size() int {
	return m.Size()
}
func (m *NortelDiscovery) XXX_DiscardUnknown() {
	xxx_messageInfo_NortelDiscovery.DiscardUnknown(m)
}

var xxx_messageInfo_NortelDiscovery proto.InternalMessageInfo

func (m *NortelDiscovery) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *NortelDiscovery) GetIPAddress() string {
	if m != nil {
		return m.IPAddress
	}
	return ""
}

func (m *NortelDiscovery) GetSegmentID() []byte {
	if m != nil {
		return m.SegmentID
	}
	return nil
}

func (m *NortelDiscovery) GetChassis() int32 {
	if m != nil {
		return m.Chassis
	}
	return 0
}

func (m *NortelDiscovery) GetBackplane() int32 {
	if m != nil {
		return m.Backplane
	}
	return 0
}

func (m *NortelDiscovery) GetState() int32 {
	if m != nil {
		return m.State
	}
	return 0
}

func (m *NortelDiscovery) GetNumLinks() int32 {
	if m != nil {
		return m.NumLinks
	}
	return 0
}

func (m *NortelDiscovery) GetSrcMac() string {
	if m != nil {
		return m.SrcMac
	}
	return ""
}

func (m *NortelDiscovery) GetDstMac() string {
	if m != nil {
		return m.DstMac
	}
	return ""
}

// The Common Industrial Protocol (CIP) is an industrial protocol for industrial automation applications.
// CIP encompasses a comprehensive suite of messages and services for the collection of manufacturing
// automation applications  control, safety, synchronization, motion, configuration and information.
// It allows users to integrate these manufacturing applications with enterprise-level Ethernet networks and the Internet.
type CIP struct {
	Timestamp        int64    `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Response         bool     `protobuf:"varint,2,opt,name=Response,proto3" json:"Response,omitempty"`
	ServiceID        int32    `protobuf:"varint,3,opt,name=ServiceID,proto3" json:"ServiceID,omitempty"`
	ClassID          uint32   `protobuf:"varint,4,opt,name=ClassID,proto3" json:"ClassID,omitempty"`
	InstanceID       uint32   `protobuf:"varint,5,opt,name=InstanceID,proto3" json:"InstanceID,omitempty"`
	Status           int32    `protobuf:"varint,6,opt,name=Status,proto3" json:"Status,omitempty"`
	AdditionalStatus []uint32 `protobuf:"varint,7,rep,packed,name=AdditionalStatus,proto3" json:"AdditionalStatus,omitempty"`
	Data             []byte   `protobuf:"bytes,8,opt,name=Data,proto3" json:"Data,omitempty"`
	SrcIP            string   `protobuf:"bytes,9,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP            string   `protobuf:"bytes,10,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
	SrcPort          int32    `protobuf:"varint,11,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	DstPort          int32    `protobuf:"varint,12,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
}

func (m *CIP) Reset()         { *m = CIP{} }
func (m *CIP) String() string { return proto.CompactTextString(m) }
func (*CIP) ProtoMessage()    {}
func (*CIP) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{117}
}
func (m *CIP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CIP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CIP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CIP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CIP.Merge(m, src)
}
func (m *CIP) XXX_Size() int {
	return m.Size()
}
func (m *CIP) XXX_DiscardUnknown() {
	xxx_messageInfo_CIP.DiscardUnknown(m)
}

var xxx_messageInfo_CIP proto.InternalMessageInfo

func (m *CIP) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *CIP) GetResponse() bool {
	if m != nil {
		return m.Response
	}
	return false
}

func (m *CIP) GetServiceID() int32 {
	if m != nil {
		return m.ServiceID
	}
	return 0
}

func (m *CIP) GetClassID() uint32 {
	if m != nil {
		return m.ClassID
	}
	return 0
}

func (m *CIP) GetInstanceID() uint32 {
	if m != nil {
		return m.InstanceID
	}
	return 0
}

func (m *CIP) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *CIP) GetAdditionalStatus() []uint32 {
	if m != nil {
		return m.AdditionalStatus
	}
	return nil
}

func (m *CIP) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *CIP) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *CIP) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

func (m *CIP) GetSrcPort() int32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *CIP) GetDstPort() int32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

// ENIP implements decoding of EtherNet/IP, a protocol used to transport the
// Common Industrial Protocol over standard OSI networks. EtherNet/IP transports
// over both TCP and UDP.
// See the EtherNet/IP Developer's Guide for more information: https://www.odva.org/Portals/0/Library/Publications_Numbered/PUB00213R0_EtherNetIP_Developers_Guide.pdf
type ENIP struct {
	Timestamp       int64                    `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Command         uint32                   `protobuf:"varint,2,opt,name=Command,proto3" json:"Command,omitempty"`
	Length          uint32                   `protobuf:"varint,3,opt,name=Length,proto3" json:"Length,omitempty"`
	SessionHandle   uint32                   `protobuf:"varint,4,opt,name=SessionHandle,proto3" json:"SessionHandle,omitempty"`
	Status          uint32                   `protobuf:"varint,5,opt,name=Status,proto3" json:"Status,omitempty"`
	SenderContext   []byte                   `protobuf:"bytes,6,opt,name=SenderContext,proto3" json:"SenderContext,omitempty"`
	Options         uint32                   `protobuf:"varint,7,opt,name=Options,proto3" json:"Options,omitempty"`
	CommandSpecific *ENIPCommandSpecificData `protobuf:"bytes,8,opt,name=CommandSpecific,proto3" json:"CommandSpecific,omitempty"`
	SrcIP           string                   `protobuf:"bytes,9,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP           string                   `protobuf:"bytes,10,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
	SrcPort         int32                    `protobuf:"varint,11,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	DstPort         int32                    `protobuf:"varint,12,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
}

func (m *ENIP) Reset()         { *m = ENIP{} }
func (m *ENIP) String() string { return proto.CompactTextString(m) }
func (*ENIP) ProtoMessage()    {}
func (*ENIP) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{118}
}
func (m *ENIP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ENIP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ENIP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ENIP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ENIP.Merge(m, src)
}
func (m *ENIP) XXX_Size() int {
	return m.Size()
}
func (m *ENIP) XXX_DiscardUnknown() {
	xxx_messageInfo_ENIP.DiscardUnknown(m)
}

var xxx_messageInfo_ENIP proto.InternalMessageInfo

func (m *ENIP) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *ENIP) GetCommand() uint32 {
	if m != nil {
		return m.Command
	}
	return 0
}

func (m *ENIP) GetLength() uint32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *ENIP) GetSessionHandle() uint32 {
	if m != nil {
		return m.SessionHandle
	}
	return 0
}

func (m *ENIP) GetStatus() uint32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *ENIP) GetSenderContext() []byte {
	if m != nil {
		return m.SenderContext
	}
	return nil
}

func (m *ENIP) GetOptions() uint32 {
	if m != nil {
		return m.Options
	}
	return 0
}

func (m *ENIP) GetCommandSpecific() *ENIPCommandSpecificData {
	if m != nil {
		return m.CommandSpecific
	}
	return nil
}

func (m *ENIP) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *ENIP) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

func (m *ENIP) GetSrcPort() int32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *ENIP) GetDstPort() int32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

// ENIPCommandSpecificData contains data specific to a command. This may
// include another EtherNet/IP packet embedded within the Data structure.
type ENIPCommandSpecificData struct {
	Cmd  uint32 `protobuf:"varint,1,opt,name=Cmd,proto3" json:"Cmd,omitempty"`
	Data []byte `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *ENIPCommandSpecificData) Reset()         { *m = ENIPCommandSpecificData{} }
func (m *ENIPCommandSpecificData) String() string { return proto.CompactTextString(m) }
func (*ENIPCommandSpecificData) ProtoMessage()    {}
func (*ENIPCommandSpecificData) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{119}
}
func (m *ENIPCommandSpecificData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ENIPCommandSpecificData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ENIPCommandSpecificData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ENIPCommandSpecificData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ENIPCommandSpecificData.Merge(m, src)
}
func (m *ENIPCommandSpecificData) XXX_Size() int {
	return m.Size()
}
func (m *ENIPCommandSpecificData) XXX_DiscardUnknown() {
	xxx_messageInfo_ENIPCommandSpecificData.DiscardUnknown(m)
}

var xxx_messageInfo_ENIPCommandSpecificData proto.InternalMessageInfo

func (m *ENIPCommandSpecificData) GetCmd() uint32 {
	if m != nil {
		return m.Cmd
	}
	return 0
}

func (m *ENIPCommandSpecificData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// Device Profiling
type DeviceProfile struct {
	MacAddr            string   `protobuf:"bytes,1,opt,name=MacAddr,proto3" json:"MacAddr,omitempty"`
	DeviceManufacturer string   `protobuf:"bytes,2,opt,name=DeviceManufacturer,proto3" json:"DeviceManufacturer,omitempty"`
	DeviceIPs          []string `protobuf:"bytes,3,rep,name=DeviceIPs,proto3" json:"DeviceIPs,omitempty"`
	Contacts           []string `protobuf:"bytes,4,rep,name=Contacts,proto3" json:"Contacts,omitempty"`
	NumPackets         int64    `protobuf:"varint,5,opt,name=NumPackets,proto3" json:"NumPackets,omitempty"`
	Timestamp          int64    `protobuf:"varint,6,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Bytes              uint64   `protobuf:"varint,7,opt,name=Bytes,proto3" json:"Bytes,omitempty"`
}

func (m *DeviceProfile) Reset()         { *m = DeviceProfile{} }
func (m *DeviceProfile) String() string { return proto.CompactTextString(m) }
func (*DeviceProfile) ProtoMessage()    {}
func (*DeviceProfile) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{120}
}
func (m *DeviceProfile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceProfile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceProfile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceProfile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceProfile.Merge(m, src)
}
func (m *DeviceProfile) XXX_Size() int {
	return m.Size()
}
func (m *DeviceProfile) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceProfile.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceProfile proto.InternalMessageInfo

func (m *DeviceProfile) GetMacAddr() string {
	if m != nil {
		return m.MacAddr
	}
	return ""
}

func (m *DeviceProfile) GetDeviceManufacturer() string {
	if m != nil {
		return m.DeviceManufacturer
	}
	return ""
}

func (m *DeviceProfile) GetDeviceIPs() []string {
	if m != nil {
		return m.DeviceIPs
	}
	return nil
}

func (m *DeviceProfile) GetContacts() []string {
	if m != nil {
		return m.Contacts
	}
	return nil
}

func (m *DeviceProfile) GetNumPackets() int64 {
	if m != nil {
		return m.NumPackets
	}
	return 0
}

func (m *DeviceProfile) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *DeviceProfile) GetBytes() uint64 {
	if m != nil {
		return m.Bytes
	}
	return 0
}

// Port models a transport layer port and basic stats such as the number of packets, bytes transferred and protocol type.
type Port struct {
	PortNumber int32      `protobuf:"varint,1,opt,name=PortNumber,proto3" json:"PortNumber,omitempty"`
	Protocol   string     `protobuf:"bytes,2,opt,name=Protocol,proto3" json:"Protocol,omitempty"`
	Stats      *PortStats `protobuf:"bytes,3,opt,name=Stats,proto3" json:"Stats,omitempty"`
}

func (m *Port) Reset()         { *m = Port{} }
func (m *Port) String() string { return proto.CompactTextString(m) }
func (*Port) ProtoMessage()    {}
func (*Port) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{121}
}
func (m *Port) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Port) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Port.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Port) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Port.Merge(m, src)
}
func (m *Port) XXX_Size() int {
	return m.Size()
}
func (m *Port) XXX_DiscardUnknown() {
	xxx_messageInfo_Port.DiscardUnknown(m)
}

var xxx_messageInfo_Port proto.InternalMessageInfo

func (m *Port) GetPortNumber() int32 {
	if m != nil {
		return m.PortNumber
	}
	return 0
}

func (m *Port) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *Port) GetStats() *PortStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// Workaround for Go issue with ARM:
// On both ARM and x86-32, it is the caller's responsibility to arrange for 64-bit alignment of 64-bit words accessed atomically.
// The first word in a variable or in an allocated struct, array, or slice can be relied upon to be 64-bit aligned.
// Since we currently dont have control over the generated field order, lets move the counters that are accessed atomically into a dedicated structure
type PortStats struct {
	Packets uint64 `protobuf:"varint,1,opt,name=Packets,proto3" json:"Packets,omitempty"`
	Bytes   uint64 `protobuf:"varint,2,opt,name=Bytes,proto3" json:"Bytes,omitempty"`
}

func (m *PortStats) Reset()         { *m = PortStats{} }
func (m *PortStats) String() string { return proto.CompactTextString(m) }
func (*PortStats) ProtoMessage()    {}
func (*PortStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{122}
}
func (m *PortStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PortStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PortStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortStats.Merge(m, src)
}
func (m *PortStats) XXX_Size() int {
	return m.Size()
}
func (m *PortStats) XXX_DiscardUnknown() {
	xxx_messageInfo_PortStats.DiscardUnknown(m)
}

var xxx_messageInfo_PortStats proto.InternalMessageInfo

func (m *PortStats) GetPackets() uint64 {
	if m != nil {
		return m.Packets
	}
	return 0
}

func (m *PortStats) GetBytes() uint64 {
	if m != nil {
		return m.Bytes
	}
	return 0
}

type IPProfile struct {
	Addr           string               `protobuf:"bytes,1,opt,name=Addr,proto3" json:"Addr,omitempty"`
	NumPackets     int64                `protobuf:"varint,2,opt,name=NumPackets,proto3" json:"NumPackets,omitempty"`
	Geolocation    string               `protobuf:"bytes,3,opt,name=Geolocation,proto3" json:"Geolocation,omitempty"`
	DNSNames       []string             `protobuf:"bytes,4,rep,name=DNSNames,proto3" json:"DNSNames,omitempty"`
	TimestampFirst int64                `protobuf:"varint,5,opt,name=TimestampFirst,proto3" json:"TimestampFirst,omitempty"`
	TimestampLast  int64                `protobuf:"varint,6,opt,name=TimestampLast,proto3" json:"TimestampLast,omitempty"`
	Applications   []string             `protobuf:"bytes,7,rep,name=Applications,proto3" json:"Applications,omitempty"`
	Ja3Hashes      map[string]string    `protobuf:"bytes,8,rep,name=Ja3Hashes,proto3" json:"Ja3Hashes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Protocols      map[string]*Protocol `protobuf:"bytes,9,rep,name=Protocols,proto3" json:"Protocols,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Bytes          uint64               `protobuf:"varint,10,opt,name=Bytes,proto3" json:"Bytes,omitempty"`
	SNIs           map[string]int64     `protobuf:"bytes,11,rep,name=SNIs,proto3" json:"SNIs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	SrcPorts       []*Port              `protobuf:"bytes,12,rep,name=SrcPorts,proto3" json:"SrcPorts,omitempty"`
	DstPorts       []*Port              `protobuf:"bytes,13,rep,name=DstPorts,proto3" json:"DstPorts,omitempty"`
	ContactedPorts []*Port              `protobuf:"bytes,14,rep,name=ContactedPorts,proto3" json:"ContactedPorts,omitempty"`
}

func (m *IPProfile) Reset()         { *m = IPProfile{} }
func (m *IPProfile) String() string { return proto.CompactTextString(m) }
func (*IPProfile) ProtoMessage()    {}
func (*IPProfile) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{123}
}
func (m *IPProfile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPProfile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPProfile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPProfile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPProfile.Merge(m, src)
}
func (m *IPProfile) XXX_Size() int {
	return m.Size()
}
func (m *IPProfile) XXX_DiscardUnknown() {
	xxx_messageInfo_IPProfile.DiscardUnknown(m)
}

var xxx_messageInfo_IPProfile proto.InternalMessageInfo

func (m *IPProfile) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *IPProfile) GetNumPackets() int64 {
	if m != nil {
		return m.NumPackets
	}
	return 0
}

func (m *IPProfile) GetGeolocation() string {
	if m != nil {
		return m.Geolocation
	}
	return ""
}

func (m *IPProfile) GetDNSNames() []string {
	if m != nil {
		return m.DNSNames
	}
	return nil
}

func (m *IPProfile) GetTimestampFirst() int64 {
	if m != nil {
		return m.TimestampFirst
	}
	return 0
}

func (m *IPProfile) GetTimestampLast() int64 {
	if m != nil {
		return m.TimestampLast
	}
	return 0
}

func (m *IPProfile) GetApplications() []string {
	if m != nil {
		return m.Applications
	}
	return nil
}

func (m *IPProfile) GetJa3Hashes() map[string]string {
	if m != nil {
		return m.Ja3Hashes
	}
	return nil
}

func (m *IPProfile) GetProtocols() map[string]*Protocol {
	if m != nil {
		return m.Protocols
	}
	return nil
}

func (m *IPProfile) GetBytes() uint64 {
	if m != nil {
		return m.Bytes
	}
	return 0
}

func (m *IPProfile) GetSNIs() map[string]int64 {
	if m != nil {
		return m.SNIs
	}
	return nil
}

func (m *IPProfile) GetSrcPorts() []*Port {
	if m != nil {
		return m.SrcPorts
	}
	return nil
}

func (m *IPProfile) GetDstPorts() []*Port {
	if m != nil {
		return m.DstPorts
	}
	return nil
}

func (m *IPProfile) GetContactedPorts() []*Port {
	if m != nil {
		return m.ContactedPorts
	}
	return nil
}

type Protocol struct {
	Packets  uint64 `protobuf:"varint,1,opt,name=Packets,proto3" json:"Packets,omitempty"`
	Category string `protobuf:"bytes,2,opt,name=Category,proto3" json:"Category,omitempty"`
}

func (m *Protocol) Reset()         { *m = Protocol{} }
func (m *Protocol) String() string { return proto.CompactTextString(m) }
func (*Protocol) ProtoMessage()    {}
func (*Protocol) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{124}
}
func (m *Protocol) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Protocol) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Protocol.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Protocol) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Protocol.Merge(m, src)
}
func (m *Protocol) XXX_Size() int {
	return m.Size()
}
func (m *Protocol) XXX_DiscardUnknown() {
	xxx_messageInfo_Protocol.DiscardUnknown(m)
}

var xxx_messageInfo_Protocol proto.InternalMessageInfo

func (m *Protocol) GetPackets() uint64 {
	if m != nil {
		return m.Packets
	}
	return 0
}

func (m *Protocol) GetCategory() string {
	if m != nil {
		return m.Category
	}
	return ""
}

type File struct {
	Timestamp           int64  `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Name                string `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	Length              int64  `protobuf:"varint,3,opt,name=Length,proto3" json:"Length,omitempty"`
	Hash                string `protobuf:"bytes,4,opt,name=Hash,proto3" json:"Hash,omitempty"`
	Location            string `protobuf:"bytes,5,opt,name=Location,proto3" json:"Location,omitempty"`
	Ident               string `protobuf:"bytes,6,opt,name=Ident,proto3" json:"Ident,omitempty"`
	Source              string `protobuf:"bytes,7,opt,name=Source,proto3" json:"Source,omitempty"`
	ContentType         string `protobuf:"bytes,8,opt,name=ContentType,proto3" json:"ContentType,omitempty"`
	Host                string `protobuf:"bytes,9,opt,name=Host,proto3" json:"Host,omitempty"`
	ContentTypeDetected string `protobuf:"bytes,10,opt,name=ContentTypeDetected,proto3" json:"ContentTypeDetected,omitempty"`
	SrcIP               string `protobuf:"bytes,11,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP               string `protobuf:"bytes,12,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
	SrcPort             int32  `protobuf:"varint,13,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	DstPort             int32  `protobuf:"varint,14,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
}

func (m *File) Reset()         { *m = File{} }
func (m *File) String() string { return proto.CompactTextString(m) }
func (*File) ProtoMessage()    {}
func (*File) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{125}
}
func (m *File) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *File) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_File.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *File) XXX_Merge(src proto.Message) {
	xxx_messageInfo_File.Merge(m, src)
}
func (m *File) XXX_Size() int {
	return m.Size()
}
func (m *File) XXX_DiscardUnknown() {
	xxx_messageInfo_File.DiscardUnknown(m)
}

var xxx_messageInfo_File proto.InternalMessageInfo

func (m *File) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *File) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *File) GetLength() int64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *File) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *File) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *File) GetIdent() string {
	if m != nil {
		return m.Ident
	}
	return ""
}

func (m *File) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *File) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

func (m *File) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *File) GetContentTypeDetected() string {
	if m != nil {
		return m.ContentTypeDetected
	}
	return ""
}

func (m *File) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *File) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

func (m *File) GetSrcPort() int32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *File) GetDstPort() int32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

// SMTPResponse SMTP response type
// with status code and parameter
type SMTPResponse struct {
	ResponseCode int32  `protobuf:"varint,1,opt,name=ResponseCode,proto3" json:"ResponseCode,omitempty"`
	Parameter    string `protobuf:"bytes,2,opt,name=Parameter,proto3" json:"Parameter,omitempty"`
	Data         string `protobuf:"bytes,3,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *SMTPResponse) Reset()         { *m = SMTPResponse{} }
func (m *SMTPResponse) String() string { return proto.CompactTextString(m) }
func (*SMTPResponse) ProtoMessage()    {}
func (*SMTPResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{126}
}
func (m *SMTPResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SMTPResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SMTPResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SMTPResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SMTPResponse.Merge(m, src)
}
func (m *SMTPResponse) XXX_Size() int {
	return m.Size()
}
func (m *SMTPResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SMTPResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SMTPResponse proto.InternalMessageInfo

func (m *SMTPResponse) GetResponseCode() int32 {
	if m != nil {
		return m.ResponseCode
	}
	return 0
}

func (m *SMTPResponse) GetParameter() string {
	if m != nil {
		return m.Parameter
	}
	return ""
}

func (m *SMTPResponse) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

// SMTPRequest
type SMTPRequest struct {
	Command  string `protobuf:"bytes,1,opt,name=Command,proto3" json:"Command,omitempty"`
	Argument string `protobuf:"bytes,2,opt,name=Argument,proto3" json:"Argument,omitempty"`
	Data     string `protobuf:"bytes,3,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *SMTPRequest) Reset()         { *m = SMTPRequest{} }
func (m *SMTPRequest) String() string { return proto.CompactTextString(m) }
func (*SMTPRequest) ProtoMessage()    {}
func (*SMTPRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{127}
}
func (m *SMTPRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SMTPRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SMTPRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SMTPRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SMTPRequest.Merge(m, src)
}
func (m *SMTPRequest) XXX_Size() int {
	return m.Size()
}
func (m *SMTPRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SMTPRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SMTPRequest proto.InternalMessageInfo

func (m *SMTPRequest) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

func (m *SMTPRequest) GetArgument() string {
	if m != nil {
		return m.Argument
	}
	return ""
}

func (m *SMTPRequest) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

// SMTPCommand represents a SMTP command
type SMTPCommand struct {
	Command   int32  `protobuf:"varint,1,opt,name=Command,proto3" json:"Command,omitempty"`
	Parameter string `protobuf:"bytes,2,opt,name=Parameter,proto3" json:"Parameter,omitempty"`
}

func (m *SMTPCommand) Reset()         { *m = SMTPCommand{} }
func (m *SMTPCommand) String() string { return proto.CompactTextString(m) }
func (*SMTPCommand) ProtoMessage()    {}
func (*SMTPCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{128}
}
func (m *SMTPCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SMTPCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SMTPCommand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SMTPCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SMTPCommand.Merge(m, src)
}
func (m *SMTPCommand) XXX_Size() int {
	return m.Size()
}
func (m *SMTPCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_SMTPCommand.DiscardUnknown(m)
}

var xxx_messageInfo_SMTPCommand proto.InternalMessageInfo

func (m *SMTPCommand) GetCommand() int32 {
	if m != nil {
		return m.Command
	}
	return 0
}

func (m *SMTPCommand) GetParameter() string {
	if m != nil {
		return m.Parameter
	}
	return ""
}

// Simple Mail Transfer Protocol
type SMTP struct {
	Timestamp   int64    `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	IsEncrypted bool     `protobuf:"varint,2,opt,name=IsEncrypted,proto3" json:"IsEncrypted,omitempty"`
	IsResponse  bool     `protobuf:"varint,3,opt,name=IsResponse,proto3" json:"IsResponse,omitempty"`
	SrcIP       string   `protobuf:"bytes,6,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP       string   `protobuf:"bytes,7,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
	SrcPort     int32    `protobuf:"varint,8,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	DstPort     int32    `protobuf:"varint,9,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
	MailIDs     []string `protobuf:"bytes,10,rep,name=MailIDs,proto3" json:"MailIDs,omitempty"`
	Commands    []string `protobuf:"bytes,11,rep,name=Commands,proto3" json:"Commands,omitempty"`
}

func (m *SMTP) Reset()         { *m = SMTP{} }
func (m *SMTP) String() string { return proto.CompactTextString(m) }
func (*SMTP) ProtoMessage()    {}
func (*SMTP) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{129}
}
func (m *SMTP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SMTP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SMTP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SMTP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SMTP.Merge(m, src)
}
func (m *SMTP) XXX_Size() int {
	return m.Size()
}
func (m *SMTP) XXX_DiscardUnknown() {
	xxx_messageInfo_SMTP.DiscardUnknown(m)
}

var xxx_messageInfo_SMTP proto.InternalMessageInfo

func (m *SMTP) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *SMTP) GetIsEncrypted() bool {
	if m != nil {
		return m.IsEncrypted
	}
	return false
}

func (m *SMTP) GetIsResponse() bool {
	if m != nil {
		return m.IsResponse
	}
	return false
}

func (m *SMTP) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *SMTP) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

func (m *SMTP) GetSrcPort() int32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *SMTP) GetDstPort() int32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

func (m *SMTP) GetMailIDs() []string {
	if m != nil {
		return m.MailIDs
	}
	return nil
}

func (m *SMTP) GetCommands() []string {
	if m != nil {
		return m.Commands
	}
	return nil
}

// Diameter is an authentication, authorization, and accounting protocol for computer networks.
// It evolved from the earlier RADIUS protocol.
// It belongs to the application layer protocols in the internet protocol suite.
type Diameter struct {
	Timestamp int64 `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	// Diameter Header Information
	Version       uint32 `protobuf:"varint,2,opt,name=Version,proto3" json:"Version,omitempty"`
	Flags         uint32 `protobuf:"varint,3,opt,name=Flags,proto3" json:"Flags,omitempty"`
	MessageLen    uint32 `protobuf:"varint,4,opt,name=MessageLen,proto3" json:"MessageLen,omitempty"`
	CommandCode   uint32 `protobuf:"varint,5,opt,name=CommandCode,proto3" json:"CommandCode,omitempty"`
	ApplicationID uint32 `protobuf:"varint,6,opt,name=ApplicationID,proto3" json:"ApplicationID,omitempty"`
	HopByHopID    uint32 `protobuf:"varint,7,opt,name=HopByHopID,proto3" json:"HopByHopID,omitempty"`
	EndToEndID    uint32 `protobuf:"varint,8,opt,name=EndToEndID,proto3" json:"EndToEndID,omitempty"`
	// Diameter AVPs
	AVPs    []*AVP `protobuf:"bytes,9,rep,name=AVPs,proto3" json:"AVPs,omitempty"`
	SrcIP   string `protobuf:"bytes,10,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	DstIP   string `protobuf:"bytes,11,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
	SrcPort int32  `protobuf:"varint,12,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	DstPort int32  `protobuf:"varint,13,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
}

func (m *Diameter) Reset()         { *m = Diameter{} }
func (m *Diameter) String() string { return proto.CompactTextString(m) }
func (*Diameter) ProtoMessage()    {}
func (*Diameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{130}
}
func (m *Diameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Diameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Diameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Diameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Diameter.Merge(m, src)
}
func (m *Diameter) XXX_Size() int {
	return m.Size()
}
func (m *Diameter) XXX_DiscardUnknown() {
	xxx_messageInfo_Diameter.DiscardUnknown(m)
}

var xxx_messageInfo_Diameter proto.InternalMessageInfo

func (m *Diameter) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Diameter) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Diameter) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *Diameter) GetMessageLen() uint32 {
	if m != nil {
		return m.MessageLen
	}
	return 0
}

func (m *Diameter) GetCommandCode() uint32 {
	if m != nil {
		return m.CommandCode
	}
	return 0
}

func (m *Diameter) GetApplicationID() uint32 {
	if m != nil {
		return m.ApplicationID
	}
	return 0
}

func (m *Diameter) GetHopByHopID() uint32 {
	if m != nil {
		return m.HopByHopID
	}
	return 0
}

func (m *Diameter) GetEndToEndID() uint32 {
	if m != nil {
		return m.EndToEndID
	}
	return 0
}

func (m *Diameter) GetAVPs() []*AVP {
	if m != nil {
		return m.AVPs
	}
	return nil
}

func (m *Diameter) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *Diameter) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

func (m *Diameter) GetSrcPort() int32 {
	if m != nil {
		return m.SrcPort
	}
	return 0
}

func (m *Diameter) GetDstPort() int32 {
	if m != nil {
		return m.DstPort
	}
	return 0
}

// Attribute Value Pair
type AVP struct {
	// Value in the header section of the AVP
	AttributeCode   uint32 `protobuf:"varint,1,opt,name=AttributeCode,proto3" json:"AttributeCode,omitempty"`
	AttributeName   string `protobuf:"bytes,2,opt,name=AttributeName,proto3" json:"AttributeName,omitempty"`
	AttributeFormat string `protobuf:"bytes,3,opt,name=AttributeFormat,proto3" json:"AttributeFormat,omitempty"`
	Flags           uint32 `protobuf:"varint,4,opt,name=Flags,proto3" json:"Flags,omitempty"`
	HeaderLen       uint32 `protobuf:"varint,5,opt,name=HeaderLen,proto3" json:"HeaderLen,omitempty"`
	Len             uint32 `protobuf:"varint,6,opt,name=Len,proto3" json:"Len,omitempty"`
	VendorCode      uint32 `protobuf:"varint,7,opt,name=VendorCode,proto3" json:"VendorCode,omitempty"`
	VendorName      string `protobuf:"bytes,8,opt,name=VendorName,proto3" json:"VendorName,omitempty"`
	VendorID        string `protobuf:"bytes,9,opt,name=VendorID,proto3" json:"VendorID,omitempty"`
	// the value associated with the Attribute, padding with zeros is sometimes added after the value in some case
	DecodedValue string `protobuf:"bytes,10,opt,name=DecodedValue,proto3" json:"DecodedValue,omitempty"`
	Padding      uint32 `protobuf:"varint,11,opt,name=Padding,proto3" json:"Padding,omitempty"`
	Value        []byte `protobuf:"bytes,12,opt,name=Value,proto3" json:"Value,omitempty"`
	ValueLen     uint32 `protobuf:"varint,13,opt,name=ValueLen,proto3" json:"ValueLen,omitempty"`
}

func (m *AVP) Reset()         { *m = AVP{} }
func (m *AVP) String() string { return proto.CompactTextString(m) }
func (*AVP) ProtoMessage()    {}
func (*AVP) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{131}
}
func (m *AVP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AVP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AVP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AVP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AVP.Merge(m, src)
}
func (m *AVP) XXX_Size() int {
	return m.Size()
}
func (m *AVP) XXX_DiscardUnknown() {
	xxx_messageInfo_AVP.DiscardUnknown(m)
}

var xxx_messageInfo_AVP proto.InternalMessageInfo

func (m *AVP) GetAttributeCode() uint32 {
	if m != nil {
		return m.AttributeCode
	}
	return 0
}

func (m *AVP) GetAttributeName() string {
	if m != nil {
		return m.AttributeName
	}
	return ""
}

func (m *AVP) GetAttributeFormat() string {
	if m != nil {
		return m.AttributeFormat
	}
	return ""
}

func (m *AVP) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *AVP) GetHeaderLen() uint32 {
	if m != nil {
		return m.HeaderLen
	}
	return 0
}

func (m *AVP) GetLen() uint32 {
	if m != nil {
		return m.Len
	}
	return 0
}

func (m *AVP) GetVendorCode() uint32 {
	if m != nil {
		return m.VendorCode
	}
	return 0
}

func (m *AVP) GetVendorName() string {
	if m != nil {
		return m.VendorName
	}
	return ""
}

func (m *AVP) GetVendorID() string {
	if m != nil {
		return m.VendorID
	}
	return ""
}

func (m *AVP) GetDecodedValue() string {
	if m != nil {
		return m.DecodedValue
	}
	return ""
}

func (m *AVP) GetPadding() uint32 {
	if m != nil {
		return m.Padding
	}
	return 0
}

func (m *AVP) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *AVP) GetValueLen() uint32 {
	if m != nil {
		return m.ValueLen
	}
	return 0
}

type POP3 struct {
	Timestamp int64    `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	ClientIP  string   `protobuf:"bytes,2,opt,name=ClientIP,proto3" json:"ClientIP,omitempty"`
	ServerIP  string   `protobuf:"bytes,3,opt,name=ServerIP,proto3" json:"ServerIP,omitempty"`
	AuthToken string   `protobuf:"bytes,4,opt,name=AuthToken,proto3" json:"AuthToken,omitempty"`
	User      string   `protobuf:"bytes,5,opt,name=User,proto3" json:"User,omitempty"`
	Pass      string   `protobuf:"bytes,6,opt,name=Pass,proto3" json:"Pass,omitempty"`
	MailIDs   []string `protobuf:"bytes,7,rep,name=MailIDs,proto3" json:"MailIDs,omitempty"`
	Commands  []string `protobuf:"bytes,8,rep,name=Commands,proto3" json:"Commands,omitempty"`
}

func (m *POP3) Reset()         { *m = POP3{} }
func (m *POP3) String() string { return proto.CompactTextString(m) }
func (*POP3) ProtoMessage()    {}
func (*POP3) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{132}
}
func (m *POP3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *POP3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_POP3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *POP3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_POP3.Merge(m, src)
}
func (m *POP3) XXX_Size() int {
	return m.Size()
}
func (m *POP3) XXX_DiscardUnknown() {
	xxx_messageInfo_POP3.DiscardUnknown(m)
}

var xxx_messageInfo_POP3 proto.InternalMessageInfo

func (m *POP3) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *POP3) GetClientIP() string {
	if m != nil {
		return m.ClientIP
	}
	return ""
}

func (m *POP3) GetServerIP() string {
	if m != nil {
		return m.ServerIP
	}
	return ""
}

func (m *POP3) GetAuthToken() string {
	if m != nil {
		return m.AuthToken
	}
	return ""
}

func (m *POP3) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *POP3) GetPass() string {
	if m != nil {
		return m.Pass
	}
	return ""
}

func (m *POP3) GetMailIDs() []string {
	if m != nil {
		return m.MailIDs
	}
	return nil
}

func (m *POP3) GetCommands() []string {
	if m != nil {
		return m.Commands
	}
	return nil
}

type Mail struct {
	Timestamp       int64       `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	ReturnPath      string      `protobuf:"bytes,2,opt,name=ReturnPath,proto3" json:"ReturnPath,omitempty"`
	From            string      `protobuf:"bytes,3,opt,name=From,proto3" json:"From,omitempty"`
	To              string      `protobuf:"bytes,4,opt,name=To,proto3" json:"To,omitempty"`
	CC              string      `protobuf:"bytes,5,opt,name=CC,proto3" json:"CC,omitempty"`
	Subject         string      `protobuf:"bytes,6,opt,name=Subject,proto3" json:"Subject,omitempty"`
	Date            string      `protobuf:"bytes,7,opt,name=Date,proto3" json:"Date,omitempty"`
	MessageID       string      `protobuf:"bytes,8,opt,name=MessageID,proto3" json:"MessageID,omitempty"`
	References      string      `protobuf:"bytes,9,opt,name=References,proto3" json:"References,omitempty"`
	InReplyTo       string      `protobuf:"bytes,10,opt,name=InReplyTo,proto3" json:"InReplyTo,omitempty"`
	ContentLanguage string      `protobuf:"bytes,11,opt,name=ContentLanguage,proto3" json:"ContentLanguage,omitempty"`
	HasAttachments  bool        `protobuf:"varint,12,opt,name=HasAttachments,proto3" json:"HasAttachments,omitempty"`
	XOriginatingIP  string      `protobuf:"bytes,13,opt,name=XOriginatingIP,proto3" json:"XOriginatingIP,omitempty"`
	ContentType     string      `protobuf:"bytes,14,opt,name=ContentType,proto3" json:"ContentType,omitempty"`
	EnvelopeTo      string      `protobuf:"bytes,15,opt,name=EnvelopeTo,proto3" json:"EnvelopeTo,omitempty"`
	Body            []*MailPart `protobuf:"bytes,16,rep,name=Body,proto3" json:"Body,omitempty"`
	ClientIP        string      `protobuf:"bytes,17,opt,name=ClientIP,proto3" json:"ClientIP,omitempty"`
	ServerIP        string      `protobuf:"bytes,18,opt,name=ServerIP,proto3" json:"ServerIP,omitempty"`
	ID              string      `protobuf:"bytes,19,opt,name=ID,proto3" json:"ID,omitempty"`
	DeliveryDate    string      `protobuf:"bytes,20,opt,name=DeliveryDate,proto3" json:"DeliveryDate,omitempty"`
	Origin          string      `protobuf:"bytes,21,opt,name=Origin,proto3" json:"Origin,omitempty"`
}

func (m *Mail) Reset()         { *m = Mail{} }
func (m *Mail) String() string { return proto.CompactTextString(m) }
func (*Mail) ProtoMessage()    {}
func (*Mail) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{133}
}
func (m *Mail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Mail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Mail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Mail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Mail.Merge(m, src)
}
func (m *Mail) XXX_Size() int {
	return m.Size()
}
func (m *Mail) XXX_DiscardUnknown() {
	xxx_messageInfo_Mail.DiscardUnknown(m)
}

var xxx_messageInfo_Mail proto.InternalMessageInfo

func (m *Mail) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Mail) GetReturnPath() string {
	if m != nil {
		return m.ReturnPath
	}
	return ""
}

func (m *Mail) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *Mail) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *Mail) GetCC() string {
	if m != nil {
		return m.CC
	}
	return ""
}

func (m *Mail) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *Mail) GetDate() string {
	if m != nil {
		return m.Date
	}
	return ""
}

func (m *Mail) GetMessageID() string {
	if m != nil {
		return m.MessageID
	}
	return ""
}

func (m *Mail) GetReferences() string {
	if m != nil {
		return m.References
	}
	return ""
}

func (m *Mail) GetInReplyTo() string {
	if m != nil {
		return m.InReplyTo
	}
	return ""
}

func (m *Mail) GetContentLanguage() string {
	if m != nil {
		return m.ContentLanguage
	}
	return ""
}

func (m *Mail) GetHasAttachments() bool {
	if m != nil {
		return m.HasAttachments
	}
	return false
}

func (m *Mail) GetXOriginatingIP() string {
	if m != nil {
		return m.XOriginatingIP
	}
	return ""
}

func (m *Mail) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

func (m *Mail) GetEnvelopeTo() string {
	if m != nil {
		return m.EnvelopeTo
	}
	return ""
}

func (m *Mail) GetBody() []*MailPart {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Mail) GetClientIP() string {
	if m != nil {
		return m.ClientIP
	}
	return ""
}

func (m *Mail) GetServerIP() string {
	if m != nil {
		return m.ServerIP
	}
	return ""
}

func (m *Mail) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Mail) GetDeliveryDate() string {
	if m != nil {
		return m.DeliveryDate
	}
	return ""
}

func (m *Mail) GetOrigin() string {
	if m != nil {
		return m.Origin
	}
	return ""
}

type MailPart struct {
	ID       string            `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Header   map[string]string `protobuf:"bytes,2,rep,name=Header,proto3" json:"Header,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Content  string            `protobuf:"bytes,3,opt,name=Content,proto3" json:"Content,omitempty"`
	Filename string            `protobuf:"bytes,4,opt,name=Filename,proto3" json:"Filename,omitempty"`
}

func (m *MailPart) Reset()         { *m = MailPart{} }
func (m *MailPart) String() string { return proto.CompactTextString(m) }
func (*MailPart) ProtoMessage()    {}
func (*MailPart) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{134}
}
func (m *MailPart) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MailPart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MailPart.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MailPart) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MailPart.Merge(m, src)
}
func (m *MailPart) XXX_Size() int {
	return m.Size()
}
func (m *MailPart) XXX_DiscardUnknown() {
	xxx_messageInfo_MailPart.DiscardUnknown(m)
}

var xxx_messageInfo_MailPart proto.InternalMessageInfo

func (m *MailPart) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *MailPart) GetHeader() map[string]string {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *MailPart) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *MailPart) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

type POP3Request struct {
	Command  string `protobuf:"bytes,1,opt,name=Command,proto3" json:"Command,omitempty"`
	Argument string `protobuf:"bytes,2,opt,name=Argument,proto3" json:"Argument,omitempty"`
}

func (m *POP3Request) Reset()         { *m = POP3Request{} }
func (m *POP3Request) String() string { return proto.CompactTextString(m) }
func (*POP3Request) ProtoMessage()    {}
func (*POP3Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{135}
}
func (m *POP3Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *POP3Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_POP3Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *POP3Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_POP3Request.Merge(m, src)
}
func (m *POP3Request) XXX_Size() int {
	return m.Size()
}
func (m *POP3Request) XXX_DiscardUnknown() {
	xxx_messageInfo_POP3Request.DiscardUnknown(m)
}

var xxx_messageInfo_POP3Request proto.InternalMessageInfo

func (m *POP3Request) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

func (m *POP3Request) GetArgument() string {
	if m != nil {
		return m.Argument
	}
	return ""
}

type POP3Response struct {
	Command string `protobuf:"bytes,1,opt,name=Command,proto3" json:"Command,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
}

func (m *POP3Response) Reset()         { *m = POP3Response{} }
func (m *POP3Response) String() string { return proto.CompactTextString(m) }
func (*POP3Response) ProtoMessage()    {}
func (*POP3Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{136}
}
func (m *POP3Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *POP3Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_POP3Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *POP3Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_POP3Response.Merge(m, src)
}
func (m *POP3Response) XXX_Size() int {
	return m.Size()
}
func (m *POP3Response) XXX_DiscardUnknown() {
	xxx_messageInfo_POP3Response.DiscardUnknown(m)
}

var xxx_messageInfo_POP3Response proto.InternalMessageInfo

func (m *POP3Response) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

func (m *POP3Response) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type Software struct {
	Timestamp      int64    `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Product        string   `protobuf:"bytes,2,opt,name=Product,proto3" json:"Product,omitempty"`
	Vendor         string   `protobuf:"bytes,3,opt,name=Vendor,proto3" json:"Vendor,omitempty"`
	Version        string   `protobuf:"bytes,4,opt,name=Version,proto3" json:"Version,omitempty"`
	DeviceProfiles []string `protobuf:"bytes,5,rep,name=DeviceProfiles,proto3" json:"DeviceProfiles,omitempty"`
	SourceName     string   `protobuf:"bytes,6,opt,name=SourceName,proto3" json:"SourceName,omitempty"`
	DPIResults     []string `protobuf:"bytes,7,rep,name=DPIResults,proto3" json:"DPIResults,omitempty"`
	Service        string   `protobuf:"bytes,8,opt,name=Service,proto3" json:"Service,omitempty"`
	Flows          []string `protobuf:"bytes,9,rep,name=Flows,proto3" json:"Flows,omitempty"`
	SourceData     string   `protobuf:"bytes,10,opt,name=SourceData,proto3" json:"SourceData,omitempty"`
	Notes          string   `protobuf:"bytes,11,opt,name=Notes,proto3" json:"Notes,omitempty"`
	Website        string   `protobuf:"bytes,12,opt,name=Website,proto3" json:"Website,omitempty"`
	OS             string   `protobuf:"bytes,13,opt,name=OS,proto3" json:"OS,omitempty"`
}

func (m *Software) Reset()         { *m = Software{} }
func (m *Software) String() string { return proto.CompactTextString(m) }
func (*Software) ProtoMessage()    {}
func (*Software) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{137}
}
func (m *Software) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Software) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Software.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Software) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Software.Merge(m, src)
}
func (m *Software) XXX_Size() int {
	return m.Size()
}
func (m *Software) XXX_DiscardUnknown() {
	xxx_messageInfo_Software.DiscardUnknown(m)
}

var xxx_messageInfo_Software proto.InternalMessageInfo

func (m *Software) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Software) GetProduct() string {
	if m != nil {
		return m.Product
	}
	return ""
}

func (m *Software) GetVendor() string {
	if m != nil {
		return m.Vendor
	}
	return ""
}

func (m *Software) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Software) GetDeviceProfiles() []string {
	if m != nil {
		return m.DeviceProfiles
	}
	return nil
}

func (m *Software) GetSourceName() string {
	if m != nil {
		return m.SourceName
	}
	return ""
}

func (m *Software) GetDPIResults() []string {
	if m != nil {
		return m.DPIResults
	}
	return nil
}

func (m *Software) GetService() string {
	if m != nil {
		return m.Service
	}
	return ""
}

func (m *Software) GetFlows() []string {
	if m != nil {
		return m.Flows
	}
	return nil
}

func (m *Software) GetSourceData() string {
	if m != nil {
		return m.SourceData
	}
	return ""
}

func (m *Software) GetNotes() string {
	if m != nil {
		return m.Notes
	}
	return ""
}

func (m *Software) GetWebsite() string {
	if m != nil {
		return m.Website
	}
	return ""
}

func (m *Software) GetOS() string {
	if m != nil {
		return m.OS
	}
	return ""
}

type Service struct {
	Timestamp   int64    `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	IP          string   `protobuf:"bytes,2,opt,name=IP,proto3" json:"IP,omitempty"`
	Port        int32    `protobuf:"varint,3,opt,name=Port,proto3" json:"Port,omitempty"`
	Name        string   `protobuf:"bytes,4,opt,name=Name,proto3" json:"Name,omitempty"`
	Banner      string   `protobuf:"bytes,5,opt,name=Banner,proto3" json:"Banner,omitempty"`
	Protocol    string   `protobuf:"bytes,6,opt,name=Protocol,proto3" json:"Protocol,omitempty"`
	Flows       []string `protobuf:"bytes,7,rep,name=Flows,proto3" json:"Flows,omitempty"`
	Product     string   `protobuf:"bytes,8,opt,name=Product,proto3" json:"Product,omitempty"`
	Vendor      string   `protobuf:"bytes,9,opt,name=Vendor,proto3" json:"Vendor,omitempty"`
	Version     string   `protobuf:"bytes,10,opt,name=Version,proto3" json:"Version,omitempty"`
	Notes       string   `protobuf:"bytes,11,opt,name=Notes,proto3" json:"Notes,omitempty"`
	BytesServer int32    `protobuf:"varint,12,opt,name=BytesServer,proto3" json:"BytesServer,omitempty"`
	BytesClient int32    `protobuf:"varint,13,opt,name=BytesClient,proto3" json:"BytesClient,omitempty"`
	Hostname    string   `protobuf:"bytes,14,opt,name=Hostname,proto3" json:"Hostname,omitempty"`
	OS          string   `protobuf:"bytes,15,opt,name=OS,proto3" json:"OS,omitempty"`
}

func (m *Service) Reset()         { *m = Service{} }
func (m *Service) String() string { return proto.CompactTextString(m) }
func (*Service) ProtoMessage()    {}
func (*Service) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{138}
}
func (m *Service) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Service) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Service.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Service) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Service.Merge(m, src)
}
func (m *Service) XXX_Size() int {
	return m.Size()
}
func (m *Service) XXX_DiscardUnknown() {
	xxx_messageInfo_Service.DiscardUnknown(m)
}

var xxx_messageInfo_Service proto.InternalMessageInfo

func (m *Service) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Service) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

func (m *Service) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Service) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Service) GetBanner() string {
	if m != nil {
		return m.Banner
	}
	return ""
}

func (m *Service) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *Service) GetFlows() []string {
	if m != nil {
		return m.Flows
	}
	return nil
}

func (m *Service) GetProduct() string {
	if m != nil {
		return m.Product
	}
	return ""
}

func (m *Service) GetVendor() string {
	if m != nil {
		return m.Vendor
	}
	return ""
}

func (m *Service) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Service) GetNotes() string {
	if m != nil {
		return m.Notes
	}
	return ""
}

func (m *Service) GetBytesServer() int32 {
	if m != nil {
		return m.BytesServer
	}
	return 0
}

func (m *Service) GetBytesClient() int32 {
	if m != nil {
		return m.BytesClient
	}
	return 0
}

func (m *Service) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Service) GetOS() string {
	if m != nil {
		return m.OS
	}
	return ""
}

type Credentials struct {
	Timestamp int64  `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Service   string `protobuf:"bytes,2,opt,name=Service,proto3" json:"Service,omitempty"`
	Flow      string `protobuf:"bytes,3,opt,name=Flow,proto3" json:"Flow,omitempty"`
	User      string `protobuf:"bytes,4,opt,name=User,proto3" json:"User,omitempty"`
	Password  string `protobuf:"bytes,5,opt,name=Password,proto3" json:"Password,omitempty"`
	Notes     string `protobuf:"bytes,6,opt,name=Notes,proto3" json:"Notes,omitempty"`
}

func (m *Credentials) Reset()         { *m = Credentials{} }
func (m *Credentials) String() string { return proto.CompactTextString(m) }
func (*Credentials) ProtoMessage()    {}
func (*Credentials) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{139}
}
func (m *Credentials) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Credentials) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Credentials.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Credentials) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Credentials.Merge(m, src)
}
func (m *Credentials) XXX_Size() int {
	return m.Size()
}
func (m *Credentials) XXX_DiscardUnknown() {
	xxx_messageInfo_Credentials.DiscardUnknown(m)
}

var xxx_messageInfo_Credentials proto.InternalMessageInfo

func (m *Credentials) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Credentials) GetService() string {
	if m != nil {
		return m.Service
	}
	return ""
}

func (m *Credentials) GetFlow() string {
	if m != nil {
		return m.Flow
	}
	return ""
}

func (m *Credentials) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *Credentials) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *Credentials) GetNotes() string {
	if m != nil {
		return m.Notes
	}
	return ""
}

type SSH struct {
	Timestamp  int64  `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	HASSH      string `protobuf:"bytes,2,opt,name=HASSH,proto3" json:"HASSH,omitempty"`
	Flow       string `protobuf:"bytes,3,opt,name=Flow,proto3" json:"Flow,omitempty"`
	Notes      string `protobuf:"bytes,4,opt,name=Notes,proto3" json:"Notes,omitempty"`
	Ident      string `protobuf:"bytes,5,opt,name=Ident,proto3" json:"Ident,omitempty"`
	Algorithms string `protobuf:"bytes,6,opt,name=Algorithms,proto3" json:"Algorithms,omitempty"`
	IsClient   bool   `protobuf:"varint,7,opt,name=IsClient,proto3" json:"IsClient,omitempty"`
}

func (m *SSH) Reset()         { *m = SSH{} }
func (m *SSH) String() string { return proto.CompactTextString(m) }
func (*SSH) ProtoMessage()    {}
func (*SSH) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{140}
}
func (m *SSH) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SSH) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SSH.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SSH) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SSH.Merge(m, src)
}
func (m *SSH) XXX_Size() int {
	return m.Size()
}
func (m *SSH) XXX_DiscardUnknown() {
	xxx_messageInfo_SSH.DiscardUnknown(m)
}

var xxx_messageInfo_SSH proto.InternalMessageInfo

func (m *SSH) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *SSH) GetHASSH() string {
	if m != nil {
		return m.HASSH
	}
	return ""
}

func (m *SSH) GetFlow() string {
	if m != nil {
		return m.Flow
	}
	return ""
}

func (m *SSH) GetNotes() string {
	if m != nil {
		return m.Notes
	}
	return ""
}

func (m *SSH) GetIdent() string {
	if m != nil {
		return m.Ident
	}
	return ""
}

func (m *SSH) GetAlgorithms() string {
	if m != nil {
		return m.Algorithms
	}
	return ""
}

func (m *SSH) GetIsClient() bool {
	if m != nil {
		return m.IsClient
	}
	return false
}

type Vulnerability struct {
	Timestamp    int64     `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	ID           string    `protobuf:"bytes,2,opt,name=ID,proto3" json:"ID,omitempty"`
	Description  string    `protobuf:"bytes,3,opt,name=Description,proto3" json:"Description,omitempty"`
	Severity     string    `protobuf:"bytes,4,opt,name=Severity,proto3" json:"Severity,omitempty"`
	V2Score      string    `protobuf:"bytes,5,opt,name=V2Score,proto3" json:"V2Score,omitempty"`
	AccessVector string    `protobuf:"bytes,6,opt,name=AccessVector,proto3" json:"AccessVector,omitempty"`
	Versions     []string  `protobuf:"bytes,7,rep,name=Versions,proto3" json:"Versions,omitempty"`
	Notes        string    `protobuf:"bytes,8,opt,name=Notes,proto3" json:"Notes,omitempty"`
	Software     *Software `protobuf:"bytes,9,opt,name=Software,proto3" json:"Software,omitempty"`
}

func (m *Vulnerability) Reset()         { *m = Vulnerability{} }
func (m *Vulnerability) String() string { return proto.CompactTextString(m) }
func (*Vulnerability) ProtoMessage()    {}
func (*Vulnerability) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{141}
}
func (m *Vulnerability) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vulnerability) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vulnerability.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vulnerability) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vulnerability.Merge(m, src)
}
func (m *Vulnerability) XXX_Size() int {
	return m.Size()
}
func (m *Vulnerability) XXX_DiscardUnknown() {
	xxx_messageInfo_Vulnerability.DiscardUnknown(m)
}

var xxx_messageInfo_Vulnerability proto.InternalMessageInfo

func (m *Vulnerability) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Vulnerability) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Vulnerability) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Vulnerability) GetSeverity() string {
	if m != nil {
		return m.Severity
	}
	return ""
}

func (m *Vulnerability) GetV2Score() string {
	if m != nil {
		return m.V2Score
	}
	return ""
}

func (m *Vulnerability) GetAccessVector() string {
	if m != nil {
		return m.AccessVector
	}
	return ""
}

func (m *Vulnerability) GetVersions() []string {
	if m != nil {
		return m.Versions
	}
	return nil
}

func (m *Vulnerability) GetNotes() string {
	if m != nil {
		return m.Notes
	}
	return ""
}

func (m *Vulnerability) GetSoftware() *Software {
	if m != nil {
		return m.Software
	}
	return nil
}

type Exploit struct {
	Timestamp   int64     `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	ID          string    `protobuf:"bytes,2,opt,name=ID,proto3" json:"ID,omitempty"`
	Description string    `protobuf:"bytes,3,opt,name=Description,proto3" json:"Description,omitempty"`
	File        string    `protobuf:"bytes,4,opt,name=File,proto3" json:"File,omitempty"`
	Notes       string    `protobuf:"bytes,5,opt,name=Notes,proto3" json:"Notes,omitempty"`
	Date        string    `protobuf:"bytes,6,opt,name=Date,proto3" json:"Date,omitempty"`
	Author      string    `protobuf:"bytes,7,opt,name=Author,proto3" json:"Author,omitempty"`
	Typ         string    `protobuf:"bytes,8,opt,name=Typ,proto3" json:"Typ,omitempty"`
	Platform    string    `protobuf:"bytes,9,opt,name=Platform,proto3" json:"Platform,omitempty"`
	Port        string    `protobuf:"bytes,10,opt,name=Port,proto3" json:"Port,omitempty"`
	Software    *Software `protobuf:"bytes,11,opt,name=Software,proto3" json:"Software,omitempty"`
}

func (m *Exploit) Reset()         { *m = Exploit{} }
func (m *Exploit) String() string { return proto.CompactTextString(m) }
func (*Exploit) ProtoMessage()    {}
func (*Exploit) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{142}
}
func (m *Exploit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Exploit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Exploit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Exploit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Exploit.Merge(m, src)
}
func (m *Exploit) XXX_Size() int {
	return m.Size()
}
func (m *Exploit) XXX_DiscardUnknown() {
	xxx_messageInfo_Exploit.DiscardUnknown(m)
}

var xxx_messageInfo_Exploit proto.InternalMessageInfo

func (m *Exploit) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Exploit) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Exploit) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Exploit) GetFile() string {
	if m != nil {
		return m.File
	}
	return ""
}

func (m *Exploit) GetNotes() string {
	if m != nil {
		return m.Notes
	}
	return ""
}

func (m *Exploit) GetDate() string {
	if m != nil {
		return m.Date
	}
	return ""
}

func (m *Exploit) GetAuthor() string {
	if m != nil {
		return m.Author
	}
	return ""
}

func (m *Exploit) GetTyp() string {
	if m != nil {
		return m.Typ
	}
	return ""
}

func (m *Exploit) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *Exploit) GetPort() string {
	if m != nil {
		return m.Port
	}
	return ""
}

func (m *Exploit) GetSoftware() *Software {
	if m != nil {
		return m.Software
	}
	return nil
}

// Alert models a user defined event with IP layer and meta information.
type Alert struct {
	Timestamp    int64  `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Name         string `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	Description  string `protobuf:"bytes,3,opt,name=Description,proto3" json:"Description,omitempty"`
	SrcIP        string `protobuf:"bytes,4,opt,name=SrcIP,proto3" json:"SrcIP,omitempty"`
	SrcPort      string `protobuf:"bytes,5,opt,name=SrcPort,proto3" json:"SrcPort,omitempty"`
	DstIP        string `protobuf:"bytes,6,opt,name=DstIP,proto3" json:"DstIP,omitempty"`
	DstPort      string `protobuf:"bytes,7,opt,name=DstPort,proto3" json:"DstPort,omitempty"`
	MITRE        string `protobuf:"bytes,8,opt,name=MITRE,proto3" json:"MITRE,omitempty"`
	IPReputation string `protobuf:"bytes,9,opt,name=IPReputation,proto3" json:"IPReputation,omitempty"`
	Domain       string `protobuf:"bytes,10,opt,name=Domain,proto3" json:"Domain,omitempty"`
	Protocol     string `protobuf:"bytes,11,opt,name=Protocol,proto3" json:"Protocol,omitempty"`
	Notes        string `protobuf:"bytes,12,opt,name=Notes,proto3" json:"Notes,omitempty"`
}

func (m *Alert) Reset()         { *m = Alert{} }
func (m *Alert) String() string { return proto.CompactTextString(m) }
func (*Alert) ProtoMessage()    {}
func (*Alert) Descriptor() ([]byte, []int) {
	return fileDescriptor_3068659fd5590671, []int{143}
}
func (m *Alert) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Alert) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Alert.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Alert) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Alert.Merge(m, src)
}
func (m *Alert) XXX_Size() int {
	return m.Size()
}
func (m *Alert) XXX_DiscardUnknown() {
	xxx_messageInfo_Alert.DiscardUnknown(m)
}

var xxx_messageInfo_Alert proto.InternalMessageInfo

func (m *Alert) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Alert) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Alert) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Alert) GetSrcIP() string {
	if m != nil {
		return m.SrcIP
	}
	return ""
}

func (m *Alert) GetSrcPort() string {
	if m != nil {
		return m.SrcPort
	}
	return ""
}

func (m *Alert) GetDstIP() string {
	if m != nil {
		return m.DstIP
	}
	return ""
}

func (m *Alert) GetDstPort() string {
	if m != nil {
		return m.DstPort
	}
	return ""
}

func (m *Alert) GetMITRE() string {
	if m != nil {
		return m.MITRE
	}
	return ""
}

func (m *Alert) GetIPReputation() string {
	if m != nil {
		return m.IPReputation
	}
	return ""
}

func (m *Alert) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *Alert) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *Alert) GetNotes() string {
	if m != nil {
		return m.Notes
	}
	return ""
}

func init() {
	proto.RegisterEnum("types.Type", Type_name, Type_value)
	proto.RegisterType((*Header)(nil), "types.Header")
	proto.RegisterType((*Batch)(nil), "types.Batch")
	proto.RegisterType((*PacketContext)(nil), "types.PacketContext")
	proto.RegisterType((*Connection)(nil), "types.Connection")
	proto.RegisterType((*Ethernet)(nil), "types.Ethernet")
	proto.RegisterType((*ARP)(nil), "types.ARP")
	proto.RegisterType((*Dot1Q)(nil), "types.Dot1Q")
	proto.RegisterType((*Dot11)(nil), "types.Dot11")
	proto.RegisterType((*Dot11QOS)(nil), "types.Dot11QOS")
	proto.RegisterType((*Dot11HTControl)(nil), "types.Dot11HTControl")
	proto.RegisterType((*Dot11HTControlVHT)(nil), "types.Dot11HTControlVHT")
	proto.RegisterType((*Dot11HTControlHT)(nil), "types.Dot11HTControlHT")
	proto.RegisterType((*Dot11HTControlMFB)(nil), "types.Dot11HTControlMFB")
	proto.RegisterType((*Dot11LinkAdapationControl)(nil), "types.Dot11LinkAdapationControl")
	proto.RegisterType((*Dot11ASEL)(nil), "types.Dot11ASEL")
	proto.RegisterType((*LinkLayerDiscovery)(nil), "types.LinkLayerDiscovery")
	proto.RegisterType((*LLDPChassisID)(nil), "types.LLDPChassisID")
	proto.RegisterType((*LLDPPortID)(nil), "types.LLDPPortID")
	proto.RegisterType((*LinkLayerDiscoveryValue)(nil), "types.LinkLayerDiscoveryValue")
	proto.RegisterType((*EthernetCTP)(nil), "types.EthernetCTP")
	proto.RegisterType((*EthernetCTPReply)(nil), "types.EthernetCTPReply")
	proto.RegisterType((*LinkLayerDiscoveryInfo)(nil), "types.LinkLayerDiscoveryInfo")
	proto.RegisterType((*LLDPSysCapabilities)(nil), "types.LLDPSysCapabilities")
	proto.RegisterType((*LLDPCapabilities)(nil), "types.LLDPCapabilities")
	proto.RegisterType((*LLDPMgmtAddress)(nil), "types.LLDPMgmtAddress")
	proto.RegisterType((*LLDPOrgSpecificTLV)(nil), "types.LLDPOrgSpecificTLV")
	proto.RegisterType((*IPv4)(nil), "types.IPv4")
	proto.RegisterType((*IPv4Option)(nil), "types.IPv4Option")
	proto.RegisterType((*IPv6)(nil), "types.IPv6")
	proto.RegisterType((*IPv6Fragment)(nil), "types.IPv6Fragment")
	proto.RegisterType((*ICMPv4)(nil), "types.ICMPv4")
	proto.RegisterType((*ICMPv6)(nil), "types.ICMPv6")
	proto.RegisterType((*ICMPv6NeighborAdvertisement)(nil), "types.ICMPv6NeighborAdvertisement")
	proto.RegisterType((*ICMPv6RouterAdvertisement)(nil), "types.ICMPv6RouterAdvertisement")
	proto.RegisterType((*ICMPv6Option)(nil), "types.ICMPv6Option")
	proto.RegisterType((*UDP)(nil), "types.UDP")
	proto.RegisterType((*TCP)(nil), "types.TCP")
	proto.RegisterType((*TCPOption)(nil), "types.TCPOption")
	proto.RegisterType((*SCTP)(nil), "types.SCTP")
	proto.RegisterType((*DNS)(nil), "types.DNS")
	proto.RegisterType((*DNSResourceRecord)(nil), "types.DNSResourceRecord")
	proto.RegisterType((*DNSSOA)(nil), "types.DNSSOA")
	proto.RegisterType((*DNSSRV)(nil), "types.DNSSRV")
	proto.RegisterType((*DNSMX)(nil), "types.DNSMX")
	proto.RegisterType((*DNSQuestion)(nil), "types.DNSQuestion")
	proto.RegisterType((*DHCPv4)(nil), "types.DHCPv4")
	proto.RegisterType((*DHCPOption)(nil), "types.DHCPOption")
	proto.RegisterType((*DHCPv6)(nil), "types.DHCPv6")
	proto.RegisterType((*DHCPv6Option)(nil), "types.DHCPv6Option")
	proto.RegisterType((*LLC)(nil), "types.LLC")
	proto.RegisterType((*NTP)(nil), "types.NTP")
	proto.RegisterType((*SIP)(nil), "types.SIP")
	proto.RegisterType((*IGMP)(nil), "types.IGMP")
	proto.RegisterType((*IGMPv3GroupRecord)(nil), "types.IGMPv3GroupRecord")
	proto.RegisterType((*IPv6HopByHop)(nil), "types.IPv6HopByHop")
	proto.RegisterType((*IPv6HopByHopOption)(nil), "types.IPv6HopByHopOption")
	proto.RegisterType((*IPv6HopByHopOptionAlignment)(nil), "types.IPv6HopByHopOptionAlignment")
	proto.RegisterType((*SNAP)(nil), "types.SNAP")
	proto.RegisterType((*ICMPv6Echo)(nil), "types.ICMPv6Echo")
	proto.RegisterType((*ICMPv6NeighborSolicitation)(nil), "types.ICMPv6NeighborSolicitation")
	proto.RegisterType((*ICMPv6RouterSolicitation)(nil), "types.ICMPv6RouterSolicitation")
	proto.RegisterType((*HTTP)(nil), "types.HTTP")
	proto.RegisterMapType((map[string]string)(nil), "types.HTTP.ParametersEntry")
	proto.RegisterMapType((map[string]string)(nil), "types.HTTP.RequestHeaderEntry")
	proto.RegisterMapType((map[string]string)(nil), "types.HTTP.ResponseHeaderEntry")
	proto.RegisterType((*HTTPCookie)(nil), "types.HTTPCookie")
	proto.RegisterType((*TLSClientHello)(nil), "types.TLSClientHello")
	proto.RegisterType((*TLSServerHello)(nil), "types.TLSServerHello")
	proto.RegisterType((*IPSecAH)(nil), "types.IPSecAH")
	proto.RegisterType((*IPSecESP)(nil), "types.IPSecESP")
	proto.RegisterType((*Geneve)(nil), "types.Geneve")
	proto.RegisterType((*GeneveOption)(nil), "types.GeneveOption")
	proto.RegisterType((*VXLAN)(nil), "types.VXLAN")
	proto.RegisterType((*USB)(nil), "types.USB")
	proto.RegisterType((*USBRequestBlockSetup)(nil), "types.USBRequestBlockSetup")
	proto.RegisterType((*LCM)(nil), "types.LCM")
	proto.RegisterType((*MPLS)(nil), "types.MPLS")
	proto.RegisterType((*Modbus)(nil), "types.Modbus")
	proto.RegisterType((*OSPFv2)(nil), "types.OSPFv2")
	proto.RegisterType((*HelloPkg)(nil), "types.HelloPkg")
	proto.RegisterType((*HelloPkgV2)(nil), "types.HelloPkgV2")
	proto.RegisterType((*DbDescPkg)(nil), "types.DbDescPkg")
	proto.RegisterType((*OSPFv3)(nil), "types.OSPFv3")
	proto.RegisterType((*LSAheader)(nil), "types.LSAheader")
	proto.RegisterType((*LSA)(nil), "types.LSA")
	proto.RegisterType((*LSReq)(nil), "types.LSReq")
	proto.RegisterType((*LSUpdate)(nil), "types.LSUpdate")
	proto.RegisterType((*IntraAreaPrefixLSA)(nil), "types.IntraAreaPrefixLSA")
	proto.RegisterType((*ASExternalLSA)(nil), "types.ASExternalLSA")
	proto.RegisterType((*InterAreaPrefixLSA)(nil), "types.InterAreaPrefixLSA")
	proto.RegisterType((*InterAreaRouterLSA)(nil), "types.InterAreaRouterLSA")
	proto.RegisterType((*ASExternalLSAV2)(nil), "types.ASExternalLSAV2")
	proto.RegisterType((*RouterLSA)(nil), "types.RouterLSA")
	proto.RegisterType((*Router)(nil), "types.Router")
	proto.RegisterType((*RouterLSAV2)(nil), "types.RouterLSAV2")
	proto.RegisterType((*RouterV2)(nil), "types.RouterV2")
	proto.RegisterType((*NetworkLSA)(nil), "types.NetworkLSA")
	proto.RegisterType((*LinkLSA)(nil), "types.LinkLSA")
	proto.RegisterType((*LSAPrefix)(nil), "types.LSAPrefix")
	proto.RegisterType((*BFD)(nil), "types.BFD")
	proto.RegisterType((*BFDAuthHeader)(nil), "types.BFDAuthHeader")
	proto.RegisterType((*GRE)(nil), "types.GRE")
	proto.RegisterType((*GRERouting)(nil), "types.GRERouting")
	proto.RegisterType((*FDDI)(nil), "types.FDDI")
	proto.RegisterType((*EAP)(nil), "types.EAP")
	proto.RegisterType((*EAPOL)(nil), "types.EAPOL")
	proto.RegisterType((*EAPOLKey)(nil), "types.EAPOLKey")
	proto.RegisterType((*VRRPv2)(nil), "types.VRRPv2")
	proto.RegisterType((*CiscoDiscovery)(nil), "types.CiscoDiscovery")
	proto.RegisterType((*CiscoDiscoveryValue)(nil), "types.CiscoDiscoveryValue")
	proto.RegisterType((*CDPVLANDialogue)(nil), "types.CDPVLANDialogue")
	proto.RegisterType((*CDPLocation)(nil), "types.CDPLocation")
	proto.RegisterType((*CDPPowerDialogue)(nil), "types.CDPPowerDialogue")
	proto.RegisterType((*CDPSparePairPoE)(nil), "types.CDPSparePairPoE")
	proto.RegisterType((*CiscoDiscoveryInfo)(nil), "types.CiscoDiscoveryInfo")
	proto.RegisterType((*CDPHello)(nil), "types.CDPHello")
	proto.RegisterType((*CDPEnergyWise)(nil), "types.CDPEnergyWise")
	proto.RegisterType((*CDPCapabilities)(nil), "types.CDPCapabilities")
	proto.RegisterType((*IPNet)(nil), "types.IPNet")
	proto.RegisterType((*NortelDiscovery)(nil), "types.NortelDiscovery")
	proto.RegisterType((*CIP)(nil), "types.CIP")
	proto.RegisterType((*ENIP)(nil), "types.ENIP")
	proto.RegisterType((*ENIPCommandSpecificData)(nil), "types.ENIPCommandSpecificData")
	proto.RegisterType((*DeviceProfile)(nil), "types.DeviceProfile")
	proto.RegisterType((*Port)(nil), "types.Port")
	proto.RegisterType((*PortStats)(nil), "types.PortStats")
	proto.RegisterType((*IPProfile)(nil), "types.IPProfile")
	proto.RegisterMapType((map[string]string)(nil), "types.IPProfile.Ja3HashesEntry")
	proto.RegisterMapType((map[string]*Protocol)(nil), "types.IPProfile.ProtocolsEntry")
	proto.RegisterMapType((map[string]int64)(nil), "types.IPProfile.SNIsEntry")
	proto.RegisterType((*Protocol)(nil), "types.Protocol")
	proto.RegisterType((*File)(nil), "types.File")
	proto.RegisterType((*SMTPResponse)(nil), "types.SMTPResponse")
	proto.RegisterType((*SMTPRequest)(nil), "types.SMTPRequest")
	proto.RegisterType((*SMTPCommand)(nil), "types.SMTPCommand")
	proto.RegisterType((*SMTP)(nil), "types.SMTP")
	proto.RegisterType((*Diameter)(nil), "types.Diameter")
	proto.RegisterType((*AVP)(nil), "types.AVP")
	proto.RegisterType((*POP3)(nil), "types.POP3")
	proto.RegisterType((*Mail)(nil), "types.Mail")
	proto.RegisterType((*MailPart)(nil), "types.MailPart")
	proto.RegisterMapType((map[string]string)(nil), "types.MailPart.HeaderEntry")
	proto.RegisterType((*POP3Request)(nil), "types.POP3Request")
	proto.RegisterType((*POP3Response)(nil), "types.POP3Response")
	proto.RegisterType((*Software)(nil), "types.Software")
	proto.RegisterType((*Service)(nil), "types.Service")
	proto.RegisterType((*Credentials)(nil), "types.Credentials")
	proto.RegisterType((*SSH)(nil), "types.SSH")
	proto.RegisterType((*Vulnerability)(nil), "types.Vulnerability")
	proto.RegisterType((*Exploit)(nil), "types.Exploit")
	proto.RegisterType((*Alert)(nil), "types.Alert")
}

func init() { proto.RegisterFile("netcap.proto", fileDescriptor_3068659fd5590671) }

var fileDescriptor_3068659fd5590671 = []byte{
	// 12191 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0xbd, 0x6f, 0x8c, 0x24, 0x49,
	0x76, 0x10, 0x7e, 0xf5, 0xaf, 0xbb, 0x2a, 0xaa, 0xaa, 0x27, 0x27, 0x67, 0x76, 0xa6, 0x77, 0x76,
	0x6e, 0x6e, 0x2e, 0xbd, 0xb7, 0xb7, 0x9e, 0xdb, 0x1b, 0xdf, 0xf6, 0xac, 0xd7, 0xf7, 0xf7, 0x67,
	0x57, 0x57, 0x75, 0x4f, 0xd7, 0x4d, 0x55, 0x75, 0x4e, 0x64, 0x75, 0xcf, 0xde, 0xf9, 0x07, 0x4b,
	0x4e, 0x55, 0x74, 0x77, 0xba, 0xab, 0x33, 0x6b, 0x33, 0xb3, 0x66, 0xa6, 0x2d, 0x21, 0x99, 0x0f,
	0x87, 0x04, 0x92, 0x65, 0xc0, 0xfe, 0x80, 0xc0, 0x06, 0xf9, 0xab, 0xc1, 0xc0, 0x07, 0x83, 0x40,
	0x96, 0x00, 0x09, 0x81, 0x91, 0x25, 0x84, 0x31, 0x7c, 0xb0, 0x84, 0xb0, 0x90, 0x8d, 0xb0, 0xf8,
	0x2b, 0x21, 0x10, 0x92, 0x31, 0x42, 0x28, 0x5e, 0xbc, 0x88, 0x8c, 0xc8, 0xca, 0x9a, 0xee, 0x19,
	0xdf, 0x22, 0x21, 0xf1, 0x2d, 0xdf, 0x8b, 0xc8, 0xcc, 0x88, 0x17, 0x2f, 0x5e, 0xbc, 0xf7, 0xe2,
	0xc5, 0x0b, 0xd2, 0x0a, 0x59, 0x3a, 0xf1, 0xe7, 0xf7, 0xe7, 0x71, 0x94, 0x46, 0x76, 0x2d, 0x3d,
	0x9f, 0xb3, 0xc4, 0xf9, 0x2b, 0x25, 0xb2, 0xb6, 0xc7, 0xfc, 0x29, 0x8b, 0xed, 0x4d, 0xb2, 0xde,
	0x8d, 0x99, 0x9f, 0xb2, 0xe9, 0x66, 0xe9, 0x6e, 0xe9, 0xdd, 0x0a, 0x95, 0xa0, 0x7d, 0x97, 0x34,
	0xfb, 0xe1, 0x7c, 0x91, 0x7a, 0xd1, 0x22, 0x9e, 0xb0, 0xcd, 0xf2, 0xdd, 0xd2, 0xbb, 0x0d, 0xaa,
	0xa3, 0xec, 0xcf, 0x91, 0xea, 0xf8, 0x7c, 0xce, 0x36, 0x2b, 0x77, 0x4b, 0xef, 0x6e, 0x6c, 0x35,
	0xef, 0xc3, 0xc7, 0xef, 0x73, 0x14, 0x85, 0x02, 0xfe, 0xf1, 0x43, 0x16, 0x27, 0x41, 0x14, 0x6e,
	0x56, 0xe1, 0x75, 0x09, 0xda, 0xf7, 0x88, 0xd5, 0x8d, 0xc2, 0xd4, 0x0f, 0xc2, 0xc4, 0xf5, 0xcf,
	0x67, 0x91, 0x3f, 0x4d, 0x36, 0x6b, 0x77, 0x4b, 0xef, 0xd6, 0xe9, 0x12, 0xde, 0xf9, 0x1b, 0x25,
	0x52, 0xdb, 0xf6, 0xd3, 0xc9, 0x89, 0x7d, 0x8b, 0xd4, 0xbb, 0xb3, 0x80, 0x85, 0x69, 0xbf, 0x07,
	0xad, 0x6d, 0x50, 0x05, 0xdb, 0x5f, 0x26, 0xcd, 0x21, 0x4b, 0x12, 0xff, 0x98, 0x41, 0x9b, 0xca,
	0xcb, 0x6d, 0xd2, 0xcb, 0xed, 0xdb, 0xa4, 0x31, 0x8e, 0x52, 0x7f, 0xe6, 0x05, 0x3f, 0x29, 0x3a,
	0x50, 0xa3, 0x19, 0xc2, 0xb6, 0x49, 0xb5, 0xe7, 0xa7, 0x3e, 0xb4, 0xba, 0x45, 0xe1, 0xf9, 0x95,
	0x9a, 0x1c, 0x91, 0xb6, 0xeb, 0x4f, 0x4e, 0x59, 0xca, 0x4b, 0xd8, 0x8b, 0xd4, 0xbe, 0x4e, 0x6a,
	0x5e, 0x3c, 0xe9, 0xbb, 0xd8, 0x6c, 0x01, 0x70, 0x6c, 0x2f, 0x49, 0xfb, 0x2e, 0x12, 0x57, 0x00,
	0x9c, 0x6a, 0x5e, 0x3c, 0x71, 0xa3, 0x38, 0xc5, 0x86, 0x49, 0x90, 0x97, 0xf4, 0x92, 0x14, 0x4a,
	0xaa, 0xa2, 0x04, 0x41, 0xe7, 0x37, 0xd6, 0x09, 0xe9, 0x46, 0x61, 0xc8, 0x26, 0x29, 0x27, 0xef,
	0x3b, 0x64, 0x63, 0x1c, 0x9c, 0xb1, 0x24, 0xf5, 0xcf, 0xe6, 0xbb, 0x41, 0x9c, 0xa4, 0x38, 0xb8,
	0x39, 0x2c, 0xa7, 0xc2, 0x20, 0x08, 0x4f, 0x5d, 0xce, 0x1c, 0xd8, 0x88, 0x0c, 0x61, 0x3b, 0xa4,
	0x35, 0x62, 0xe9, 0xf3, 0x28, 0xc6, 0x0a, 0x15, 0xa8, 0x60, 0xe0, 0xe0, 0x4f, 0xb1, 0x1f, 0x26,
	0xf3, 0x28, 0x4e, 0x45, 0x2d, 0x31, 0xd2, 0x39, 0x2c, 0xa7, 0x5e, 0x67, 0x3e, 0x9f, 0x05, 0x13,
	0x9f, 0x37, 0x50, 0xd4, 0xac, 0x41, 0xcd, 0x25, 0xbc, 0x7d, 0x83, 0xac, 0x79, 0xf1, 0x64, 0xd8,
	0xe9, 0x6e, 0xae, 0x41, 0x0d, 0x84, 0x38, 0xbe, 0x97, 0xa4, 0x1c, 0xbf, 0x2e, 0xf0, 0x02, 0xca,
	0x88, 0x5b, 0xd7, 0x89, 0xab, 0x91, 0xb1, 0x21, 0x98, 0x4f, 0x92, 0x51, 0x91, 0x9d, 0xe4, 0xc8,
	0x2e, 0x89, 0xdb, 0x14, 0xf5, 0x11, 0x34, 0x79, 0xa5, 0x95, 0xe7, 0x95, 0x77, 0xc8, 0x46, 0x67,
	0x3e, 0xc7, 0xa1, 0x87, 0x2a, 0x6d, 0xa8, 0x92, 0xc3, 0xda, 0x77, 0x08, 0x19, 0x2d, 0xce, 0x04,
	0x5b, 0x24, 0x9b, 0x1b, 0x50, 0x47, 0xc3, 0xd8, 0x16, 0xa9, 0x1c, 0xf4, 0x7b, 0x9b, 0x57, 0xe0,
	0xdf, 0xfc, 0xd1, 0x7e, 0x9b, 0xb4, 0xd5, 0x78, 0x0d, 0xfc, 0x24, 0xdd, 0xb4, 0x60, 0x10, 0x4d,
	0x24, 0x9f, 0x14, 0xbd, 0x45, 0x0c, 0xe4, 0xdb, 0xbc, 0x0a, 0x15, 0x14, 0x6c, 0x7f, 0x85, 0x5c,
	0xdb, 0x3e, 0x4f, 0x59, 0xe2, 0xb1, 0xf8, 0x19, 0x8b, 0xc7, 0x91, 0x98, 0x2d, 0x9b, 0x36, 0x54,
	0x2b, 0x2a, 0x52, 0x6f, 0x08, 0x70, 0x1c, 0x89, 0xe2, 0xcd, 0x6b, 0xda, 0x1b, 0x66, 0x11, 0x97,
	0x13, 0xa3, 0xc5, 0xd9, 0x6e, 0x7f, 0xb4, 0x3b, 0xf3, 0x8f, 0x93, 0xcd, 0xeb, 0xd0, 0x31, 0x1d,
	0x85, 0x35, 0xa8, 0x37, 0x16, 0x35, 0xde, 0x50, 0x35, 0x24, 0x0a, 0x6b, 0x74, 0xba, 0x8f, 0x44,
	0x8d, 0x1b, 0xaa, 0x86, 0x44, 0x61, 0x0d, 0xef, 0x3b, 0xf8, 0x97, 0x9b, 0xaa, 0x86, 0x44, 0x61,
	0x8d, 0x03, 0xfa, 0x50, 0xd4, 0xd8, 0x54, 0x35, 0x24, 0x0a, 0x6b, 0xec, 0x74, 0x77, 0x44, 0x8d,
	0x37, 0x55, 0x0d, 0x89, 0xc2, 0x1a, 0xae, 0xb7, 0x27, 0x6a, 0xdc, 0x52, 0x35, 0x24, 0x0a, 0x6b,
	0x74, 0x9f, 0x50, 0x51, 0xe3, 0x2d, 0x55, 0x43, 0xa2, 0x70, 0x9c, 0x47, 0x9e, 0xa8, 0x70, 0x5b,
	0x8d, 0x33, 0x62, 0x38, 0xbf, 0x0c, 0x99, 0x1f, 0x3e, 0x09, 0xc2, 0x69, 0xf4, 0x1c, 0xf8, 0xe5,
	0xb3, 0x82, 0x5f, 0x4c, 0xac, 0xf3, 0x8f, 0x4a, 0xa4, 0xbe, 0x93, 0x9e, 0xb0, 0x38, 0x64, 0x82,
	0x05, 0xe5, 0xa8, 0xe3, 0x5c, 0xce, 0x10, 0xda, 0x84, 0x29, 0xaf, 0x98, 0x30, 0x15, 0x63, 0xc2,
	0x38, 0xa4, 0x25, 0xbf, 0x0c, 0xc2, 0x52, 0x08, 0x13, 0x03, 0xc7, 0x9b, 0x89, 0xdc, 0xbb, 0x13,
	0xa6, 0x71, 0x34, 0x3f, 0x87, 0xe9, 0x5a, 0xa2, 0x39, 0x2c, 0x27, 0x88, 0xce, 0xfb, 0x6b, 0x82,
	0x20, 0x1a, 0xca, 0xf9, 0xfd, 0x32, 0xa9, 0x74, 0xa8, 0x7b, 0x41, 0x1f, 0x6e, 0x91, 0x7a, 0x67,
	0x3a, 0x8d, 0x95, 0xf0, 0xae, 0x51, 0x05, 0xf3, 0x32, 0x90, 0x0c, 0x93, 0x68, 0x86, 0x22, 0x51,
	0xc1, 0x7c, 0x92, 0xec, 0x3d, 0xe7, 0x35, 0x59, 0x92, 0x40, 0x0b, 0x44, 0x67, 0x4c, 0x24, 0x67,
	0x6b, 0xf9, 0x86, 0x5e, 0xb7, 0x06, 0x75, 0x8b, 0x8a, 0x78, 0x6b, 0xf7, 0xe7, 0x0c, 0xe7, 0x95,
	0xe8, 0x55, 0x86, 0xe0, 0x14, 0xf4, 0xe2, 0x89, 0xfa, 0x07, 0x0a, 0x24, 0x03, 0x67, 0xdf, 0x27,
	0x36, 0x97, 0x38, 0xe6, 0xb7, 0x51, 0x46, 0x15, 0x94, 0xf0, 0x6f, 0xf6, 0x92, 0x34, 0xfb, 0xa6,
	0x90, 0x5a, 0x06, 0x8e, 0x7f, 0x93, 0x4b, 0xa5, 0xdc, 0x37, 0x85, 0x1c, 0x2b, 0x28, 0x71, 0x7e,
	0xb1, 0x44, 0x6a, 0xbd, 0x28, 0x7d, 0xff, 0xf1, 0xc5, 0xd4, 0x77, 0xe3, 0x20, 0x8a, 0x83, 0xf4,
	0x5c, 0x52, 0x5f, 0xc2, 0xd0, 0xae, 0x38, 0x9a, 0xef, 0xcc, 0x82, 0xe3, 0xe0, 0xe9, 0x4c, 0xac,
	0x96, 0x75, 0x6a, 0xe0, 0x38, 0xb7, 0x1c, 0x0e, 0x3a, 0xa3, 0xfe, 0x94, 0x85, 0x69, 0x70, 0x14,
	0xb0, 0x18, 0x87, 0x21, 0x87, 0xe5, 0x0b, 0x2b, 0x8c, 0xb0, 0x20, 0x3c, 0x3c, 0x3b, 0x7f, 0xa7,
	0x22, 0xda, 0xf8, 0xfe, 0x05, 0x6d, 0x94, 0xef, 0x96, 0xb3, 0x77, 0xb9, 0x28, 0xcf, 0xd6, 0xa6,
	0x1a, 0x15, 0x00, 0xc7, 0x8a, 0xd9, 0x27, 0x1a, 0x51, 0x53, 0x13, 0x53, 0x0a, 0xc6, 0x7e, 0x0f,
	0x5b, 0xa0, 0x61, 0x24, 0x07, 0xb2, 0x24, 0x79, 0x1f, 0x17, 0x1e, 0x05, 0x6b, 0x65, 0x5b, 0x38,
	0xd6, 0x0a, 0xd6, 0xca, 0x1e, 0xe0, 0xe8, 0x2a, 0x58, 0x2b, 0xfb, 0x00, 0xc7, 0x53, 0xc1, 0x9c,
	0x66, 0x1e, 0xfb, 0x64, 0xc1, 0xc2, 0x09, 0x1b, 0x2d, 0xce, 0x9e, 0xb2, 0x18, 0xc6, 0xb1, 0x46,
	0x73, 0x58, 0x5e, 0x6f, 0x37, 0xf6, 0x8f, 0xcf, 0x58, 0x98, 0x62, 0xbd, 0xa6, 0xa8, 0x67, 0x62,
	0x41, 0x3b, 0x3a, 0x61, 0x93, 0xd3, 0x64, 0x71, 0x06, 0xab, 0x54, 0x9b, 0x2a, 0xd8, 0xfe, 0x3c,
	0xa9, 0x3c, 0xde, 0xf7, 0x60, 0x65, 0x6a, 0x6e, 0x5d, 0x41, 0xad, 0x08, 0x88, 0xfe, 0x78, 0xdf,
	0xa3, 0xbc, 0xcc, 0x7e, 0x40, 0x1a, 0x7b, 0x63, 0xae, 0xaf, 0xc4, 0xd1, 0x0c, 0x96, 0xa7, 0xe6,
	0xd6, 0x1b, 0x7a, 0x45, 0x55, 0x48, 0xb3, 0x7a, 0xce, 0x53, 0x52, 0x97, 0x5f, 0xe1, 0x0b, 0xd8,
	0x18, 0x15, 0xb3, 0x1a, 0xe5, 0x8f, 0x7c, 0xc4, 0x76, 0xf6, 0x3d, 0xa1, 0xde, 0xd4, 0x29, 0x3c,
	0xf3, 0x31, 0xee, 0x4c, 0x4e, 0xdd, 0x68, 0x16, 0x4c, 0xce, 0xa5, 0xe2, 0xa5, 0x10, 0x30, 0xc6,
	0x1f, 0xed, 0xbb, 0x38, 0x70, 0xf0, 0xcc, 0xb5, 0xd5, 0x0d, 0xb3, 0x05, 0x9c, 0x25, 0x3b, 0xdd,
	0x6e, 0x14, 0x26, 0x69, 0xec, 0x07, 0xa1, 0xd0, 0x6e, 0xea, 0xd4, 0xc0, 0x71, 0xc1, 0x44, 0x7b,
	0x0f, 0x87, 0x51, 0xcc, 0x5c, 0xb7, 0x77, 0x80, 0x6d, 0xd0, 0x51, 0xf6, 0x3d, 0x52, 0x39, 0xdc,
	0x1b, 0x43, 0x23, 0x9a, 0x5b, 0x9b, 0x85, 0x7d, 0x3d, 0xdc, 0x1b, 0x53, 0x5e, 0xc9, 0xfe, 0x22,
	0x29, 0xef, 0x8d, 0xa1, 0x59, 0xcd, 0xad, 0x9b, 0x85, 0x55, 0xf7, 0xc6, 0xb4, 0xbc, 0x37, 0x76,
	0x7e, 0xad, 0x4c, 0xae, 0x2e, 0x7d, 0x83, 0xd3, 0x66, 0x48, 0x1f, 0x63, 0x3b, 0xf9, 0x23, 0x1f,
	0xd5, 0x83, 0x30, 0xe1, 0xbd, 0x0e, 0x52, 0x36, 0x1d, 0xee, 0x6e, 0x63, 0x0b, 0x73, 0x58, 0x78,
	0xd3, 0xeb, 0x23, 0xa5, 0xf8, 0x23, 0x6f, 0x36, 0xaf, 0x5e, 0x7d, 0x49, 0xb3, 0x87, 0xbb, 0xdb,
	0x94, 0x57, 0xe2, 0xd2, 0xb1, 0x1b, 0x9d, 0xcd, 0x39, 0xc3, 0xb1, 0x29, 0xff, 0x8e, 0x60, 0x7b,
	0x13, 0x09, 0x9c, 0x38, 0xde, 0xee, 0xf6, 0xc3, 0x29, 0xea, 0x61, 0xc0, 0xff, 0x75, 0x9a, 0xc3,
	0xf2, 0xd1, 0x19, 0xee, 0x7a, 0x7d, 0x98, 0x01, 0x35, 0x0a, 0xcf, 0xbc, 0x7d, 0x0f, 0xfb, 0x3d,
	0x60, 0xfc, 0x1a, 0xe5, 0x8f, 0x7c, 0x9e, 0x75, 0xa3, 0x69, 0x10, 0x1e, 0xc3, 0x6c, 0x6d, 0x88,
	0x79, 0x96, 0x61, 0x80, 0x9f, 0x9f, 0x8e, 0x3f, 0xda, 0x66, 0xfe, 0xd9, 0x51, 0x14, 0x9f, 0xb1,
	0x29, 0xf0, 0x7d, 0x9d, 0xe6, 0xb0, 0xce, 0x2f, 0x95, 0x89, 0x95, 0x27, 0xb1, 0x3d, 0x26, 0xd7,
	0xb9, 0x82, 0xda, 0x99, 0xfa, 0x73, 0x68, 0x93, 0x64, 0xd8, 0x12, 0x50, 0xe3, 0xae, 0x4e, 0x8d,
	0xa2, 0x7a, 0xb4, 0xf0, 0x6d, 0xbe, 0x3c, 0x74, 0xfd, 0x59, 0xf0, 0x54, 0xc8, 0x02, 0x37, 0x4a,
	0x02, 0xa0, 0x82, 0x90, 0x34, 0x45, 0x45, 0xb9, 0x37, 0xe4, 0x8c, 0xc5, 0x61, 0x2a, 0x2a, 0xe2,
	0xfc, 0xd8, 0xf5, 0xfa, 0x5e, 0xca, 0x58, 0x1c, 0x84, 0xc7, 0xc8, 0xe1, 0x3a, 0xca, 0x7e, 0x97,
	0x5c, 0x19, 0xf5, 0xdc, 0x4e, 0x18, 0x46, 0x8b, 0x70, 0xc2, 0xf8, 0xcc, 0x46, 0x03, 0x23, 0x8f,
	0xe6, 0x44, 0xef, 0xed, 0xf4, 0x71, 0x94, 0xf8, 0xa3, 0xc3, 0xf2, 0x5c, 0xc7, 0x47, 0xff, 0x06,
	0x59, 0xe3, 0x1a, 0xd2, 0xd8, 0xc3, 0x49, 0x89, 0x10, 0xc7, 0x1f, 0xee, 0x8d, 0x87, 0x5d, 0x0f,
	0x7b, 0x88, 0x90, 0xbd, 0x41, 0xca, 0xdb, 0x4f, 0xb0, 0x0f, 0xe5, 0xed, 0x27, 0xfc, 0x37, 0xde,
	0x88, 0x62, 0x53, 0xf9, 0xa3, 0xf3, 0x0b, 0x25, 0xf2, 0xe6, 0x4a, 0xe2, 0x82, 0x04, 0xc8, 0xb8,
	0x7c, 0x4c, 0x1f, 0x4b, 0xbe, 0x2f, 0x67, 0x7c, 0xbf, 0xcc, 0xcf, 0x92, 0xab, 0xaa, 0x26, 0x57,
	0x71, 0x1e, 0x5f, 0xc3, 0x5a, 0xc0, 0xc9, 0xd5, 0x8e, 0xb7, 0x33, 0x00, 0x8a, 0x34, 0xb7, 0x2c,
	0x7d, 0xa0, 0x39, 0x9e, 0x42, 0xa9, 0xf3, 0x35, 0xd2, 0x50, 0x28, 0xb0, 0x6d, 0xa3, 0xb3, 0x33,
	0x3f, 0x9c, 0x62, 0xff, 0x25, 0xa8, 0xec, 0x3b, 0x5c, 0x4a, 0xf8, 0xb3, 0xf3, 0x2f, 0x4b, 0xc4,
	0xe6, 0xbd, 0x1a, 0xf8, 0xe7, 0x2c, 0xee, 0x05, 0xc9, 0x24, 0x7a, 0xc6, 0xe2, 0xf3, 0x0b, 0xd6,
	0xa4, 0x2d, 0xd2, 0xe8, 0x9e, 0xf8, 0x49, 0x12, 0x24, 0xfd, 0x1e, 0x7c, 0xad, 0xb9, 0x75, 0x1d,
	0x9b, 0x36, 0x18, 0xf4, 0x5c, 0x55, 0x46, 0xb3, 0x6a, 0xf6, 0x0f, 0x92, 0x35, 0x6e, 0x56, 0xf4,
	0x7b, 0x28, 0x79, 0xae, 0x6a, 0x2f, 0x88, 0x02, 0x8a, 0x15, 0x80, 0xa0, 0xe3, 0x81, 0x1c, 0x80,
	0xf1, 0x78, 0x60, 0x7f, 0x48, 0xd6, 0x0e, 0xfd, 0xd9, 0x82, 0x71, 0xdb, 0xb3, 0xf2, 0x6e, 0x73,
	0xeb, 0x8e, 0x7c, 0x79, 0xa9, 0xe5, 0x50, 0x8d, 0x62, 0x6d, 0xe7, 0x6b, 0xa4, 0x6d, 0x34, 0x08,
	0xcc, 0xa3, 0xc5, 0x53, 0xfe, 0xb2, 0x24, 0x0e, 0x82, 0x9c, 0x0b, 0xb0, 0x33, 0x2d, 0x5a, 0xee,
	0xf7, 0x9c, 0x0f, 0x09, 0xc9, 0x9a, 0xf6, 0x0a, 0xef, 0xfd, 0x38, 0xb9, 0xb9, 0xa2, 0x55, 0x6a,
	0x29, 0x2f, 0x69, 0x4b, 0xf9, 0x0d, 0xb2, 0x36, 0x60, 0xe1, 0x71, 0x7a, 0x22, 0x99, 0x52, 0x40,
	0x7c, 0x31, 0x87, 0x97, 0x80, 0x5a, 0x2d, 0x2a, 0x00, 0xa7, 0x4f, 0x9a, 0x52, 0x5d, 0xed, 0x8e,
	0x2f, 0xd2, 0x2d, 0x6f, 0x93, 0x86, 0x77, 0x1a, 0xcc, 0xbb, 0xd1, 0x22, 0x4c, 0xf1, 0xeb, 0x19,
	0xc2, 0xf9, 0x93, 0x25, 0x62, 0x69, 0xdf, 0xa2, 0x6c, 0x3e, 0x3b, 0xbf, 0x58, 0x5d, 0xda, 0x5d,
	0x84, 0x13, 0x4d, 0x48, 0x28, 0x98, 0x8b, 0x5c, 0xca, 0x26, 0x2c, 0x98, 0xcb, 0xd5, 0x5a, 0xb0,
	0xba, 0x89, 0x2c, 0xf2, 0x30, 0x38, 0x7f, 0xb6, 0x42, 0x6e, 0x2c, 0x53, 0xac, 0x1f, 0x1e, 0x45,
	0x17, 0x34, 0xe7, 0x5d, 0x72, 0x85, 0x8f, 0x4e, 0x8f, 0x25, 0x93, 0x38, 0x98, 0xab, 0x56, 0x35,
	0x68, 0x1e, 0x0d, 0xa3, 0x77, 0x9e, 0x8c, 0xfc, 0x33, 0x86, 0x26, 0x81, 0x04, 0x61, 0x0d, 0x38,
	0x4f, 0xf4, 0x4f, 0xa0, 0x21, 0x6f, 0x62, 0xed, 0x1e, 0xb9, 0xe2, 0x9d, 0x27, 0x5d, 0x7f, 0xee,
	0x3f, 0x0d, 0x66, 0x41, 0x1a, 0xb0, 0x04, 0xa7, 0xe4, 0x2d, 0x8d, 0x8d, 0x73, 0x35, 0x68, 0xfe,
	0x15, 0xfb, 0xab, 0xa4, 0x39, 0x3c, 0x3e, 0x4b, 0xa5, 0x02, 0xbb, 0x06, 0x5f, 0xb8, 0xa1, 0x7d,
	0x41, 0x2b, 0xa5, 0x7a, 0x55, 0xfb, 0x01, 0x59, 0xdf, 0x8f, 0x8f, 0xc7, 0x83, 0x43, 0xae, 0x74,
	0xf3, 0x19, 0xf0, 0xa6, 0xf6, 0xd6, 0x7e, 0x7c, 0xec, 0xcd, 0xd9, 0x24, 0x38, 0x0a, 0x26, 0xe3,
	0xc1, 0x21, 0x95, 0x35, 0xed, 0xaf, 0x92, 0xf5, 0x83, 0xf0, 0x34, 0x8c, 0x9e, 0x87, 0x9b, 0xf5,
	0x4b, 0x4d, 0x1b, 0x59, 0xdd, 0xf9, 0x5e, 0x89, 0x5c, 0x2b, 0xe8, 0x91, 0xfd, 0xc3, 0xa4, 0xe1,
	0x9d, 0x27, 0x29, 0x3b, 0xeb, 0xfa, 0x73, 0x5c, 0x7c, 0x6e, 0xea, 0x13, 0x5f, 0xef, 0x7d, 0x56,
	0xd3, 0xfe, 0x11, 0x42, 0x76, 0x42, 0xff, 0xe9, 0x8c, 0x4d, 0xf9, 0x7b, 0xe5, 0x97, 0xbf, 0xa7,
	0x55, 0x75, 0x7e, 0xbe, 0x4c, 0xac, 0x7c, 0x05, 0x3e, 0x35, 0xf6, 0x39, 0xe3, 0xa2, 0xc4, 0x15,
	0x00, 0x67, 0x4e, 0xca, 0xe6, 0xcc, 0x4f, 0x59, 0x8c, 0x82, 0x57, 0xc1, 0x7c, 0x92, 0x6d, 0xc7,
	0xc1, 0xf4, 0x58, 0x6a, 0xf1, 0x08, 0x71, 0xfc, 0x93, 0x41, 0x67, 0xd4, 0x11, 0x9a, 0x57, 0x9d,
	0x22, 0xc4, 0xf1, 0x34, 0x5a, 0xf0, 0x2f, 0x89, 0x95, 0x08, 0x21, 0xd0, 0xbb, 0x4f, 0xa2, 0x90,
	0xe1, 0x12, 0x24, 0x00, 0xb0, 0x37, 0xa3, 0x89, 0x17, 0x08, 0x7b, 0xa8, 0x4e, 0x11, 0xe2, 0x4b,
	0x9f, 0x97, 0xc2, 0x4a, 0xb1, 0x1f, 0xce, 0xce, 0x41, 0x57, 0xa8, 0x53, 0x1d, 0xc5, 0xbf, 0xd7,
	0xe5, 0xa6, 0x02, 0xa8, 0x0b, 0x75, 0x2a, 0x00, 0x70, 0xec, 0x00, 0x56, 0x28, 0x08, 0x02, 0x00,
	0xe1, 0x31, 0x74, 0x29, 0x68, 0xc1, 0x75, 0x0a, 0xcf, 0xce, 0x2f, 0x97, 0xc8, 0x95, 0x1c, 0xdb,
	0xbc, 0x44, 0x52, 0x6d, 0x92, 0x75, 0xc9, 0x79, 0x42, 0x5c, 0x49, 0xd0, 0xbe, 0x47, 0xac, 0x7e,
	0x98, 0xb2, 0xf8, 0xc8, 0x9f, 0x30, 0xf9, 0xb2, 0x98, 0xbf, 0x4b, 0x78, 0x3e, 0xeb, 0x14, 0x0e,
	0xa7, 0x7a, 0x15, 0xd4, 0xee, 0x3c, 0x9a, 0x8b, 0xf1, 0x7d, 0x34, 0x39, 0x1a, 0x94, 0x3f, 0x3a,
	0x63, 0x62, 0x2f, 0xf3, 0x2b, 0xd4, 0x3b, 0xe8, 0x43, 0x6b, 0xdb, 0x94, 0x3f, 0x62, 0x1f, 0x34,
	0xb3, 0x47, 0x82, 0x9c, 0x0a, 0x5c, 0x32, 0xa0, 0x54, 0x84, 0x67, 0xe7, 0x0f, 0x2a, 0xa4, 0xda,
	0x77, 0x9f, 0x7d, 0x70, 0x81, 0xb8, 0xd0, 0xdc, 0xb2, 0xf8, 0x51, 0xe9, 0x96, 0xb5, 0x48, 0xa5,
	0xbf, 0x37, 0x90, 0x8b, 0x73, 0x7f, 0x6f, 0x00, 0x2b, 0xd0, 0xbe, 0xa7, 0x56, 0xa0, 0x7d, 0x4f,
	0x93, 0xd3, 0x35, 0x43, 0x4e, 0x73, 0xf1, 0x3f, 0xc5, 0x15, 0xbb, 0xdc, 0x9f, 0x66, 0x46, 0xd8,
	0x7a, 0xce, 0x08, 0xe3, 0x66, 0xcb, 0xfe, 0xd1, 0x51, 0xc2, 0x52, 0xd4, 0x1a, 0x35, 0x8c, 0x5c,
	0xf1, 0x1a, 0xd9, 0x8a, 0xa7, 0x1b, 0xff, 0x24, 0x67, 0xfc, 0xeb, 0x26, 0x8f, 0x30, 0x8a, 0x32,
	0x93, 0x47, 0x79, 0x05, 0x5b, 0x85, 0x2e, 0xd7, 0x76, 0xce, 0xf7, 0xe7, 0xfa, 0x53, 0xae, 0xa1,
	0x82, 0xe5, 0xd3, 0xa2, 0x12, 0xb4, 0xbf, 0x44, 0xd6, 0xf7, 0x41, 0xf0, 0x25, 0x9b, 0x57, 0x40,
	0x72, 0xc8, 0xd5, 0x9a, 0xd3, 0x59, 0x94, 0x50, 0x59, 0xa3, 0xc0, 0x67, 0x62, 0x5d, 0xc6, 0x67,
	0x72, 0x75, 0xc9, 0x67, 0xa2, 0x3b, 0x2f, 0xed, 0x95, 0x3e, 0xe0, 0x6b, 0xa6, 0x0f, 0x78, 0x4e,
	0x48, 0xd6, 0x28, 0x4e, 0x68, 0xf1, 0xa4, 0x2d, 0xb4, 0x1a, 0x86, 0x9b, 0x50, 0x02, 0x32, 0x16,
	0x5d, 0x03, 0x97, 0x7d, 0x03, 0x96, 0x2a, 0xc1, 0x69, 0x1a, 0xc6, 0xf9, 0xeb, 0x82, 0xdf, 0x3e,
	0x7c, 0x6d, 0x7e, 0x73, 0x48, 0x6b, 0x1c, 0xfb, 0x47, 0x47, 0xc1, 0xa4, 0x3b, 0xf3, 0x93, 0x04,
	0x19, 0xcf, 0xc0, 0xf1, 0x6f, 0xef, 0xce, 0xa2, 0xe7, 0x03, 0xff, 0x29, 0x9b, 0xe1, 0x04, 0xcb,
	0x10, 0x2b, 0xb9, 0xf1, 0x0e, 0x21, 0x23, 0xf6, 0x22, 0x15, 0xbb, 0x1c, 0xc8, 0x95, 0x1a, 0x86,
	0x73, 0xce, 0x5e, 0x34, 0x1f, 0x04, 0x67, 0x41, 0x8a, 0x0c, 0xaa, 0xe0, 0x15, 0xfe, 0x64, 0xc5,
	0x39, 0x0d, 0x9d, 0x73, 0x96, 0x87, 0x9c, 0x5c, 0x66, 0xc8, 0x9b, 0xcb, 0x43, 0xfe, 0x43, 0xd0,
	0xa2, 0xed, 0xf3, 0xbd, 0x68, 0x0e, 0x2c, 0xdb, 0xdc, 0xba, 0x96, 0xb1, 0xda, 0x87, 0xb2, 0x88,
	0xaa, 0x4a, 0x3a, 0x8f, 0xb4, 0x57, 0xf2, 0xc8, 0x86, 0xc9, 0x23, 0xbf, 0x5d, 0x26, 0x2d, 0xfe,
	0x39, 0xe9, 0x3a, 0xb8, 0x60, 0xe4, 0x4c, 0x2a, 0x96, 0x97, 0xa8, 0x78, 0x9b, 0x34, 0x28, 0x4b,
	0x58, 0xfc, 0x8c, 0x4d, 0xdf, 0x97, 0xc6, 0xbc, 0x42, 0xe8, 0x8e, 0x0b, 0x9c, 0xef, 0x55, 0xd3,
	0x71, 0x81, 0x73, 0x5e, 0xfb, 0xca, 0x16, 0x0e, 0x63, 0x86, 0xe0, 0xfa, 0x14, 0xb7, 0xd8, 0xe5,
	0x3b, 0x09, 0x2e, 0x39, 0x26, 0x92, 0xff, 0x4b, 0xba, 0x99, 0xd0, 0x84, 0x5d, 0x07, 0x56, 0xc9,
	0x61, 0x75, 0xa2, 0xd5, 0x57, 0x12, 0xad, 0x61, 0x10, 0x2d, 0xe3, 0x07, 0x52, 0xc8, 0x0f, 0x4d,
	0x8d, 0x1f, 0x9c, 0xbf, 0x5a, 0x22, 0x6b, 0xfd, 0xee, 0xf0, 0x62, 0x21, 0x7c, 0x8b, 0xd4, 0xf9,
	0x3c, 0xec, 0x46, 0x53, 0xe5, 0xef, 0x94, 0xb0, 0x21, 0xd6, 0x2a, 0x39, 0xb1, 0x26, 0xc4, 0x6c,
	0x55, 0x89, 0x59, 0x6e, 0xa3, 0xb1, 0x4f, 0x90, 0x6c, 0xfc, 0x31, 0x6b, 0xee, 0x5a, 0x61, 0x73,
	0xd7, 0xf5, 0xe6, 0xfe, 0x69, 0xd9, 0xdc, 0x0f, 0x3f, 0xa5, 0xe6, 0xaa, 0xc6, 0x54, 0x0b, 0x1b,
	0x53, 0xd3, 0x1b, 0xf3, 0x9b, 0x25, 0xf2, 0x96, 0x68, 0xcc, 0x88, 0x05, 0xc7, 0x27, 0x4f, 0xa3,
	0xb8, 0x33, 0x7d, 0xc6, 0xe2, 0x34, 0x48, 0xd8, 0x25, 0x78, 0x55, 0xad, 0x37, 0x65, 0x7d, 0xbd,
	0x79, 0x9b, 0xb4, 0xc7, 0x7e, 0x7c, 0xcc, 0x94, 0xaa, 0x29, 0xd4, 0x5e, 0x13, 0x69, 0x7f, 0x39,
	0x93, 0xf2, 0x55, 0x90, 0xf2, 0x6a, 0xea, 0x41, 0x73, 0xf2, 0x72, 0x5e, 0x75, 0xaa, 0x56, 0xd8,
	0xa9, 0x35, 0xbd, 0x53, 0x7f, 0xbb, 0x4c, 0xde, 0x14, 0x5f, 0x11, 0xaa, 0xd3, 0xab, 0x74, 0x49,
	0x17, 0x52, 0xe5, 0x65, 0x21, 0x25, 0xba, 0x5b, 0xd1, 0xbb, 0xfb, 0x0e, 0xd9, 0x10, 0xbf, 0x19,
	0x04, 0x47, 0x2c, 0x0d, 0xce, 0xa4, 0x3b, 0x3c, 0x87, 0x15, 0x46, 0x8a, 0x3f, 0x39, 0xe1, 0xfa,
	0x25, 0xff, 0x1f, 0xf4, 0xa4, 0x4d, 0x4d, 0x24, 0x17, 0xcf, 0x94, 0xa5, 0xb1, 0x1f, 0x26, 0x1c,
	0x14, 0x62, 0xb4, 0x4d, 0x0d, 0x9c, 0x4e, 0xba, 0xf5, 0x57, 0x21, 0xdd, 0xc5, 0xb2, 0xd5, 0xf9,
	0x90, 0xb4, 0xf4, 0x8f, 0x14, 0x5a, 0x8d, 0xba, 0x25, 0x2f, 0xed, 0xa8, 0xbf, 0x58, 0x26, 0x95,
	0x83, 0x9e, 0x7b, 0xf1, 0xaa, 0x24, 0x25, 0x41, 0x79, 0xa5, 0x24, 0xa8, 0x98, 0x92, 0x20, 0x5b,
	0x6d, 0xaa, 0xc6, 0x6a, 0xa3, 0xcf, 0x80, 0x5a, 0x6e, 0x06, 0x2c, 0xaf, 0x10, 0x6b, 0x97, 0x59,
	0x21, 0xd6, 0x0b, 0x95, 0x02, 0x04, 0x81, 0x7a, 0xa0, 0xa5, 0x00, 0x98, 0x51, 0xb5, 0x51, 0x48,
	0x55, 0x7d, 0x9f, 0xd3, 0xf9, 0x77, 0x55, 0x52, 0x19, 0x77, 0x3f, 0x25, 0xea, 0x78, 0xec, 0x93,
	0xd1, 0xe2, 0x0c, 0x97, 0x69, 0x84, 0x38, 0xbe, 0x33, 0x39, 0x1d, 0x21, 0x6d, 0xda, 0x14, 0x21,
	0x70, 0xc8, 0xfb, 0xa9, 0x8f, 0x6b, 0x03, 0xae, 0xd1, 0x19, 0x86, 0x8b, 0xb6, 0xdd, 0xfe, 0x08,
	0x6d, 0x09, 0xfe, 0x08, 0xc2, 0xee, 0x3b, 0x23, 0x34, 0x20, 0xf8, 0x23, 0xc7, 0x50, 0x6f, 0x8c,
	0x66, 0x03, 0x7f, 0xe4, 0x18, 0xd7, 0xdb, 0x43, 0x93, 0x81, 0x3f, 0x72, 0x4c, 0xa7, 0xfb, 0x08,
	0xed, 0x05, 0xfe, 0x08, 0x7b, 0xad, 0xf4, 0x21, 0x2c, 0xb3, 0x75, 0xca, 0x1f, 0x39, 0x66, 0xa7,
	0xbb, 0x03, 0x0b, 0x69, 0x9d, 0xf2, 0x47, 0x8e, 0xe9, 0x3e, 0xa1, 0xb0, 0x80, 0xd6, 0x29, 0x7f,
	0xe4, 0xa2, 0x77, 0xe4, 0xc1, 0x06, 0x6d, 0x9d, 0x96, 0x47, 0xa0, 0x09, 0x8b, 0xfd, 0x3a, 0x50,
	0xf3, 0x6a, 0x14, 0x21, 0x83, 0x1b, 0xae, 0xe6, 0xb8, 0xe1, 0x06, 0x59, 0x3b, 0x88, 0x8f, 0xe5,
	0x26, 0x6c, 0x8d, 0x22, 0xa4, 0x6b, 0xa0, 0xd7, 0x4c, 0x0d, 0xf4, 0x5e, 0x36, 0xc1, 0xae, 0xc3,
	0x04, 0x93, 0xbe, 0xaf, 0x71, 0xd7, 0xbd, 0x58, 0x01, 0x7d, 0xe3, 0x32, 0xbc, 0x76, 0xe3, 0xa5,
	0xbc, 0x76, 0x73, 0x05, 0xaf, 0x6d, 0x16, 0xf2, 0xda, 0x9b, 0x3a, 0xaf, 0x45, 0xa4, 0xa1, 0x5a,
	0xf9, 0x7f, 0x44, 0x23, 0xfd, 0xf5, 0x12, 0xa9, 0x7a, 0x17, 0x3b, 0x84, 0x5e, 0x87, 0xbb, 0xdf,
	0x25, 0x57, 0x0e, 0x59, 0xac, 0x34, 0x89, 0xb1, 0x7f, 0x2c, 0xcd, 0xbd, 0x1c, 0x7a, 0x49, 0x1a,
	0xb4, 0x8b, 0xd6, 0xc3, 0x4b, 0x2c, 0xce, 0xff, 0xb5, 0x4a, 0x2a, 0xbd, 0x91, 0x77, 0x41, 0x5f,
	0x32, 0xb7, 0x1b, 0x57, 0x08, 0x7a, 0x1c, 0x7e, 0x4c, 0xd1, 0xbc, 0x2f, 0x3f, 0xa6, 0x9c, 0xe3,
	0xf6, 0xe7, 0xb0, 0x6e, 0xa3, 0xcc, 0x12, 0x10, 0xaf, 0xd7, 0xe9, 0xa0, 0x59, 0x5f, 0xee, 0x74,
	0x38, 0x3c, 0xee, 0xa2, 0x72, 0x55, 0x1e, 0x77, 0x39, 0x4c, 0x7b, 0x38, 0xf9, 0xca, 0x14, 0xbe,
	0x4b, 0x3b, 0x38, 0xf5, 0xca, 0xb4, 0x63, 0xb7, 0x48, 0xe9, 0xbb, 0xa8, 0x29, 0x95, 0xbe, 0x2b,
	0x96, 0x8a, 0x64, 0x1e, 0x85, 0x89, 0xd0, 0x11, 0x84, 0xa5, 0x66, 0xe0, 0x38, 0x6d, 0x1f, 0xf7,
	0x84, 0x13, 0x4e, 0xe8, 0xbf, 0x12, 0x04, 0x83, 0x7c, 0x24, 0x4a, 0x44, 0x7c, 0x85, 0x04, 0x79,
	0xc9, 0xc8, 0x13, 0x25, 0xa8, 0xe4, 0x22, 0x08, 0xef, 0x50, 0x51, 0x82, 0x4a, 0x2e, 0x82, 0xf6,
	0x57, 0x48, 0xe3, 0xf1, 0x82, 0x25, 0xba, 0xd5, 0x66, 0x4b, 0x7f, 0xf1, 0xc8, 0x93, 0x45, 0x34,
	0xab, 0x64, 0x6f, 0x91, 0xf5, 0x4e, 0x98, 0x3c, 0x67, 0x71, 0xb2, 0x69, 0x41, 0xfd, 0xcd, 0xac,
	0x3e, 0x65, 0x09, 0x84, 0x3b, 0x51, 0x36, 0x89, 0xe2, 0x29, 0x95, 0x15, 0xed, 0xaf, 0x93, 0x66,
	0x67, 0x91, 0x9e, 0x44, 0xb1, 0x70, 0x82, 0x5d, 0xbd, 0xe0, 0x3d, 0xbd, 0x32, 0xbc, 0x3b, 0x9d,
	0xc2, 0x4e, 0x82, 0x3f, 0x4b, 0x36, 0xed, 0x0b, 0xdf, 0xcd, 0x2a, 0x67, 0x1c, 0x74, 0xad, 0x90,
	0x83, 0xae, 0xaf, 0x08, 0x25, 0x7a, 0x63, 0x25, 0x9f, 0xdf, 0x30, 0x4d, 0x84, 0x7f, 0x5e, 0x26,
	0x57, 0x97, 0x9a, 0xc0, 0xd7, 0x59, 0xf0, 0x1a, 0x8a, 0xf8, 0x25, 0x78, 0x5e, 0xb5, 0x21, 0xab,
	0x9b, 0x72, 0x02, 0xd0, 0xfd, 0xd8, 0x6d, 0x61, 0xd5, 0xa3, 0xec, 0x37, 0x6c, 0x37, 0x0d, 0xa3,
	0xd6, 0xf5, 0x35, 0x2d, 0x02, 0x8b, 0x73, 0xba, 0x9c, 0x22, 0xe5, 0xbe, 0x8b, 0xf2, 0x58, 0x2c,
	0x85, 0x5c, 0x1e, 0xf3, 0x7f, 0x8f, 0x3a, 0xc3, 0x1d, 0xe0, 0xca, 0x16, 0x15, 0x00, 0xac, 0x07,
	0x63, 0x0a, 0x0c, 0xd9, 0xa2, 0xfc, 0xd1, 0xfe, 0x1c, 0xa9, 0x78, 0xfb, 0x1d, 0xe0, 0xc1, 0xe6,
	0x56, 0x3b, 0xa3, 0xba, 0xb7, 0xdf, 0xa1, 0xbc, 0x04, 0x2a, 0xd0, 0x43, 0xb4, 0xc2, 0xf4, 0x0a,
	0xf4, 0x90, 0xf2, 0x12, 0xfb, 0x36, 0x29, 0x0f, 0x3f, 0xc2, 0xdd, 0xd4, 0x56, 0x56, 0x3e, 0xfc,
	0x88, 0x96, 0x87, 0x1f, 0x89, 0x4d, 0xcc, 0x71, 0xb2, 0xb9, 0x71, 0xb7, 0xc2, 0xdb, 0xce, 0x9f,
	0x9d, 0xbf, 0x56, 0x22, 0x6b, 0xe2, 0x17, 0xbc, 0x99, 0x43, 0x45, 0xcb, 0x16, 0x15, 0x00, 0xc7,
	0x52, 0xc0, 0x0a, 0x4d, 0x46, 0x00, 0x62, 0x49, 0x8d, 0x03, 0x5f, 0xc4, 0x3d, 0xc0, 0x92, 0xca,
	0x21, 0x3e, 0x7c, 0x94, 0x1d, 0xc5, 0x2c, 0x39, 0x41, 0xa2, 0x4a, 0x10, 0xbe, 0xc3, 0xd2, 0xf8,
	0x1c, 0x25, 0x8f, 0x00, 0xf8, 0x77, 0x76, 0x5e, 0xcc, 0x83, 0x98, 0xa1, 0x0e, 0x87, 0x10, 0xff,
	0xce, 0x30, 0x08, 0x83, 0xb3, 0xc5, 0x19, 0xda, 0x4b, 0x12, 0x74, 0xa6, 0xa2, 0xbd, 0xf4, 0xd0,
	0x88, 0x0d, 0x28, 0xe5, 0x62, 0x03, 0xf8, 0x12, 0xc8, 0x75, 0x75, 0x29, 0x47, 0x11, 0xe2, 0x24,
	0xd0, 0x64, 0x28, 0x3c, 0x2b, 0x16, 0x42, 0x97, 0x37, 0x7f, 0x76, 0xbe, 0x41, 0x6a, 0x40, 0x37,
	0xce, 0x0f, 0x6e, 0xcc, 0x8e, 0x58, 0x0c, 0xdb, 0x68, 0xb8, 0x38, 0x64, 0x18, 0xf5, 0x72, 0x39,
	0xe3, 0x3f, 0xe7, 0x11, 0x69, 0x6a, 0xf3, 0xf9, 0x0f, 0xc7, 0xa2, 0xce, 0xef, 0x57, 0xc9, 0x5a,
	0x6f, 0xaf, 0x7b, 0xb1, 0xe1, 0x66, 0x04, 0x86, 0x94, 0x0b, 0x02, 0x43, 0xf6, 0xfc, 0x78, 0xfa,
	0xdc, 0x8f, 0xd9, 0x38, 0x73, 0x1e, 0x1a, 0x38, 0xbe, 0xfa, 0x4a, 0x78, 0xc0, 0x42, 0xb9, 0x13,
	0xa8, 0xa1, 0xf4, 0xaf, 0xec, 0xcf, 0xd3, 0x04, 0xe7, 0x87, 0x81, 0xe3, 0x7c, 0xfd, 0x51, 0x30,
	0xc5, 0xf1, 0xe4, 0x8f, 0xbc, 0xb3, 0x1e, 0x9b, 0x48, 0x87, 0x1b, 0x3c, 0x67, 0x66, 0x42, 0x5d,
	0x37, 0x13, 0xb2, 0x40, 0x4a, 0xa9, 0x32, 0x2a, 0x98, 0xff, 0xfb, 0x3b, 0xd1, 0x22, 0x56, 0xe5,
	0x42, 0x79, 0x34, 0x70, 0x22, 0x32, 0xf0, 0x45, 0x2a, 0x22, 0xc0, 0x94, 0x09, 0x6c, 0xe0, 0xc4,
	0x8a, 0x30, 0xf3, 0xcf, 0x3b, 0xc7, 0xe2, 0x3b, 0xc2, 0x0d, 0x67, 0xe0, 0x78, 0x1d, 0xf1, 0xcd,
	0xbd, 0x27, 0xdc, 0x14, 0x43, 0xa7, 0x9c, 0x81, 0xe3, 0x9c, 0x21, 0xbe, 0x09, 0x83, 0x2b, 0xdc,
	0x73, 0x1a, 0x86, 0xf7, 0x7a, 0x37, 0x98, 0x31, 0xd0, 0xcb, 0x5a, 0x14, 0x9e, 0x75, 0xaf, 0x9d,
	0x65, 0x78, 0xed, 0xf8, 0x08, 0xe7, 0x95, 0xa6, 0xbb, 0xa4, 0xb9, 0x1b, 0x84, 0xc7, 0x2c, 0x9e,
	0xc7, 0x41, 0x98, 0x82, 0xc6, 0xd6, 0xa0, 0x3a, 0x2a, 0x13, 0xb9, 0x76, 0xa1, 0xc8, 0xbd, 0xb6,
	0x42, 0xe4, 0x5e, 0x5f, 0x29, 0x72, 0xdf, 0x30, 0x45, 0xee, 0x80, 0x90, 0xac, 0x61, 0xaf, 0xb4,
	0x39, 0x26, 0xc5, 0xa4, 0xb0, 0x6a, 0x85, 0xf9, 0xf3, 0x1f, 0xca, 0xc8, 0xc9, 0x97, 0xf0, 0xcb,
	0x0d, 0x93, 0x63, 0xdd, 0xb9, 0x8c, 0x20, 0x1a, 0x9e, 0x62, 0x71, 0xad, 0x28, 0xc3, 0x53, 0xac,
	0xae, 0xb7, 0x48, 0x5d, 0x6c, 0xfe, 0x4e, 0x63, 0x34, 0xea, 0x15, 0x0c, 0xa2, 0x82, 0x71, 0x1b,
	0x77, 0x1a, 0xa3, 0x6d, 0xac, 0x60, 0xb0, 0xc4, 0xb9, 0xd9, 0xe8, 0x4f, 0x30, 0x02, 0x47, 0x88,
	0x76, 0x13, 0xb9, 0xda, 0x9c, 0x14, 0x3d, 0xba, 0x60, 0xec, 0xea, 0x2f, 0x19, 0xbb, 0x8b, 0x4d,
	0x23, 0x7d, 0xec, 0x9a, 0x2b, 0xc7, 0xae, 0x65, 0x8e, 0xdd, 0x88, 0xb4, 0xf4, 0xa6, 0xf1, 0x11,
	0x01, 0x05, 0x08, 0x47, 0x0f, 0x14, 0x9f, 0x57, 0x19, 0xbd, 0xef, 0x95, 0x48, 0x65, 0x30, 0xe8,
	0x5e, 0x1c, 0x0b, 0xd5, 0xf3, 0x3a, 0xae, 0xda, 0xc0, 0xf6, 0x3a, 0xb0, 0x1c, 0xf6, 0x1f, 0x4a,
	0xc5, 0xaf, 0xff, 0x10, 0xc4, 0x81, 0xd7, 0x51, 0xb1, 0x34, 0x1e, 0xd6, 0xe9, 0x52, 0xa9, 0xf4,
	0x75, 0xa9, 0xd8, 0x22, 0x17, 0x11, 0x14, 0x6b, 0x72, 0x8b, 0x5c, 0x44, 0xf6, 0xfc, 0x5e, 0x95,
	0x54, 0x46, 0x17, 0x2a, 0xd2, 0x6f, 0x93, 0xf6, 0x80, 0xf9, 0x73, 0x8c, 0x11, 0x89, 0xa4, 0x8f,
	0xd0, 0x44, 0xea, 0x0e, 0xe0, 0x8a, 0xe9, 0x00, 0xb6, 0x49, 0x75, 0x98, 0xa9, 0xa6, 0xf0, 0x0c,
	0xa3, 0x90, 0xc6, 0x7e, 0xaa, 0x6c, 0x69, 0x09, 0x8a, 0x55, 0x65, 0x26, 0x9b, 0x0a, 0xcf, 0xbc,
	0x7d, 0x6e, 0xcc, 0x26, 0x41, 0x22, 0x7d, 0x7e, 0x35, 0x9a, 0x21, 0xc0, 0xb5, 0x18, 0x45, 0x69,
	0x8f, 0x0b, 0x1d, 0xe0, 0x8e, 0x36, 0xcd, 0x10, 0xc2, 0x5b, 0x12, 0xa5, 0xbd, 0x20, 0x99, 0x63,
	0xf3, 0x1a, 0xc2, 0x69, 0x68, 0x62, 0x21, 0x94, 0x48, 0xae, 0x44, 0xfd, 0x1e, 0xf0, 0x4c, 0x9b,
	0xea, 0x28, 0xfb, 0x3e, 0xb1, 0x15, 0x98, 0x91, 0x8b, 0x33, 0x51, 0x95, 0x16, 0x94, 0x70, 0x63,
	0x62, 0x3f, 0x0e, 0x8e, 0x83, 0x30, 0xab, 0xdc, 0x82, 0xca, 0x79, 0xb4, 0x7d, 0x8f, 0x58, 0xb0,
	0x73, 0xfc, 0x4c, 0xfb, 0x6e, 0x1b, 0xaa, 0x2e, 0xe1, 0xed, 0xf7, 0xc8, 0x55, 0x98, 0x4d, 0x67,
	0x41, 0x9a, 0x55, 0xde, 0x80, 0xca, 0xcb, 0x05, 0xbc, 0xf7, 0x3b, 0x2f, 0x52, 0x16, 0xf2, 0x2e,
	0x42, 0x60, 0x2f, 0x8a, 0xd0, 0x1c, 0x36, 0x9b, 0x41, 0x56, 0xe1, 0x0c, 0xba, 0xba, 0x62, 0x06,
	0x5d, 0x7a, 0xdf, 0xe2, 0x57, 0xcb, 0xa4, 0xe2, 0xf5, 0xdd, 0xd7, 0xde, 0x44, 0xb8, 0x41, 0xd6,
	0x86, 0x2c, 0x3d, 0x89, 0xa6, 0xc8, 0x5c, 0x08, 0xf1, 0x37, 0x84, 0x9b, 0x5a, 0x38, 0xf5, 0x1a,
	0x54, 0x82, 0x7c, 0x49, 0xe9, 0x27, 0xd2, 0x34, 0xc1, 0xd9, 0xa0, 0x61, 0x96, 0x8c, 0x99, 0xb5,
	0x02, 0x63, 0x86, 0xf3, 0x0e, 0xc2, 0x5e, 0xea, 0xa7, 0x0b, 0x19, 0x03, 0x9a, 0xc3, 0xbe, 0xd2,
	0x66, 0x82, 0x46, 0x3d, 0xb2, 0x92, 0x7a, 0x4d, 0x93, 0x7a, 0x7f, 0xab, 0x4a, 0xaa, 0xfd, 0x87,
	0x43, 0xf7, 0x35, 0x82, 0x27, 0xdf, 0x25, 0x57, 0x86, 0xfe, 0x0b, 0xd9, 0x5e, 0x70, 0x03, 0x56,
	0x04, 0x13, 0xe6, 0xd0, 0x86, 0x45, 0x5b, 0xcd, 0x79, 0x34, 0x1c, 0xd2, 0x7a, 0x18, 0x47, 0x8b,
	0xb9, 0x74, 0xb0, 0x0a, 0xb9, 0x6f, 0xe0, 0xec, 0xaf, 0x92, 0x9b, 0xde, 0x02, 0x02, 0xce, 0x84,
	0x1f, 0xd2, 0x8d, 0xa3, 0x09, 0x4b, 0x92, 0x20, 0x3c, 0x46, 0x83, 0x73, 0x55, 0x31, 0x6f, 0x23,
	0x8d, 0x9e, 0x2e, 0x92, 0x34, 0x64, 0x49, 0x22, 0xe2, 0x40, 0xc4, 0x24, 0xcf, 0xa3, 0x79, 0x3b,
	0x60, 0xdf, 0xf5, 0x99, 0x3f, 0x83, 0xae, 0xd4, 0xa1, 0x2b, 0x06, 0x8e, 0x7f, 0x4d, 0x9c, 0x5d,
	0xc1, 0x86, 0xb1, 0x64, 0xb3, 0x01, 0xac, 0x91, 0x47, 0xdb, 0x5b, 0xe4, 0xba, 0xd8, 0xbc, 0xdd,
	0x3f, 0x82, 0x9e, 0x08, 0x33, 0x28, 0xc1, 0x71, 0x29, 0x2c, 0x83, 0xf8, 0x2d, 0xc4, 0x8b, 0xcf,
	0x25, 0x38, 0x58, 0x79, 0xb4, 0xfd, 0x4d, 0xa4, 0x99, 0xfc, 0x6a, 0xcb, 0x30, 0x00, 0xf9, 0x70,
	0x3e, 0x7b, 0xa0, 0x55, 0xa0, 0x46, 0x6d, 0x7d, 0x2a, 0xb4, 0xcd, 0xa9, 0xa0, 0x98, 0x6d, 0xa3,
	0x90, 0xd9, 0xae, 0xe8, 0xde, 0x85, 0x5f, 0x2b, 0x91, 0xab, 0x4b, 0x7f, 0x2a, 0x54, 0x3e, 0xee,
	0x10, 0xd2, 0x59, 0xbc, 0x40, 0xe3, 0x4c, 0xee, 0x02, 0x65, 0x98, 0xa2, 0x7e, 0x57, 0x8a, 0xfb,
	0x7d, 0x8f, 0x58, 0xc3, 0xc5, 0x2c, 0x0d, 0x26, 0x7e, 0xa2, 0x1c, 0xf2, 0x42, 0x87, 0x58, 0xc2,
	0x17, 0x8d, 0x55, 0xad, 0x70, 0xac, 0x9c, 0x9f, 0x2e, 0x89, 0x4d, 0x2d, 0xb5, 0x33, 0xf6, 0xf2,
	0xa9, 0xf0, 0x20, 0x53, 0x31, 0xca, 0x46, 0x04, 0x89, 0xfe, 0x8d, 0x95, 0x7e, 0xeb, 0x4a, 0x21,
	0x65, 0xab, 0x3a, 0x65, 0xff, 0x7d, 0x89, 0xd8, 0xcb, 0xdf, 0xfa, 0xbe, 0xf8, 0xbf, 0x1c, 0xd2,
	0xea, 0x4c, 0xd2, 0x85, 0x3f, 0xc3, 0x3a, 0x68, 0x5e, 0xe8, 0xb8, 0x9c, 0x8f, 0xac, 0x9a, 0xf7,
	0x91, 0xd9, 0x03, 0x72, 0x45, 0x40, 0x9d, 0x59, 0x70, 0x1c, 0xaa, 0x30, 0xc3, 0xe6, 0x96, 0xb3,
	0x92, 0x0e, 0xaa, 0x26, 0xcd, 0xbf, 0xea, 0x74, 0xc8, 0x5b, 0x2f, 0xa9, 0x0f, 0x21, 0x0d, 0xa1,
	0xec, 0x2d, 0x7f, 0x04, 0x5f, 0xc0, 0xf3, 0x08, 0x7b, 0xc7, 0x1f, 0x9d, 0x13, 0x52, 0xf5, 0x46,
	0x9d, 0x8b, 0x24, 0xd8, 0x7d, 0x62, 0xef, 0xc7, 0xc7, 0x7e, 0x18, 0xfc, 0xa4, 0x2f, 0x5c, 0x21,
	0x6a, 0x2f, 0xaa, 0x45, 0x0b, 0x4a, 0x14, 0x27, 0x57, 0xb4, 0x50, 0xf3, 0x9f, 0x2b, 0x11, 0x22,
	0xb6, 0x14, 0x76, 0x26, 0x27, 0xd1, 0xc5, 0x9b, 0x9f, 0x5a, 0x3c, 0x3b, 0xb2, 0xbd, 0x16, 0xcb,
	0x7e, 0x9b, 0x34, 0x84, 0x83, 0x3b, 0x0b, 0xf2, 0xca, 0x10, 0xaf, 0xb4, 0xf1, 0xf5, 0xab, 0x25,
	0x72, 0xcb, 0xdc, 0xf8, 0xf2, 0x44, 0x08, 0xb0, 0xb0, 0x29, 0x2f, 0x54, 0xc1, 0xcc, 0x1d, 0xae,
	0xf2, 0x05, 0x3b, 0x5c, 0x95, 0x57, 0xd9, 0xa6, 0xb9, 0x44, 0xeb, 0x7f, 0xb6, 0x44, 0x36, 0xf5,
	0x1d, 0xae, 0x57, 0x68, 0xfb, 0x97, 0xf3, 0x53, 0xf1, 0x92, 0xad, 0xba, 0xc4, 0x24, 0xfc, 0x4d,
	0x42, 0xaa, 0x7b, 0xe3, 0x0b, 0x15, 0x58, 0x75, 0x80, 0x00, 0x8f, 0xe0, 0xa9, 0x13, 0x68, 0x9a,
	0x4a, 0xd1, 0x50, 0x2a, 0x85, 0x4d, 0xaa, 0x7b, 0x51, 0x92, 0xe2, 0x9f, 0xe0, 0x99, 0x7f, 0xff,
	0x20, 0x61, 0x31, 0x98, 0xb4, 0x48, 0x98, 0x0c, 0x81, 0x8e, 0x1a, 0x16, 0xe3, 0xee, 0x59, 0x83,
	0x4a, 0xd0, 0x7e, 0x9f, 0x10, 0xca, 0x3e, 0xe9, 0x46, 0xd1, 0x69, 0xc0, 0xa4, 0xb1, 0x23, 0xcd,
	0x54, 0xde, 0x70, 0x51, 0x42, 0xb5, 0x4a, 0x42, 0x17, 0xfc, 0x04, 0xce, 0x14, 0x86, 0x29, 0x4a,
	0x00, 0x61, 0xd7, 0x2f, 0xe1, 0xc5, 0x16, 0xc7, 0x00, 0xf5, 0x0b, 0xfe, 0x28, 0xde, 0x4e, 0xcc,
	0xb7, 0x89, 0x7c, 0xdb, 0xc4, 0x43, 0xb0, 0xb2, 0x40, 0xc0, 0x1c, 0x12, 0xf6, 0xbd, 0x8e, 0x02,
	0xb3, 0x1c, 0x34, 0x1c, 0x98, 0x86, 0xc2, 0x28, 0xd2, 0x30, 0xd9, 0x58, 0xb5, 0x0b, 0xc7, 0x6a,
	0x43, 0xd7, 0x7b, 0x40, 0x7b, 0x96, 0xed, 0xdf, 0x09, 0x27, 0x10, 0x2b, 0x8e, 0xab, 0x55, 0x41,
	0x89, 0xa8, 0x9f, 0xe4, 0xeb, 0x5b, 0xb2, 0x7e, 0xbe, 0x24, 0xe7, 0x42, 0x10, 0x0a, 0xab, 0xee,
	0x42, 0x80, 0xa1, 0x48, 0xe4, 0x50, 0xd8, 0x2f, 0x19, 0x0a, 0x59, 0x09, 0xd5, 0x3f, 0x9d, 0x46,
	0xd7, 0x94, 0xfa, 0xa7, 0x93, 0xe9, 0x36, 0x69, 0xf4, 0xa2, 0x90, 0x75, 0x8e, 0x52, 0x16, 0x83,
	0x43, 0xa0, 0x42, 0x33, 0x04, 0x1c, 0xad, 0x19, 0x79, 0x59, 0x85, 0x37, 0xa0, 0x82, 0x81, 0x83,
	0x28, 0x8a, 0x20, 0x4e, 0x52, 0xae, 0x8c, 0x8b, 0x5a, 0x37, 0xc4, 0x59, 0x4e, 0x13, 0x0b, 0xb1,
	0x34, 0x03, 0xed, 0x5b, 0x37, 0xc5, 0xb7, 0x74, 0x1c, 0x44, 0xad, 0x67, 0x8d, 0xeb, 0xb1, 0x94,
	0x4d, 0x52, 0x36, 0xc5, 0x9d, 0x9c, 0xa2, 0x22, 0xfb, 0x43, 0x72, 0xc3, 0xec, 0x91, 0x7a, 0x49,
	0x6c, 0xf4, 0xac, 0x28, 0xb5, 0x7b, 0xa4, 0x4d, 0xd9, 0x27, 0x0b, 0x96, 0xc8, 0xe0, 0x91, 0x5b,
	0x46, 0xdc, 0x25, 0xa7, 0xea, 0x7d, 0xa3, 0xc2, 0x4e, 0x98, 0xc6, 0xe7, 0xd4, 0x7c, 0xc9, 0x7e,
	0x98, 0x29, 0xd9, 0xf8, 0x99, 0xb7, 0xe0, 0x33, 0x9f, 0x33, 0x3f, 0xa3, 0xd7, 0x10, 0xdf, 0xc9,
	0xbd, 0x66, 0x7f, 0x83, 0x10, 0xd7, 0x8f, 0xfd, 0x33, 0x96, 0x72, 0x73, 0xe0, 0x36, 0x7c, 0xe4,
	0x2d, 0xfd, 0x23, 0x59, 0xa9, 0xf8, 0x80, 0x56, 0x5d, 0x98, 0x7f, 0xd0, 0xac, 0xed, 0x68, 0x7a,
	0x0e, 0xc7, 0xf5, 0x5a, 0x54, 0x47, 0xe9, 0x06, 0x03, 0x54, 0xb9, 0x03, 0x55, 0x0c, 0xdc, 0xad,
	0x1f, 0x03, 0x26, 0xcf, 0x75, 0x98, 0x4f, 0xd3, 0x53, 0x76, 0x8e, 0x3e, 0x4b, 0xfe, 0xc8, 0xa7,
	0xc8, 0x33, 0xd0, 0x73, 0x51, 0x22, 0x01, 0xf0, 0xf5, 0xf2, 0x57, 0x4b, 0xb7, 0x3a, 0xe4, 0x5a,
	0x41, 0x5f, 0x5f, 0xe9, 0x13, 0xdf, 0x22, 0x57, 0x72, 0x3d, 0x7d, 0x95, 0xd7, 0x9d, 0x7f, 0x53,
	0x22, 0x24, 0x9b, 0x10, 0x85, 0x1e, 0x57, 0x15, 0xae, 0x8d, 0x2f, 0xab, 0x80, 0x6f, 0xd7, 0x47,
	0x7d, 0xa5, 0x41, 0xe1, 0x59, 0x44, 0x8b, 0x9e, 0xf9, 0x81, 0x8c, 0x34, 0x46, 0x88, 0x8b, 0x4c,
	0xe1, 0x9d, 0x16, 0xb6, 0x44, 0x95, 0x4a, 0x10, 0xc4, 0xb2, 0xff, 0xa2, 0x73, 0x2c, 0x2d, 0x32,
	0x84, 0x84, 0x97, 0x7c, 0xb2, 0x88, 0x99, 0x8c, 0x3b, 0x15, 0x10, 0xb8, 0xb1, 0xd2, 0x74, 0xae,
	0x05, 0x9d, 0x2a, 0x98, 0x97, 0x79, 0xfe, 0x19, 0xf3, 0x82, 0x54, 0x9e, 0x51, 0x51, 0xb0, 0xf3,
	0xdb, 0x6b, 0x64, 0x63, 0x3c, 0xf0, 0xd0, 0x0d, 0xc9, 0x66, 0xb3, 0xe8, 0x35, 0xac, 0xab, 0xd5,
	0x4e, 0x8f, 0x3b, 0x84, 0xe0, 0x51, 0xf4, 0xcc, 0xfd, 0xab, 0x61, 0xe0, 0x48, 0xa3, 0x1f, 0x4e,
	0x93, 0x13, 0xff, 0x94, 0x69, 0xa7, 0xe5, 0x4c, 0xa4, 0xf0, 0x11, 0x23, 0x82, 0x7f, 0x07, 0x83,
	0x33, 0x74, 0x1c, 0x17, 0xf9, 0x0a, 0x96, 0x8d, 0x11, 0xe6, 0xd3, 0x12, 0x1e, 0x42, 0x7d, 0xfd,
	0x70, 0x1a, 0x9d, 0xe1, 0x8e, 0x0a, 0x42, 0x70, 0xd4, 0x91, 0x1b, 0x63, 0x51, 0xd8, 0xef, 0xf1,
	0xff, 0x08, 0x17, 0x89, 0x81, 0x13, 0xaa, 0x10, 0xc2, 0xb8, 0xd3, 0x92, 0x21, 0xb8, 0x04, 0xeb,
	0x06, 0xf3, 0x13, 0x16, 0x7b, 0x8b, 0x20, 0x85, 0xb6, 0xe2, 0x01, 0x36, 0x13, 0x0b, 0xc7, 0x52,
	0xa5, 0xeb, 0x81, 0xd7, 0x6a, 0xe1, 0xb1, 0x54, 0x0d, 0x27, 0x8e, 0xa4, 0xf4, 0x71, 0x51, 0xe1,
	0x8f, 0x9c, 0xf6, 0xfb, 0x5e, 0xd7, 0xc5, 0x8d, 0x7a, 0x78, 0x06, 0xbf, 0x72, 0xf6, 0x6d, 0xb1,
	0x09, 0x58, 0xa3, 0x06, 0x8e, 0xdb, 0x17, 0xf2, 0x14, 0x94, 0x58, 0xdd, 0x85, 0xaf, 0xb8, 0x46,
	0xf3, 0x68, 0x3e, 0x1e, 0x5e, 0x70, 0x1c, 0xfa, 0xe9, 0x22, 0x66, 0x9d, 0xd9, 0xb1, 0xd8, 0xeb,
	0xab, 0x51, 0x13, 0x09, 0xf6, 0xca, 0x62, 0x3e, 0x8f, 0xe2, 0x94, 0x4d, 0xc1, 0xa2, 0x12, 0x2b,
	0x49, 0x8d, 0xe6, 0xd1, 0x46, 0x4d, 0x37, 0x0a, 0xc2, 0x34, 0xd9, 0xbc, 0x96, 0xab, 0x29, 0xd0,
	0x7c, 0x32, 0x75, 0x06, 0xee, 0x48, 0xec, 0xfc, 0x37, 0xa8, 0x00, 0x38, 0x0d, 0xbe, 0xed, 0x3f,
	0x80, 0xc5, 0xa2, 0x41, 0xf9, 0x63, 0xb6, 0xd8, 0xde, 0x28, 0x5c, 0x6c, 0x6f, 0xea, 0x8b, 0x6d,
	0x76, 0x58, 0x78, 0x73, 0xc5, 0x61, 0xe1, 0x37, 0x8d, 0xc3, 0xc2, 0x9a, 0x53, 0xe2, 0xd6, 0x4a,
	0xa7, 0xc4, 0x5b, 0xe6, 0x5e, 0xf9, 0x1d, 0x42, 0xd4, 0xa8, 0x09, 0x71, 0x5b, 0xa3, 0x1a, 0xc6,
	0xf9, 0x95, 0x75, 0x98, 0x60, 0x62, 0x09, 0xbe, 0xcc, 0x04, 0x7b, 0xa9, 0xf7, 0x07, 0xd9, 0xb6,
	0x62, 0xb0, 0xad, 0xc1, 0x92, 0xd5, 0x3c, 0x4b, 0x72, 0xfd, 0x26, 0x63, 0x06, 0x9c, 0x60, 0x3a,
	0xca, 0x7e, 0x8f, 0x5c, 0x95, 0x7c, 0x10, 0x44, 0x21, 0x6a, 0x83, 0x42, 0xec, 0x2c, 0x17, 0xc8,
	0x0d, 0x11, 0xd0, 0x1e, 0x47, 0xec, 0x18, 0xe5, 0x90, 0x81, 0x93, 0xc1, 0x94, 0x00, 0x27, 0x70,
	0x0e, 0xa1, 0x41, 0x35, 0x0c, 0xd8, 0x7f, 0x5d, 0xcf, 0xf5, 0x52, 0x7f, 0x3e, 0xe3, 0xfa, 0x8c,
	0x88, 0x69, 0x31, 0x70, 0x9c, 0x75, 0xc6, 0xc1, 0xe4, 0x94, 0xa5, 0x8a, 0x53, 0x30, 0xd0, 0x25,
	0x8f, 0xb6, 0xb7, 0xc9, 0x6d, 0x21, 0x05, 0x29, 0x0b, 0xd9, 0x71, 0x94, 0x06, 0xe2, 0x34, 0x9a,
	0x7a, 0x4d, 0x44, 0xc3, 0xbc, 0xb4, 0x0e, 0x57, 0x17, 0x0a, 0xca, 0x61, 0x5e, 0xb6, 0x68, 0x51,
	0x11, 0xd8, 0xa7, 0xb3, 0x79, 0xa8, 0x02, 0xb6, 0x71, 0x43, 0x47, 0xc7, 0x41, 0xa8, 0xcd, 0x59,
	0x22, 0x03, 0x6b, 0x76, 0xce, 0x12, 0xf0, 0x54, 0x4f, 0x52, 0x31, 0x4d, 0x5b, 0x14, 0x9e, 0xb9,
	0xe8, 0x52, 0x0d, 0x91, 0x43, 0x2f, 0xc2, 0x6c, 0x96, 0xf0, 0xe0, 0x5e, 0x62, 0x33, 0x50, 0x3c,
	0x84, 0x7d, 0x96, 0x9e, 0xbb, 0x31, 0x4b, 0x64, 0x94, 0x4d, 0x9d, 0xae, 0x2a, 0x86, 0xbf, 0xe4,
	0x8a, 0xd0, 0x3d, 0xb9, 0x84, 0xe7, 0x9c, 0x26, 0xd6, 0x3d, 0xd0, 0xe3, 0x5a, 0x14, 0x21, 0x10,
	0x0f, 0x58, 0x17, 0x26, 0x38, 0xee, 0xee, 0x98, 0xc8, 0xdc, 0x94, 0xb8, 0x91, 0x9f, 0x12, 0xd9,
	0x14, 0xbe, 0x59, 0x38, 0x85, 0x37, 0x8b, 0xa7, 0xf0, 0x9b, 0x2b, 0xa6, 0xf0, 0xad, 0x55, 0x53,
	0xf8, 0xad, 0x95, 0x53, 0xf8, 0xb6, 0x39, 0x85, 0x6d, 0x52, 0xfd, 0xb6, 0xff, 0x20, 0x01, 0x6d,
	0xa7, 0x41, 0xe1, 0xd9, 0xf9, 0x07, 0x25, 0xb2, 0xde, 0x77, 0x3d, 0x36, 0xe9, 0xec, 0x5d, 0x1c,
	0xb9, 0x28, 0x23, 0x78, 0x65, 0xe4, 0xa2, 0x84, 0x41, 0x84, 0xbb, 0xea, 0x04, 0xa0, 0xe7, 0xf6,
	0x65, 0x0c, 0x6b, 0x35, 0x8b, 0x61, 0xbd, 0x4f, 0xec, 0xce, 0x22, 0x3d, 0xe1, 0x94, 0x17, 0x71,
	0x35, 0xe0, 0xcb, 0xa8, 0x09, 0x63, 0x7f, 0xb9, 0xe4, 0x95, 0xc2, 0x6a, 0x7e, 0xbe, 0x44, 0xea,
	0xd0, 0x8b, 0x1d, 0xef, 0x22, 0xeb, 0x10, 0x9b, 0x5a, 0x5e, 0x6a, 0x6a, 0x25, 0x6b, 0xaa, 0x43,
	0x5a, 0x03, 0x16, 0xee, 0x84, 0x93, 0xf8, 0x7c, 0xce, 0x27, 0x16, 0x26, 0x53, 0xd0, 0x71, 0xaf,
	0x14, 0x30, 0xfa, 0xa7, 0xca, 0x64, 0xed, 0x21, 0x0b, 0xd9, 0x33, 0xf6, 0xda, 0x32, 0xf1, 0x6d,
	0xd2, 0x46, 0x93, 0xd9, 0x70, 0x13, 0x99, 0x48, 0xd8, 0xc8, 0xee, 0x0c, 0x45, 0xfa, 0x11, 0x3c,
	0xf6, 0x93, 0x21, 0x60, 0xd1, 0x8e, 0x03, 0x4e, 0xe4, 0x99, 0x78, 0x0d, 0xfd, 0xe4, 0x39, 0xac,
	0x71, 0x3c, 0x63, 0x2d, 0x77, 0x3c, 0xc3, 0x22, 0x95, 0xc3, 0x51, 0x1f, 0x23, 0x0b, 0xf8, 0xa3,
	0x6e, 0xf0, 0xd7, 0x0d, 0x83, 0x5f, 0xf4, 0x38, 0x67, 0xf0, 0x3b, 0x3f, 0x49, 0x5a, 0x7a, 0x41,
	0xb6, 0x75, 0x5f, 0xd2, 0xa3, 0x4b, 0x56, 0x6c, 0xf2, 0x17, 0x84, 0xc7, 0xae, 0x8a, 0xdf, 0x94,
	0x1b, 0x71, 0x35, 0x2d, 0x8a, 0xf4, 0x3f, 0x95, 0x48, 0xed, 0xf0, 0xa3, 0x41, 0x67, 0x74, 0xc1,
	0x30, 0xdc, 0x25, 0xcd, 0x43, 0x7f, 0x16, 0x4c, 0xfb, 0x3d, 0xfe, 0x0f, 0x79, 0xce, 0x5c, 0x43,
	0x49, 0x32, 0x54, 0x32, 0x32, 0x38, 0xa4, 0xf5, 0x70, 0xdb, 0x55, 0xb3, 0x1f, 0xa9, 0x6f, 0xe0,
	0xb0, 0x4e, 0x2f, 0xe2, 0x36, 0xb9, 0x1f, 0x4b, 0xf2, 0x1b, 0x38, 0x2e, 0x54, 0x1e, 0x6e, 0xbb,
	0x90, 0x40, 0x87, 0x4d, 0xd1, 0x95, 0xae, 0x61, 0xb8, 0x78, 0x7b, 0xb8, 0xed, 0x82, 0x00, 0x12,
	0x07, 0xec, 0xfb, 0x3d, 0xa9, 0xff, 0xe5, 0xf1, 0xce, 0x9f, 0xa8, 0x91, 0xca, 0x81, 0xb7, 0x7d,
	0xe9, 0x68, 0xb3, 0x2a, 0x44, 0x9b, 0xdd, 0x26, 0x8d, 0x9d, 0x67, 0xd2, 0x04, 0x46, 0x27, 0x98,
	0x42, 0xe0, 0xf9, 0x8e, 0x30, 0x39, 0x62, 0xb1, 0x9e, 0x68, 0x44, 0xc7, 0x81, 0x85, 0x1c, 0xc4,
	0x22, 0x71, 0x91, 0x8c, 0xfe, 0x57, 0x08, 0xd8, 0xa4, 0x0a, 0xa7, 0x73, 0xae, 0x0e, 0xa1, 0xa7,
	0x4d, 0x30, 0x59, 0x0e, 0xcb, 0x59, 0xbe, 0xc7, 0x9e, 0x05, 0xca, 0x2d, 0x8c, 0xdd, 0x34, 0x91,
	0x9c, 0x2b, 0xb6, 0x17, 0x89, 0x3a, 0xae, 0x2e, 0x00, 0x68, 0xa5, 0xec, 0xa0, 0xc7, 0x26, 0xb0,
	0xf0, 0x72, 0xcb, 0x59, 0xc3, 0x19, 0xb9, 0x78, 0x0e, 0x12, 0x36, 0x41, 0xcf, 0x89, 0x89, 0x84,
	0x79, 0xce, 0xd2, 0xc5, 0x1c, 0x57, 0x57, 0x01, 0x28, 0xee, 0x12, 0xe1, 0xa6, 0x22, 0x96, 0x89,
	0x8b, 0x70, 0xb1, 0x6d, 0x24, 0x5c, 0xf8, 0x08, 0x81, 0x37, 0x29, 0x7e, 0x8a, 0x4c, 0xba, 0x21,
	0x36, 0x2c, 0x15, 0x82, 0xb7, 0xe2, 0x20, 0x7e, 0xaa, 0x05, 0x4e, 0x5d, 0x11, 0x61, 0xdb, 0x06,
	0x92, 0x73, 0xe4, 0x41, 0xfc, 0x54, 0x6e, 0x7c, 0xc0, 0xaa, 0xd9, 0xa6, 0x3a, 0x0a, 0xbf, 0xe3,
	0xa5, 0x7e, 0x9c, 0xee, 0xc6, 0xd2, 0x27, 0x22, 0xbe, 0x93, 0x21, 0xb9, 0xed, 0x7f, 0x10, 0x3f,
	0xed, 0x46, 0xf3, 0xf3, 0xfd, 0x23, 0x39, 0x64, 0x62, 0x52, 0xd9, 0x50, 0x7d, 0x45, 0xa9, 0xd8,
	0x5e, 0x8b, 0x46, 0x8b, 0xb3, 0x1e, 0x4b, 0x26, 0xb0, 0x9c, 0xb6, 0xa9, 0x86, 0xd1, 0x63, 0x4b,
	0xaf, 0x1b, 0xb1, 0xa5, 0xce, 0xaf, 0x94, 0xc8, 0xf5, 0x03, 0x6f, 0x5b, 0x9a, 0xd6, 0xb3, 0x68,
	0x72, 0x2a, 0x48, 0x78, 0xe1, 0x14, 0xc4, 0x57, 0x34, 0x39, 0xa0, 0xa3, 0x84, 0x1b, 0x0e, 0x40,
	0x69, 0x8c, 0x21, 0x98, 0xd9, 0xab, 0x98, 0x2b, 0x44, 0xd8, 0xab, 0xd7, 0x49, 0xad, 0x1f, 0x4e,
	0xd9, 0x0b, 0x64, 0x48, 0x01, 0x68, 0xe2, 0x63, 0x4d, 0x17, 0x1f, 0xce, 0x2f, 0x54, 0x48, 0x65,
	0xd0, 0x1d, 0x5e, 0xec, 0x6a, 0x1c, 0xfa, 0xc7, 0xc1, 0x44, 0x1e, 0x50, 0x00, 0xa0, 0x20, 0x0b,
	0x48, 0xa5, 0x30, 0x0b, 0x48, 0x2e, 0x64, 0xb7, 0xba, 0x1c, 0xb2, 0xbb, 0x7c, 0xdc, 0xa6, 0x56,
	0x78, 0xdc, 0x66, 0x39, 0x9f, 0xc8, 0x5a, 0x61, 0x3e, 0x91, 0x77, 0xc8, 0x06, 0x64, 0xb9, 0xca,
	0x4e, 0xde, 0x88, 0x39, 0x95, 0xc3, 0x82, 0x2e, 0x7d, 0xe2, 0x87, 0x21, 0x9b, 0x81, 0x33, 0x00,
	0x63, 0x30, 0x34, 0x94, 0x3c, 0xf4, 0xc7, 0xab, 0xb3, 0x29, 0xea, 0xb5, 0x1a, 0xe6, 0x55, 0x0e,
	0xd8, 0xe8, 0xba, 0x4c, 0x6b, 0xa5, 0x2e, 0xd3, 0x36, 0xf7, 0x48, 0xff, 0x5c, 0x89, 0x54, 0x87,
	0xee, 0xc0, 0xbb, 0x78, 0x80, 0xc4, 0x29, 0x33, 0x1c, 0x20, 0x71, 0xc2, 0xec, 0x32, 0x67, 0xd4,
	0xc4, 0x01, 0xd7, 0xc9, 0xe9, 0x76, 0x94, 0xa6, 0xd1, 0x19, 0x8a, 0x73, 0x1d, 0x25, 0x23, 0x20,
	0x6b, 0xea, 0x5c, 0xa3, 0xf3, 0x5b, 0x65, 0xb2, 0x36, 0x8c, 0xa6, 0x4f, 0xc5, 0xa4, 0xbf, 0xc0,
	0xc1, 0x6f, 0x04, 0xce, 0x60, 0x8c, 0x85, 0x19, 0x38, 0x03, 0x01, 0x74, 0x62, 0xdd, 0xc5, 0xcc,
	0x02, 0x10, 0x40, 0x27, 0x31, 0x2b, 0x97, 0xbe, 0x1b, 0x64, 0xed, 0x20, 0x0c, 0x52, 0x95, 0x11,
	0x07, 0x21, 0x7d, 0x92, 0xae, 0x99, 0x01, 0xe0, 0x5c, 0xe4, 0xbf, 0x98, 0xb0, 0xb9, 0x3a, 0x65,
	0x55, 0xa7, 0x19, 0x82, 0x93, 0x4b, 0x1e, 0x85, 0x07, 0xcf, 0xb0, 0x90, 0xb4, 0x06, 0xee, 0x53,
	0x8f, 0xc9, 0xf9, 0x6f, 0x15, 0xb2, 0xb6, 0xef, 0xb9, 0xbb, 0xcf, 0xb6, 0x5e, 0x5b, 0x85, 0x2a,
	0xd8, 0x3d, 0xe2, 0x5d, 0x13, 0xca, 0x91, 0x41, 0x48, 0x03, 0x07, 0x8a, 0x2f, 0xec, 0x82, 0x20,
	0x41, 0xdb, 0x54, 0xc1, 0x70, 0x0e, 0x22, 0x66, 0x3e, 0x86, 0x3e, 0xb5, 0x29, 0x42, 0xc6, 0xee,
	0xfa, 0xfa, 0xf2, 0x79, 0x81, 0xce, 0x02, 0x5a, 0x22, 0x08, 0x89, 0x10, 0x64, 0x9d, 0x33, 0xd4,
	0x60, 0x5c, 0xb5, 0x72, 0x58, 0xfb, 0x6d, 0x52, 0x1d, 0x78, 0x9d, 0x64, 0x93, 0x18, 0x47, 0x07,
	0x06, 0x5e, 0xe7, 0x04, 0x3c, 0x88, 0x14, 0x4a, 0xed, 0xcf, 0x93, 0xca, 0xc0, 0x3b, 0xc0, 0x88,
	0xd8, 0x2b, 0xaa, 0xd2, 0xc1, 0x7c, 0xea, 0xa7, 0x8c, 0xf2, 0x32, 0xfb, 0x0e, 0xaf, 0x42, 0x71,
	0xa7, 0xba, 0xa5, 0xaa, 0x50, 0xf6, 0x09, 0x2f, 0xa7, 0xf6, 0xbb, 0x64, 0xad, 0xf7, 0x14, 0x04,
	0x7e, 0xdb, 0xcc, 0xd0, 0x01, 0x48, 0xf7, 0xf4, 0x98, 0x62, 0xb9, 0xfd, 0x25, 0xb2, 0x0e, 0x26,
	0xff, 0xe1, 0x16, 0xa6, 0x19, 0x52, 0xae, 0x76, 0x8e, 0x75, 0x4f, 0x8f, 0x0f, 0xb7, 0xa8, 0xac,
	0x91, 0xb1, 0xca, 0x95, 0x42, 0x56, 0xb1, 0x74, 0xcd, 0xf9, 0xd7, 0xcb, 0xa4, 0x2e, 0xbf, 0x21,
	0xd2, 0x57, 0xe2, 0x31, 0x6c, 0xcc, 0x4a, 0xd4, 0xa6, 0x3a, 0x0a, 0x56, 0x8d, 0x34, 0xce, 0xa5,
	0xbd, 0xd2, 0x51, 0x9c, 0x3d, 0xb2, 0x4d, 0x33, 0x88, 0x8e, 0x95, 0x3b, 0x51, 0x6f, 0x93, 0x36,
	0xfc, 0x49, 0x2d, 0xb2, 0x32, 0xeb, 0x98, 0x8e, 0x84, 0x7d, 0x0a, 0x18, 0xfc, 0x1e, 0xf3, 0xa7,
	0xaa, 0xaa, 0x60, 0x8b, 0x82, 0x12, 0xc8, 0xee, 0xc5, 0x12, 0xf0, 0x2a, 0xb1, 0xa9, 0x62, 0x23,
	0xc1, 0x2c, 0x05, 0x25, 0xf6, 0xd7, 0xc9, 0xe6, 0xb6, 0x3f, 0x39, 0x5d, 0xcc, 0x0b, 0xde, 0x12,
	0x4a, 0xf7, 0xca, 0x72, 0xe1, 0x8d, 0x10, 0x9b, 0x8d, 0xa0, 0x0f, 0x55, 0xf8, 0x22, 0x9d, 0x61,
	0x9c, 0xff, 0x5c, 0x26, 0x24, 0x1b, 0x90, 0xff, 0x47, 0xce, 0x3f, 0x1c, 0x39, 0x21, 0x6f, 0xa0,
	0xc8, 0x9b, 0x39, 0xf4, 0x93, 0x53, 0x74, 0xa2, 0xea, 0x28, 0xe7, 0x97, 0x4b, 0xa4, 0xa1, 0x26,
	0x8b, 0x4e, 0xab, 0x92, 0x49, 0x2b, 0x19, 0xe7, 0xc2, 0xc9, 0x3e, 0x1c, 0x1f, 0xc8, 0x30, 0x01,
	0x1d, 0xb7, 0xc2, 0xfa, 0xb9, 0x4b, 0x9a, 0xbd, 0x5e, 0xb6, 0x65, 0x2d, 0x02, 0xc7, 0x75, 0x94,
	0x7d, 0x8f, 0xac, 0x0f, 0xbc, 0x4e, 0x10, 0x1e, 0x45, 0x98, 0x5e, 0x66, 0x59, 0x60, 0xc8, 0x0a,
	0xce, 0xbf, 0x95, 0x42, 0xf6, 0xc1, 0xff, 0xf5, 0x42, 0xf6, 0x16, 0xa9, 0xf7, 0xc3, 0x24, 0xf5,
	0xc3, 0x89, 0x14, 0xb3, 0x0a, 0x36, 0x3c, 0x19, 0x8d, 0x9c, 0x27, 0xe3, 0x0b, 0xa4, 0x06, 0x1c,
	0x0a, 0x2b, 0x56, 0x26, 0x38, 0xe5, 0xb4, 0xa1, 0xa2, 0x54, 0x13, 0x8d, 0xcd, 0x0b, 0x44, 0xe3,
	0x45, 0x42, 0x16, 0xe5, 0x74, 0xfb, 0x25, 0x72, 0x5a, 0x0a, 0xfc, 0x8d, 0x97, 0x0a, 0xfc, 0x57,
	0x11, 0xab, 0xff, 0xa5, 0x44, 0x1a, 0xea, 0x7d, 0x50, 0x92, 0xbc, 0xce, 0xb1, 0x0c, 0xe9, 0x10,
	0x00, 0x68, 0x17, 0x9e, 0xa6, 0x7c, 0x23, 0xc4, 0x59, 0x6e, 0x10, 0x84, 0xa7, 0xdc, 0xb8, 0x61,
	0xa8, 0x96, 0xb4, 0xa9, 0x8e, 0x82, 0x7c, 0x70, 0xd3, 0x67, 0x98, 0x64, 0x04, 0x8f, 0xf7, 0x2b,
	0x04, 0xbc, 0xef, 0x65, 0x2c, 0x5b, 0xc3, 0xf7, 0x33, 0x14, 0x9f, 0x78, 0x03, 0x4f, 0x8d, 0x2c,
	0x1e, 0x22, 0xcc, 0x30, 0x9a, 0xde, 0xb3, 0x6e, 0xe8, 0x3d, 0xb7, 0x79, 0xa7, 0x32, 0x5f, 0x04,
	0x98, 0x9d, 0x0a, 0xe1, 0xfc, 0x62, 0x95, 0x53, 0xba, 0xc3, 0x87, 0x0e, 0x37, 0x1e, 0x4b, 0xc6,
	0xd0, 0x65, 0xf4, 0x94, 0x89, 0x94, 0xef, 0x91, 0x35, 0x3a, 0xf0, 0x3a, 0x87, 0x5b, 0x98, 0xd5,
	0x45, 0x9e, 0x38, 0xc2, 0x83, 0xb7, 0xbc, 0x84, 0x62, 0x0d, 0x7b, 0x8b, 0xd4, 0x3b, 0xde, 0x8e,
	0xa8, 0x5d, 0x31, 0x52, 0xdf, 0x74, 0xbc, 0x9d, 0x17, 0x29, 0x8b, 0x43, 0x7f, 0x26, 0xde, 0x50,
	0xf5, 0xf8, 0xb8, 0xf2, 0xb7, 0x31, 0xed, 0x9b, 0x95, 0xff, 0x3a, 0x85, 0x52, 0xfb, 0x0b, 0xa4,
	0x3a, 0xe2, 0xb5, 0x6a, 0xc6, 0xc2, 0x8a, 0x62, 0x06, 0xaa, 0xf1, 0x62, 0xbb, 0x8b, 0xa9, 0x4b,
	0x3a, 0x6e, 0xcc, 0x8e, 0x82, 0x17, 0xfc, 0x0d, 0x91, 0x82, 0x47, 0x85, 0x42, 0x41, 0x69, 0xcc,
	0x7c, 0x55, 0x81, 0xe6, 0xdf, 0xb0, 0xbf, 0x41, 0x9a, 0xfd, 0x8e, 0x6a, 0x00, 0x90, 0xb7, 0xe0,
	0x03, 0x59, 0x0b, 0xf5, 0xda, 0xf6, 0x7b, 0x64, 0x4d, 0x74, 0x0d, 0x68, 0x9f, 0x65, 0xcd, 0x32,
	0x08, 0x40, 0xb1, 0x8e, 0xed, 0x90, 0xea, 0x80, 0xd7, 0x6d, 0x40, 0xdd, 0x0d, 0x3d, 0x79, 0x0f,
	0xef, 0xd3, 0x20, 0xeb, 0x53, 0xec, 0x6b, 0x7d, 0x22, 0xf9, 0x26, 0xc5, 0xfe, 0x72, 0x9f, 0xf4,
	0x37, 0xb2, 0x79, 0xd1, 0x2c, 0x9c, 0x17, 0x2d, 0x7d, 0x5e, 0x3c, 0xe6, 0x33, 0x81, 0xb2, 0x4f,
	0x34, 0xe6, 0x2f, 0x19, 0xcc, 0x6f, 0xf3, 0xa9, 0x88, 0xfa, 0x7a, 0x9b, 0xc2, 0xb3, 0xc9, 0xee,
	0x95, 0x1c, 0xbb, 0x3b, 0x7b, 0xa4, 0x2e, 0x67, 0x33, 0xaf, 0x39, 0x5a, 0x9c, 0xed, 0x1f, 0xc1,
	0x6c, 0x16, 0x6b, 0x40, 0x86, 0xb0, 0xef, 0xe0, 0x34, 0x17, 0x61, 0x33, 0x24, 0x63, 0x4b, 0x31,
	0xc1, 0x9d, 0xdf, 0x2c, 0x11, 0x7b, 0xb9, 0xc3, 0x7c, 0xa1, 0x85, 0x6f, 0x08, 0x0c, 0x93, 0x8e,
	0x34, 0x13, 0x29, 0x12, 0x32, 0x1c, 0x19, 0x13, 0x3a, 0x43, 0x88, 0xd0, 0x87, 0xa3, 0xe5, 0x69,
	0x9d, 0xc3, 0x8a, 0x4d, 0xf1, 0xa3, 0xfc, 0xe4, 0x36, 0x70, 0xf6, 0x7b, 0xa4, 0xae, 0x9a, 0xb2,
	0xb4, 0xe2, 0x88, 0x12, 0xaa, 0x6a, 0x38, 0xff, 0xa4, 0x4c, 0xda, 0x06, 0x83, 0x64, 0x0b, 0x5d,
	0x29, 0xe7, 0xe6, 0x1b, 0xb2, 0x34, 0x46, 0x53, 0xbb, 0x4d, 0x11, 0x82, 0xb5, 0x45, 0x90, 0xc2,
	0x88, 0x9e, 0xd3, 0x71, 0x9c, 0x42, 0x02, 0xce, 0x12, 0x02, 0x00, 0x85, 0x0c, 0xa4, 0x49, 0xa1,
	0x5a, 0x9e, 0x42, 0x6f, 0x93, 0x36, 0x7a, 0x9c, 0xc4, 0x5b, 0xf2, 0xa8, 0x83, 0x81, 0xb4, 0xdf,
	0x23, 0x57, 0x77, 0xa3, 0xf8, 0xb9, 0x1f, 0x4f, 0x83, 0xf0, 0x58, 0x77, 0x5b, 0xb5, 0xe8, 0x72,
	0x81, 0x7d, 0x8f, 0x58, 0xb2, 0xe3, 0x40, 0xbb, 0xb1, 0x7f, 0x8c, 0x01, 0xed, 0x4b, 0xf8, 0x82,
	0x11, 0x6a, 0x14, 0x8d, 0x90, 0xf3, 0xf3, 0x82, 0x49, 0x72, 0x33, 0x5d, 0x23, 0x5f, 0xe9, 0xa5,
	0xe4, 0x2b, 0x5f, 0x86, 0x7c, 0x95, 0x22, 0xf2, 0x2d, 0x11, 0xa8, 0x5a, 0x40, 0x20, 0xe7, 0x85,
	0xd6, 0xba, 0x4c, 0x72, 0xac, 0xd6, 0x8c, 0x56, 0x0d, 0xfb, 0x57, 0xc8, 0xb5, 0x1e, 0x4b, 0xd2,
	0x20, 0x04, 0x93, 0x48, 0x69, 0x0e, 0x82, 0x6b, 0x8b, 0x8a, 0x9c, 0x5f, 0x2b, 0x91, 0x2b, 0x39,
	0x51, 0x9c, 0xd7, 0xe0, 0x4a, 0x4b, 0x1a, 0x1c, 0xaf, 0x21, 0x5f, 0xd9, 0x56, 0x19, 0x1b, 0x74,
	0x94, 0xd6, 0xc2, 0x8a, 0xd1, 0xc2, 0x42, 0x56, 0x10, 0xf3, 0xe5, 0x92, 0xac, 0x50, 0x2b, 0x66,
	0x05, 0x67, 0x4a, 0x1a, 0x19, 0xe9, 0x8a, 0x67, 0xcb, 0xa6, 0x1e, 0x84, 0x67, 0x10, 0xf4, 0x8b,
	0x64, 0x5d, 0xbc, 0x2c, 0x83, 0x06, 0xdb, 0xc6, 0xb2, 0x43, 0x65, 0xa9, 0xf3, 0x2b, 0x25, 0x99,
	0x27, 0x6c, 0xd5, 0xe9, 0x25, 0x6d, 0x60, 0x6a, 0xaa, 0xdb, 0x39, 0xa3, 0xa2, 0xb2, 0x6c, 0x54,
	0x7c, 0x85, 0x5c, 0x53, 0x4a, 0xb4, 0x56, 0x53, 0x90, 0xa6, 0xa8, 0x88, 0x13, 0x47, 0xa2, 0x73,
	0x3a, 0xe2, 0x12, 0xde, 0x99, 0x92, 0xa6, 0xb6, 0x3c, 0xaf, 0x20, 0x0f, 0x57, 0x78, 0x82, 0xf0,
	0x54, 0xe5, 0x15, 0x01, 0xc0, 0xfe, 0xc1, 0x3c, 0x69, 0xae, 0x18, 0xa4, 0xe1, 0x26, 0xac, 0x24,
	0xce, 0x4f, 0x48, 0x6d, 0xf5, 0x70, 0x6b, 0xe5, 0xd9, 0xae, 0x20, 0x3c, 0x55, 0x0b, 0x05, 0x42,
	0xf2, 0xa0, 0x95, 0x3a, 0x21, 0xd4, 0xa6, 0x0a, 0xd6, 0x28, 0x5a, 0xd5, 0x19, 0xc9, 0x19, 0x71,
	0x33, 0x44, 0x2e, 0xf6, 0x2f, 0x99, 0x2a, 0xef, 0x90, 0x8d, 0x4e, 0x9a, 0xfa, 0x93, 0x13, 0x69,
	0xc2, 0xc0, 0x42, 0xd2, 0xa6, 0x39, 0xac, 0xf3, 0x0f, 0x4b, 0x64, 0x1d, 0x97, 0xd9, 0xbc, 0x81,
	0x57, 0x7a, 0xa9, 0x81, 0x97, 0xe3, 0xa4, 0x7b, 0xc4, 0x82, 0xcf, 0x44, 0x13, 0x7f, 0xa6, 0x67,
	0x62, 0x69, 0xd1, 0x25, 0xfc, 0xf2, 0x1a, 0x25, 0xba, 0x98, 0x5b, 0xa3, 0x5e, 0x6d, 0xe5, 0xf8,
	0x59, 0xa1, 0xc3, 0xa2, 0xe4, 0xcd, 0x0b, 0xb2, 0xd2, 0x65, 0x04, 0x59, 0xb9, 0x48, 0x90, 0x99,
	0x13, 0x3a, 0xe3, 0xec, 0xcb, 0x09, 0xb8, 0x9f, 0xad, 0x91, 0xca, 0xf6, 0x6e, 0xef, 0xb5, 0xed,
	0xa7, 0x3b, 0x84, 0xf4, 0x02, 0xff, 0x38, 0x8c, 0x92, 0x54, 0xb5, 0x40, 0xc3, 0x80, 0x36, 0xc3,
	0x45, 0xbd, 0xf4, 0x6d, 0x03, 0xa0, 0x4e, 0x51, 0x89, 0x0d, 0x25, 0x71, 0x8a, 0x8a, 0xb3, 0x7e,
	0x10, 0xfa, 0x33, 0x99, 0xcf, 0x0f, 0x00, 0xfb, 0xab, 0xe4, 0x26, 0x1e, 0x07, 0x73, 0x67, 0x7e,
	0xc8, 0xfa, 0xe1, 0x94, 0xcd, 0x59, 0x38, 0x65, 0x61, 0x8a, 0x7e, 0xbf, 0x55, 0xc5, 0x9c, 0x57,
	0x3a, 0x8b, 0xf4, 0x44, 0xee, 0xc2, 0x63, 0xc6, 0x3f, 0x0d, 0x05, 0x7b, 0xd5, 0x0c, 0x72, 0xb3,
	0x36, 0x30, 0x57, 0x20, 0x40, 0x10, 0x1c, 0xb5, 0x98, 0xa5, 0x01, 0x6c, 0xee, 0x60, 0x70, 0x83,
	0x86, 0xe1, 0x9c, 0x24, 0x82, 0x0c, 0x05, 0x6e, 0x16, 0xa8, 0x7c, 0xd8, 0x4b, 0x78, 0x38, 0xe0,
	0x72, 0xde, 0x0b, 0x92, 0x49, 0x1c, 0x9c, 0x71, 0x11, 0x1f, 0xc5, 0xe8, 0x29, 0xcc, 0xa3, 0xb9,
	0x00, 0xfe, 0x4e, 0xb4, 0x88, 0xcd, 0xba, 0xc2, 0x8b, 0xbc, 0x5c, 0x60, 0x6f, 0x91, 0xeb, 0x3d,
	0x96, 0x04, 0x31, 0x9b, 0x0e, 0x83, 0x70, 0xfc, 0x42, 0xb9, 0x22, 0x44, 0x1e, 0x82, 0xc2, 0x32,
	0xfb, 0x03, 0xf2, 0x06, 0x65, 0x9f, 0x2c, 0xb0, 0x80, 0x66, 0x2f, 0x5d, 0x81, 0x97, 0x8a, 0x0b,
	0xed, 0x6f, 0x92, 0x37, 0xb5, 0x82, 0x9d, 0xc9, 0x49, 0xa4, 0xbd, 0x29, 0xc2, 0x21, 0x56, 0x57,
	0xb0, 0x3f, 0x20, 0x84, 0x93, 0x1c, 0x2d, 0x98, 0xab, 0x86, 0xa2, 0xbd, 0xbd, 0xdb, 0xcb, 0xca,
	0xa8, 0x56, 0xcf, 0xf9, 0xe3, 0xa4, 0x6d, 0x14, 0x42, 0x12, 0xf3, 0x45, 0x7a, 0xa2, 0x09, 0x2e,
	0x05, 0x73, 0xc6, 0x79, 0xc4, 0xce, 0x95, 0x53, 0x5a, 0x00, 0x97, 0xde, 0xd4, 0x28, 0xca, 0x82,
	0xfa, 0x77, 0xab, 0xa4, 0xf2, 0x90, 0xee, 0x5c, 0x9c, 0xf2, 0x54, 0x9a, 0x78, 0x92, 0xc9, 0xc4,
	0xce, 0x6b, 0x1e, 0x2d, 0x53, 0x22, 0x05, 0xe1, 0xb1, 0xac, 0x28, 0x8e, 0x48, 0xe6, 0xb0, 0x9c,
	0xf1, 0x1e, 0x31, 0x15, 0x37, 0x22, 0x5c, 0xf8, 0x1a, 0x46, 0x04, 0x11, 0x7f, 0x22, 0xcb, 0xf1,
	0xd0, 0x58, 0x86, 0xe1, 0x2c, 0xe4, 0xf1, 0xb9, 0x8f, 0xb7, 0xe3, 0x80, 0x00, 0xc5, 0xe9, 0xb4,
	0x5c, 0x00, 0x67, 0x6a, 0x26, 0xa7, 0xf2, 0x6b, 0x62, 0x36, 0x69, 0x18, 0x3c, 0xf6, 0xb7, 0x80,
	0x79, 0x2e, 0x4f, 0x68, 0xaa, 0x50, 0x6f, 0x13, 0x9f, 0xad, 0x5b, 0x8d, 0xdc, 0xb2, 0x2e, 0xc5,
	0x06, 0x31, 0xc5, 0x86, 0xbe, 0x65, 0xdf, 0x7c, 0x49, 0x46, 0xc5, 0xd6, 0xb2, 0x2f, 0x1a, 0x37,
	0x96, 0x70, 0xcf, 0x32, 0xcb, 0xd3, 0xf3, 0x88, 0x9d, 0xe3, 0x6e, 0x25, 0x7f, 0x94, 0x51, 0x12,
	0x62, 0x77, 0x12, 0xa2, 0x24, 0x2c, 0x52, 0xe9, 0x4c, 0x4e, 0x71, 0x2f, 0x92, 0x3f, 0xda, 0x5f,
	0x12, 0x2b, 0x68, 0x10, 0x1e, 0x23, 0x67, 0x4a, 0x6b, 0xf5, 0x21, 0xdd, 0xc1, 0x02, 0x2a, 0x6b,
	0xbc, 0xca, 0x09, 0x6c, 0xbe, 0x66, 0x91, 0xec, 0x1b, 0x9a, 0x28, 0xde, 0xf5, 0xcf, 0x82, 0x99,
	0x5c, 0xb8, 0x4c, 0x24, 0x84, 0x8b, 0xd1, 0x1d, 0xec, 0x9e, 0x4c, 0x11, 0x2c, 0x11, 0x58, 0x6a,
	0x58, 0x0d, 0x19, 0x42, 0xfa, 0x25, 0x83, 0xf0, 0xb8, 0x1f, 0x1e, 0x45, 0xf1, 0x99, 0xaf, 0xd2,
	0xe7, 0xb6, 0x68, 0x41, 0x09, 0x18, 0xe9, 0xec, 0x45, 0x9a, 0x33, 0xd2, 0xb5, 0x6e, 0x43, 0xb1,
	0xf3, 0x73, 0x25, 0x52, 0xdd, 0xed, 0xf5, 0xfa, 0x17, 0xcc, 0x04, 0x87, 0xb4, 0x60, 0xbb, 0x56,
	0x72, 0x09, 0x6a, 0xe5, 0x3a, 0xce, 0x48, 0xe1, 0x50, 0x59, 0x4e, 0xe1, 0x80, 0xc1, 0x44, 0xd5,
	0x15, 0xc1, 0x44, 0x35, 0x3d, 0x98, 0xc8, 0xf9, 0x99, 0x12, 0xa9, 0xec, 0x74, 0x2e, 0x71, 0xde,
	0x50, 0xcb, 0x15, 0x57, 0x95, 0x19, 0x67, 0xfa, 0xf2, 0x90, 0x66, 0xb9, 0x3f, 0x7d, 0x59, 0x34,
	0x46, 0xfe, 0x92, 0x08, 0x99, 0x7f, 0x4e, 0xcb, 0x09, 0xa2, 0x60, 0xe7, 0x94, 0xd4, 0x76, 0x3a,
	0xee, 0xfe, 0xe0, 0xfb, 0xea, 0x87, 0x5c, 0xd1, 0x38, 0xe7, 0x2f, 0xd4, 0x48, 0x1d, 0xfe, 0xc6,
	0xf9, 0xfc, 0xe5, 0x3f, 0x7c, 0x8f, 0x5c, 0x7d, 0xc4, 0xce, 0x65, 0xf2, 0xe4, 0x48, 0xbf, 0xdb,
	0x64, 0xb9, 0x80, 0x2f, 0x2a, 0x06, 0xd2, 0x0c, 0x1e, 0x2e, 0x2c, 0xe3, 0x5d, 0x7a, 0xc4, 0xce,
	0xb5, 0xd0, 0x0a, 0x09, 0x72, 0x7a, 0x71, 0x51, 0xac, 0xed, 0x61, 0x2b, 0x98, 0xbf, 0x05, 0xee,
	0xcd, 0x99, 0x5c, 0xee, 0x25, 0xc8, 0x3b, 0xfd, 0x88, 0x9d, 0x77, 0xba, 0x8f, 0x64, 0x20, 0xb5,
	0x80, 0x10, 0x3f, 0xec, 0x77, 0x71, 0x25, 0x47, 0x48, 0x0b, 0xbc, 0x6e, 0xe4, 0x03, 0xaf, 0x87,
	0xfd, 0xee, 0x4e, 0x1c, 0x47, 0x31, 0x2e, 0xe1, 0x0a, 0xd6, 0xb7, 0xe2, 0x45, 0x94, 0x84, 0xda,
	0x8a, 0xff, 0x0a, 0xb9, 0xb6, 0xe7, 0x27, 0x2a, 0x6a, 0x8a, 0xf7, 0x38, 0x0b, 0x9b, 0x28, 0x2a,
	0x02, 0x99, 0x3c, 0x7c, 0x84, 0xa1, 0xd3, 0x98, 0xbc, 0x4b, 0xc3, 0xf0, 0xf1, 0x79, 0xc4, 0xce,
	0xb5, 0x68, 0x8a, 0x1a, 0xcd, 0x10, 0x22, 0x09, 0xde, 0x7c, 0xe6, 0x9f, 0x43, 0x62, 0x03, 0x16,
	0x83, 0xbc, 0xaa, 0x52, 0x13, 0xc9, 0x85, 0xcc, 0x28, 0x0a, 0x27, 0x0c, 0x64, 0x57, 0x8b, 0x0a,
	0x00, 0x78, 0xf9, 0x10, 0x04, 0x57, 0x8b, 0x96, 0xfb, 0x87, 0x22, 0x0f, 0x59, 0x17, 0xc4, 0x53,
	0x95, 0xf2, 0x47, 0x8c, 0x94, 0xb9, 0xa6, 0x22, 0x65, 0x2c, 0x52, 0xe1, 0x04, 0x14, 0x11, 0x0f,
	0xfc, 0x91, 0xff, 0x1f, 0x3b, 0x82, 0x2d, 0xc4, 0xc0, 0x41, 0x03, 0x09, 0xd6, 0x5e, 0x9e, 0x24,
	0x37, 0x84, 0xea, 0x9c, 0xc7, 0x3b, 0xff, 0xa2, 0x4c, 0xd6, 0x0e, 0x29, 0x75, 0xbf, 0xff, 0x1b,
	0x9f, 0x87, 0x41, 0x9c, 0x2e, 0xfc, 0x19, 0x4d, 0x63, 0x34, 0xbf, 0x6a, 0xd4, 0xc0, 0x19, 0x22,
	0xa6, 0x96, 0x13, 0x31, 0x70, 0x9a, 0x68, 0x11, 0xa6, 0x7d, 0x17, 0x32, 0x43, 0xe0, 0x1d, 0x41,
	0x1a, 0xca, 0x50, 0x31, 0xd6, 0x73, 0x2a, 0x06, 0xdc, 0xa1, 0xf2, 0x8c, 0x71, 0x2b, 0x4f, 0x7a,
	0xe7, 0x25, 0x6c, 0x2c, 0x57, 0x8d, 0xdc, 0x72, 0x75, 0x9b, 0x34, 0xc4, 0xd7, 0xc5, 0x15, 0x39,
	0x95, 0x77, 0x1b, 0x34, 0x43, 0xbc, 0x92, 0xa7, 0xef, 0x97, 0x4a, 0x64, 0xa3, 0x1b, 0x24, 0x93,
	0xe8, 0xb2, 0xd7, 0x02, 0xbc, 0x34, 0xc3, 0xf2, 0x78, 0xac, 0x32, 0x2c, 0x63, 0x7e, 0xe3, 0x95,
	0x67, 0xab, 0xb7, 0x72, 0xd9, 0xfe, 0x65, 0x8e, 0x75, 0xb3, 0x31, 0x66, 0xa6, 0xff, 0x27, 0xe4,
	0x5a, 0x41, 0xf1, 0xf7, 0x21, 0xe5, 0xfe, 0x0f, 0x93, 0x2b, 0xdd, 0x9e, 0x7b, 0x38, 0xe8, 0x8c,
	0x7a, 0x81, 0x3f, 0x8b, 0x8e, 0x17, 0x32, 0xe5, 0x7f, 0x49, 0xe5, 0x1e, 0xb3, 0x49, 0x15, 0xf2,
	0x75, 0xa3, 0xd4, 0xe7, 0xcf, 0xce, 0xb7, 0x48, 0xb3, 0xdb, 0x73, 0xb9, 0x85, 0xb7, 0x32, 0xbb,
	0x09, 0xb7, 0x74, 0xb1, 0x1c, 0x8f, 0x8d, 0x28, 0xd8, 0xa1, 0xc4, 0xea, 0xf6, 0x5c, 0x37, 0x7a,
	0xce, 0xe2, 0x95, 0xbf, 0xe5, 0x56, 0xd8, 0xf1, 0x59, 0xaa, 0xb4, 0x50, 0x84, 0xe0, 0x9e, 0x0b,
	0x41, 0xbe, 0x0a, 0x58, 0xb7, 0x92, 0x44, 0x3f, 0x53, 0x82, 0xae, 0x78, 0x73, 0x3f, 0x66, 0xae,
	0x1f, 0xc4, 0x6e, 0xb4, 0x03, 0xf1, 0x35, 0xde, 0xce, 0x6e, 0xb4, 0x88, 0x9f, 0x04, 0x31, 0xc3,
	0x8c, 0xea, 0x3a, 0x0a, 0xac, 0xc6, 0x5e, 0x27, 0x9e, 0x9c, 0x78, 0x27, 0x7e, 0x8c, 0x71, 0xad,
	0x75, 0x6a, 0xe0, 0xe0, 0x2b, 0x3d, 0x94, 0x67, 0xfb, 0x21, 0x6a, 0x9a, 0x3a, 0x0a, 0x0e, 0x1c,
	0x7a, 0x3b, 0xfb, 0x32, 0xe6, 0x4f, 0x00, 0xce, 0x3f, 0xab, 0x13, 0xdb, 0x1c, 0xb5, 0x4b, 0xa4,
	0xfd, 0xff, 0x12, 0xa9, 0x77, 0x7b, 0xae, 0xd8, 0x81, 0x2a, 0x1b, 0x5b, 0x42, 0x12, 0x4d, 0x55,
	0x05, 0xb8, 0x26, 0x0e, 0x62, 0xe1, 0xd0, 0xd1, 0xd2, 0xa0, 0x0a, 0x16, 0x4e, 0x69, 0x79, 0xc8,
	0x5a, 0xe4, 0x4a, 0xc8, 0x10, 0x9c, 0x8a, 0x78, 0x5f, 0x05, 0x2a, 0x02, 0x78, 0x13, 0xc4, 0xd7,
	0x49, 0xcb, 0xb8, 0x06, 0xc0, 0x4c, 0xe2, 0xdf, 0xcd, 0x25, 0xb3, 0x37, 0xea, 0xea, 0x13, 0x64,
	0xdd, 0xbc, 0x19, 0x92, 0xcb, 0x91, 0x99, 0x9f, 0x72, 0x6d, 0x49, 0xde, 0xa6, 0x24, 0x61, 0xfb,
	0x3d, 0x42, 0xfa, 0xae, 0xb2, 0xfa, 0x1b, 0xc6, 0x2e, 0x59, 0xdf, 0x1d, 0xb1, 0x94, 0x6a, 0xe5,
	0xbc, 0x57, 0x87, 0x63, 0x17, 0x8f, 0x18, 0x89, 0x98, 0x92, 0x0c, 0x01, 0x1b, 0xb6, 0x7e, 0x1a,
	0x3c, 0x63, 0xc0, 0xb0, 0x4d, 0x4c, 0x6d, 0xac, 0x30, 0x10, 0xb3, 0xb4, 0x98, 0xcd, 0x7a, 0x8b,
	0xf9, 0x8c, 0xbd, 0xc0, 0x35, 0x48, 0xc3, 0xd8, 0x1f, 0x90, 0x06, 0xaf, 0x07, 0xb7, 0x45, 0xe0,
	0x86, 0x9c, 0xd6, 0x75, 0x7d, 0x96, 0xd0, 0xac, 0xa2, 0x7c, 0xeb, 0xf1, 0x82, 0xc5, 0xe7, 0x18,
	0xfd, 0xf0, 0xd2, 0xb7, 0xa0, 0x22, 0x5f, 0x02, 0x60, 0x02, 0x74, 0xa3, 0x30, 0x59, 0x9c, 0x89,
	0xc0, 0x1b, 0x61, 0x36, 0x2e, 0xe1, 0x61, 0x99, 0x19, 0x1f, 0x48, 0x45, 0x7b, 0x38, 0x3e, 0xe0,
	0xcb, 0x0c, 0x44, 0x95, 0x4e, 0xd9, 0x74, 0x1c, 0x2f, 0x92, 0x14, 0x73, 0x52, 0x9a, 0x48, 0xce,
	0xdd, 0x07, 0x61, 0xca, 0x1f, 0xd9, 0xb4, 0xbb, 0xef, 0x61, 0xfa, 0x0e, 0x03, 0xa7, 0xdf, 0x1e,
	0x71, 0xcd, 0xbc, 0x3d, 0x82, 0x2b, 0x02, 0xe7, 0xc9, 0x7e, 0xbf, 0x87, 0xf9, 0xe7, 0x10, 0x82,
	0xe4, 0xcd, 0x59, 0x4a, 0x7e, 0x96, 0x6c, 0xbe, 0x01, 0xdc, 0x65, 0x22, 0xed, 0xfb, 0xda, 0xfc,
	0xbf, 0x61, 0xec, 0x9e, 0x69, 0x92, 0x23, 0x93, 0x09, 0xf6, 0x37, 0x48, 0x0b, 0xfa, 0x2d, 0xf5,
	0x88, 0x9b, 0xc6, 0x3d, 0x0a, 0x79, 0x71, 0x41, 0x8d, 0xca, 0xf6, 0x8f, 0x92, 0x0d, 0x80, 0x3b,
	0xcf, 0xfc, 0x60, 0xe6, 0x3f, 0x9d, 0x31, 0x88, 0xad, 0x7f, 0xc9, 0xeb, 0xb9, 0xea, 0x9c, 0xef,
	0x35, 0xc9, 0xc1, 0x20, 0x06, 0xdf, 0x18, 0x46, 0x5d, 0xae, 0x50, 0xa3, 0x2e, 0xb7, 0xc8, 0x77,
	0x42, 0x16, 0x1f, 0x9f, 0x3f, 0x09, 0x12, 0x06, 0x51, 0xfa, 0x99, 0x45, 0xde, 0xed, 0xb9, 0x59,
	0x19, 0xd5, 0xea, 0xd9, 0x1f, 0x64, 0xd7, 0x57, 0xbc, 0x75, 0xe1, 0x3a, 0xa0, 0xae, 0xae, 0xf8,
	0x1f, 0xe5, 0x4c, 0x3e, 0xe8, 0x57, 0x0b, 0xb4, 0xc4, 0xd5, 0x02, 0x66, 0xc0, 0x58, 0x79, 0x29,
	0x60, 0xec, 0x6d, 0xd2, 0xee, 0xce, 0xf8, 0xd0, 0xc7, 0x43, 0x3f, 0x91, 0xbb, 0x55, 0x0d, 0x6a,
	0x22, 0xf9, 0x74, 0xc5, 0xff, 0xbd, 0x2f, 0xb3, 0x41, 0x49, 0x58, 0x9f, 0xe4, 0xb5, 0x25, 0xc7,
	0x95, 0xb7, 0x78, 0x2a, 0x0b, 0x71, 0xd3, 0x36, 0xc3, 0x68, 0xd1, 0xb1, 0xeb, 0x46, 0x74, 0x6c,
	0xf6, 0xb7, 0x2d, 0xa9, 0x0a, 0x48, 0x18, 0xee, 0x67, 0x15, 0x4d, 0xc3, 0x5b, 0x7e, 0x58, 0x8c,
	0xf1, 0x65, 0x4b, 0x78, 0xb0, 0xe7, 0x9e, 0x07, 0xe9, 0xe4, 0x84, 0x9b, 0x37, 0x28, 0x1a, 0x14,
	0x42, 0xfb, 0xcb, 0x03, 0x69, 0x1f, 0x4b, 0x18, 0x6e, 0x6f, 0xf4, 0x43, 0xff, 0x18, 0xd2, 0x37,
	0x83, 0xe8, 0x68, 0xe1, 0xed, 0x8d, 0x06, 0xd6, 0xf9, 0x5e, 0x95, 0xb4, 0x8d, 0x01, 0x85, 0x69,
	0x28, 0xf5, 0x35, 0x50, 0xe2, 0xc4, 0x58, 0x98, 0x48, 0x83, 0x9e, 0xc2, 0x87, 0x9a, 0xd1, 0xb3,
	0xd8, 0xab, 0xd2, 0x2e, 0x0a, 0x15, 0x1d, 0x46, 0x53, 0x36, 0xd3, 0xe2, 0x3c, 0x1a, 0x54, 0x47,
	0x19, 0x74, 0xac, 0xe5, 0xe8, 0x78, 0x87, 0x10, 0x99, 0x67, 0x0e, 0x83, 0x28, 0x1a, 0x54, 0xc3,
	0x88, 0x83, 0x55, 0x71, 0xe0, 0xf3, 0x6f, 0xa1, 0xf0, 0xce, 0x10, 0x06, 0xed, 0xc4, 0x39, 0xc2,
	0x8c, 0x76, 0x36, 0xa9, 0xd2, 0x68, 0xc6, 0x70, 0x54, 0xe0, 0x59, 0x3b, 0x04, 0x4a, 0x8c, 0x43,
	0xa0, 0xf2, 0x68, 0x69, 0x53, 0x3b, 0x5a, 0x8a, 0xfa, 0xfa, 0xb9, 0x22, 0x90, 0x38, 0x88, 0x64,
	0x22, 0xc5, 0xd6, 0xdc, 0x7c, 0x76, 0xae, 0x02, 0x41, 0x5b, 0x34, 0x43, 0x88, 0x4d, 0xc9, 0xf9,
	0xec, 0x5c, 0xea, 0x85, 0x1b, 0xf2, 0xa4, 0x6e, 0x86, 0xcb, 0xff, 0x67, 0x0b, 0xf3, 0x22, 0x99,
	0xc8, 0x7c, 0xad, 0x07, 0x68, 0x1f, 0x98, 0x48, 0xe7, 0x17, 0xca, 0xa0, 0x6a, 0x18, 0x8b, 0x1f,
	0x57, 0x77, 0x1e, 0xa0, 0xdb, 0x5d, 0xe8, 0x19, 0x0a, 0x06, 0x3b, 0x77, 0x1b, 0xaf, 0x68, 0xc1,
	0xcb, 0x5b, 0x24, 0x0c, 0x47, 0x56, 0x5d, 0xe3, 0xfa, 0x16, 0x05, 0xc3, 0x37, 0xb7, 0x04, 0x0b,
	0xa3, 0x66, 0xa1, 0x60, 0x4e, 0xe3, 0x7e, 0x02, 0x79, 0x0b, 0xf0, 0x12, 0x17, 0x01, 0x41, 0x9c,
	0xf6, 0xc3, 0xa1, 0xbb, 0x1b, 0xcc, 0x52, 0x0c, 0x02, 0xae, 0x53, 0x0d, 0x03, 0xa1, 0x15, 0xef,
	0xab, 0xab, 0x64, 0xd0, 0x47, 0x95, 0x61, 0xc0, 0x8e, 0x4c, 0xc4, 0x35, 0x30, 0x75, 0xb4, 0x23,
	0x05, 0x08, 0x59, 0x7b, 0xd8, 0x59, 0x94, 0xb2, 0xd9, 0xb9, 0x98, 0x17, 0xd2, 0xcb, 0x9b, 0x47,
	0x3b, 0x3f, 0x44, 0x6a, 0xb0, 0x72, 0x63, 0x72, 0xcf, 0x92, 0x4a, 0xee, 0xc9, 0x1b, 0xed, 0xc2,
	0x4e, 0x1b, 0xde, 0x69, 0x2a, 0x20, 0xe7, 0x7b, 0x65, 0x72, 0x65, 0x14, 0xc5, 0x29, 0x9b, 0x5d,
	0x56, 0x19, 0x37, 0xec, 0x00, 0xbc, 0xe4, 0x38, 0xb3, 0x03, 0x80, 0x9d, 0x21, 0x10, 0x19, 0x15,
	0x23, 0x38, 0x27, 0x88, 0x08, 0xc8, 0x8f, 0x26, 0xae, 0xcc, 0x92, 0x06, 0x36, 0x82, 0xfc, 0xbd,
	0x6d, 0x7f, 0x72, 0x3a, 0x9f, 0xf9, 0xa1, 0xda, 0x01, 0x56, 0x88, 0xcc, 0xf3, 0xbe, 0xa6, 0x7b,
	0xde, 0x6f, 0x91, 0xfa, 0x68, 0x71, 0x26, 0x76, 0x93, 0xd0, 0xca, 0x91, 0xb0, 0x74, 0xc3, 0xf8,
	0x13, 0xd4, 0x7a, 0x10, 0x92, 0x6e, 0x18, 0x7f, 0x82, 0xd3, 0x06, 0x21, 0xe7, 0x9f, 0x96, 0x49,
	0xa5, 0xdb, 0x77, 0x2f, 0x75, 0x0e, 0x4b, 0xe4, 0xb9, 0x52, 0x77, 0x01, 0x61, 0x96, 0x2b, 0x31,
	0x91, 0x35, 0x95, 0x10, 0xf2, 0x97, 0x20, 0x02, 0x7a, 0x3e, 0xf3, 0x93, 0x44, 0xed, 0xb6, 0x49,
	0x10, 0xd8, 0x06, 0xa3, 0xa3, 0xd4, 0xde, 0x9a, 0x86, 0xd1, 0x84, 0xf7, 0x9a, 0x21, 0xbc, 0xef,
	0x11, 0x2b, 0xcb, 0x63, 0xab, 0xc4, 0x3b, 0xd7, 0xcb, 0x97, 0xf0, 0xca, 0x31, 0x5c, 0xd7, 0xd2,
	0xbf, 0x7e, 0xda, 0x51, 0xc3, 0xff, 0xab, 0x4c, 0xaa, 0x3b, 0xa3, 0xcb, 0x24, 0x22, 0x93, 0xb7,
	0xca, 0xe1, 0x26, 0x97, 0xbc, 0x55, 0x2e, 0x33, 0xa7, 0x70, 0x77, 0x37, 0xf3, 0x33, 0xe0, 0xc9,
	0xd3, 0x3d, 0x3f, 0x9c, 0xce, 0x98, 0xdc, 0xd0, 0x32, 0x90, 0x1a, 0xd9, 0x30, 0x4b, 0x3a, 0x92,
	0x02, 0xde, 0xe6, 0xab, 0x16, 0xde, 0x25, 0x2e, 0x83, 0x09, 0x0c, 0xa4, 0xbe, 0xf5, 0xb6, 0x6e,
	0x6e, 0xbd, 0xed, 0xc1, 0x39, 0x67, 0xde, 0x40, 0x79, 0xd5, 0x10, 0x86, 0xdc, 0xc8, 0x5c, 0x0c,
	0xbc, 0xcf, 0xb9, 0x1a, 0x9c, 0xde, 0x34, 0xff, 0xda, 0xa7, 0x3e, 0x00, 0x3f, 0x4a, 0x6e, 0xae,
	0x68, 0x0b, 0x24, 0x63, 0x3f, 0x9b, 0xca, 0x9b, 0x91, 0xba, 0x67, 0xd3, 0xc2, 0xc4, 0xff, 0xbf,
	0x57, 0x92, 0xa7, 0x80, 0xdc, 0x38, 0x3a, 0x0a, 0x66, 0x22, 0xbf, 0xad, 0x3f, 0x01, 0xaf, 0x83,
	0x10, 0x2d, 0x12, 0x14, 0xc1, 0xa1, 0xbc, 0xea, 0xd0, 0x0f, 0x17, 0x47, 0xfe, 0x24, 0x5d, 0xc4,
	0x98, 0xe5, 0xa7, 0x41, 0x0b, 0x4a, 0xe0, 0x98, 0x92, 0xb0, 0x97, 0x5c, 0x61, 0x4e, 0x36, 0x68,
	0x86, 0x00, 0x23, 0x3e, 0x0a, 0x53, 0x7f, 0x92, 0x4a, 0x03, 0x4a, 0xc1, 0xb9, 0x8b, 0xbf, 0x6b,
	0xc0, 0x4f, 0xfa, 0xc5, 0xdf, 0x06, 0xbb, 0xad, 0x15, 0x1c, 0x4a, 0x10, 0xc9, 0xf9, 0xd6, 0xc1,
	0x93, 0x24, 0x00, 0xe7, 0x27, 0x44, 0x7e, 0x5d, 0x50, 0xe2, 0xa2, 0x58, 0x9e, 0xe3, 0x90, 0x69,
	0x73, 0x15, 0xc6, 0x70, 0xf5, 0xa3, 0x65, 0xad, 0x5c, 0xfd, 0xef, 0x08, 0x19, 0x95, 0x60, 0x08,
	0x9a, 0xdc, 0x3e, 0xe5, 0x6f, 0x03, 0x5e, 0x48, 0xad, 0xc4, 0xf9, 0x06, 0x69, 0x28, 0x9c, 0x38,
	0x16, 0x20, 0x7a, 0x52, 0x12, 0xc9, 0x19, 0x64, 0x37, 0x54, 0x43, 0xcb, 0x7a, 0x43, 0x7f, 0x6a,
	0x8d, 0x4b, 0x5f, 0x39, 0x1c, 0x36, 0xa9, 0x6a, 0x63, 0x51, 0x95, 0xf9, 0x5d, 0x35, 0xf2, 0x94,
	0x97, 0xc8, 0x73, 0x97, 0x34, 0x1f, 0xb2, 0x68, 0x26, 0xed, 0x03, 0xa1, 0x85, 0xea, 0x28, 0x30,
	0x6d, 0x47, 0x1e, 0x57, 0x11, 0x14, 0xf1, 0x25, 0x5c, 0x70, 0x13, 0x7e, 0xad, 0xf0, 0x26, 0xfc,
	0xa5, 0xbb, 0xd6, 0xd7, 0x8a, 0xee, 0x5a, 0x77, 0x48, 0x4b, 0xbb, 0xad, 0x5e, 0x88, 0xaf, 0x06,
	0x35, 0x70, 0xf6, 0xb7, 0x48, 0xe3, 0xdb, 0xfe, 0x83, 0x3d, 0x3f, 0x39, 0x61, 0xf2, 0x90, 0xe3,
	0xe7, 0x94, 0x8d, 0x8a, 0x84, 0xb8, 0xaf, 0x6a, 0x88, 0x6c, 0x23, 0xd9, 0x1b, 0xfc, 0x75, 0x39,
	0x42, 0xd2, 0xc4, 0x5d, 0x7e, 0x5d, 0xd5, 0xc0, 0xd7, 0x15, 0x9c, 0x8d, 0x02, 0xd1, 0x46, 0xc1,
	0xbe, 0x4f, 0xaa, 0xde, 0xa8, 0x9f, 0x6c, 0x36, 0x0d, 0xeb, 0x21, 0xfb, 0x1e, 0x2f, 0x14, 0x9f,
	0x82, 0x7a, 0xf6, 0x17, 0x49, 0x1d, 0xa7, 0xab, 0xcc, 0x4d, 0xd7, 0xd4, 0xb8, 0x83, 0xaa, 0x42,
	0x5e, 0x11, 0x67, 0x6f, 0xb2, 0xd9, 0x2e, 0xa8, 0x28, 0x0b, 0xed, 0x07, 0x64, 0x03, 0x27, 0x04,
	0x9b, 0x8a, 0xea, 0x1b, 0xcb, 0xd5, 0x73, 0x55, 0x6e, 0x7d, 0x93, 0x6c, 0x98, 0x84, 0x7a, 0xa5,
	0x5c, 0x27, 0x43, 0xb2, 0x61, 0xd2, 0xa9, 0xe0, 0xed, 0x2f, 0xe8, 0x6f, 0x67, 0xfe, 0x13, 0xf9,
	0x9e, 0xfe, 0xb9, 0x1f, 0x21, 0x0d, 0x45, 0xa6, 0x8b, 0xda, 0x51, 0xd1, 0x93, 0xa6, 0xfc, 0x58,
	0x36, 0x07, 0x5f, 0x32, 0x7d, 0xb8, 0x04, 0xf1, 0x53, 0x76, 0x1c, 0xc5, 0xe7, 0x72, 0xa6, 0x4a,
	0xd8, 0xf9, 0xef, 0x65, 0x91, 0xe3, 0xf8, 0xe2, 0x3d, 0x97, 0x7c, 0x8e, 0xec, 0xdc, 0x9a, 0x54,
	0xd1, 0xf7, 0x58, 0x38, 0x5d, 0x55, 0x26, 0x2b, 0x3f, 0x39, 0x31, 0xdc, 0x70, 0x35, 0xd3, 0x0d,
	0x07, 0x07, 0xe2, 0x60, 0xe3, 0x1f, 0xcf, 0x2a, 0x03, 0x00, 0x6b, 0x16, 0x6c, 0x6a, 0xa2, 0x21,
	0x80, 0x50, 0x3e, 0x7d, 0x54, 0x7d, 0x39, 0x7d, 0x94, 0xcc, 0xa4, 0xd5, 0xd0, 0x32, 0x69, 0xad,
	0xc8, 0x4e, 0x44, 0x56, 0x67, 0x27, 0x7a, 0x05, 0x27, 0xee, 0x6b, 0x5d, 0x97, 0x35, 0x25, 0x2d,
	0x6f, 0x38, 0x76, 0x57, 0x26, 0x06, 0x2d, 0x15, 0x24, 0x06, 0xbd, 0x4d, 0x1a, 0x2a, 0xc5, 0x8e,
	0x54, 0x37, 0x15, 0xa2, 0x30, 0xe5, 0xef, 0x13, 0xd2, 0x14, 0x7f, 0x11, 0x0e, 0x8a, 0xdc, 0xb5,
	0xb5, 0x8d, 0x4c, 0xc1, 0xb8, 0x45, 0xea, 0x9d, 0xf8, 0x78, 0x71, 0x26, 0x77, 0xbb, 0x1b, 0x54,
	0xc1, 0x85, 0x1f, 0xde, 0x11, 0x1f, 0x96, 0xaf, 0xaf, 0xbe, 0x0f, 0xf7, 0xa5, 0x6d, 0x76, 0xfe,
	0x67, 0x89, 0x54, 0xf9, 0x77, 0x2e, 0x3e, 0x85, 0xd9, 0xcf, 0xb6, 0x68, 0xe4, 0x41, 0x68, 0x0d,
	0x95, 0xcb, 0xbb, 0x5a, 0x59, 0xca, 0xbb, 0xfa, 0x0a, 0xa7, 0xf8, 0x5f, 0xeb, 0x22, 0x2f, 0xd0,
	0x06, 0x82, 0x59, 0xbf, 0x27, 0xf7, 0x03, 0x24, 0x28, 0xd6, 0x6f, 0xa0, 0x85, 0x10, 0x92, 0xb0,
	0x7e, 0x0b, 0xd8, 0xf9, 0xa9, 0x0a, 0xa9, 0xf7, 0x02, 0x1c, 0xbf, 0x57, 0xf2, 0xfb, 0xb7, 0x8d,
	0xcc, 0x9c, 0xd9, 0x89, 0x8c, 0xb6, 0x76, 0x1b, 0x62, 0x2e, 0x13, 0x50, 0xdb, 0xc8, 0x04, 0x04,
	0xf3, 0x08, 0x9a, 0x01, 0xec, 0x86, 0xe1, 0xef, 0x1a, 0x0a, 0x76, 0xb7, 0xb3, 0xd5, 0x47, 0x9d,
	0x7a, 0x30, 0x91, 0x60, 0xd3, 0x63, 0x82, 0x46, 0x75, 0x96, 0x45, 0xc3, 0x40, 0x72, 0x8a, 0x70,
	0x3a, 0x8e, 0x76, 0xc2, 0x29, 0x1e, 0x8e, 0x6e, 0x53, 0x0d, 0x63, 0xdf, 0x21, 0xd5, 0xce, 0xa1,
	0x2b, 0xd7, 0x23, 0x19, 0x6d, 0xdc, 0x39, 0x74, 0x29, 0xe0, 0x3f, 0xf5, 0x03, 0x9c, 0x3f, 0x5d,
	0x21, 0x95, 0xce, 0xa1, 0x0b, 0xbd, 0x4d, 0xd3, 0x38, 0x78, 0xba, 0x48, 0xb3, 0x09, 0xc8, 0x7b,
	0xab, 0x23, 0x8d, 0x5a, 0x9a, 0x40, 0x34, 0x91, 0xdc, 0x46, 0x55, 0x88, 0x5d, 0xd8, 0x9b, 0xc7,
	0xb9, 0x93, 0x47, 0x67, 0x63, 0x57, 0xd5, 0xc7, 0xee, 0x36, 0x69, 0x88, 0xf8, 0x18, 0x3e, 0x74,
	0x62, 0x64, 0x32, 0x04, 0x5f, 0x20, 0xb2, 0xa4, 0x4c, 0xfc, 0x91, 0xd3, 0xf8, 0x90, 0x85, 0xd3,
	0x28, 0x86, 0x86, 0xe3, 0x18, 0x64, 0x98, 0xac, 0x5c, 0x3b, 0x45, 0xab, 0x61, 0x38, 0x8b, 0x0a,
	0x08, 0xc3, 0x79, 0x1b, 0x54, 0xc1, 0x90, 0x47, 0x8e, 0x4d, 0xa2, 0x29, 0x9b, 0x8a, 0x7d, 0x1b,
	0xcc, 0xd9, 0xaf, 0xe3, 0xf4, 0x1b, 0x86, 0x9a, 0x82, 0x37, 0xe5, 0x0d, 0x43, 0x6a, 0xbb, 0xa7,
	0xa5, 0x6d, 0xf7, 0xc0, 0xff, 0xf8, 0x03, 0xef, 0x46, 0x5b, 0x78, 0xa2, 0x24, 0xec, 0xfc, 0x56,
	0x89, 0x54, 0xdd, 0x7d, 0xf7, 0xc1, 0xc5, 0xd6, 0xa7, 0xba, 0x46, 0xa0, 0x9c, 0xbb, 0x66, 0xe0,
	0x16, 0xa9, 0xab, 0xeb, 0x03, 0x70, 0x3f, 0x42, 0x5d, 0x1d, 0x70, 0x9b, 0x34, 0x60, 0xf7, 0x2f,
	0x3a, 0x65, 0x32, 0x39, 0x58, 0x86, 0xe0, 0x92, 0xee, 0x20, 0x61, 0x32, 0xc1, 0x3c, 0x3c, 0x8b,
	0xfc, 0x62, 0x78, 0x91, 0x30, 0xe4, 0x17, 0x13, 0xf7, 0xbf, 0xca, 0xd9, 0xbe, 0xbe, 0x7a, 0xb6,
	0xd7, 0x73, 0xb3, 0xfd, 0xf7, 0xaa, 0xa4, 0xca, 0xeb, 0x5d, 0x9c, 0x1c, 0x94, 0xb2, 0x74, 0x11,
	0x87, 0x90, 0xd6, 0x4c, 0x74, 0x4e, 0xc3, 0xc0, 0xad, 0x04, 0x31, 0x26, 0x25, 0x6a, 0x50, 0x78,
	0x86, 0x1b, 0x76, 0x22, 0xec, 0x4f, 0x79, 0x1c, 0x41, 0x32, 0x76, 0x19, 0x5d, 0x51, 0xee, 0x76,
	0xf1, 0xb2, 0xd7, 0x9f, 0x60, 0x13, 0xb9, 0xca, 0x4a, 0x10, 0x85, 0xbb, 0x5c, 0x65, 0xe1, 0x99,
	0xb7, 0x0f, 0x25, 0x05, 0x4e, 0xd9, 0x06, 0xcd, 0x10, 0xa2, 0x7d, 0x98, 0x76, 0x3c, 0x41, 0x7e,
	0xd1, 0x30, 0xe0, 0x14, 0x09, 0xc1, 0x55, 0x35, 0x8e, 0xa4, 0x07, 0x54, 0x21, 0x44, 0x6e, 0x2c,
	0x91, 0x0f, 0xd2, 0x0f, 0x8f, 0x17, 0xfe, 0xb1, 0x74, 0xc4, 0xe5, 0xd1, 0x5c, 0xbf, 0xde, 0xf3,
	0x13, 0x11, 0x35, 0x2a, 0x0e, 0x89, 0x8b, 0xad, 0x92, 0x1c, 0x96, 0xd7, 0xfb, 0x48, 0xa4, 0x36,
	0xf7, 0x21, 0x1c, 0x46, 0xe6, 0x85, 0xcc, 0x61, 0xf3, 0x9a, 0xc3, 0x46, 0x61, 0xe2, 0xc9, 0x9d,
	0xf0, 0x19, 0x9b, 0x45, 0x73, 0x36, 0x8e, 0xf0, 0xfc, 0x92, 0x86, 0xb1, 0x7f, 0x80, 0x54, 0x21,
	0x07, 0x9f, 0x65, 0x84, 0xe5, 0xf2, 0x21, 0x75, 0xfd, 0x38, 0xa5, 0x50, 0x68, 0x70, 0xe6, 0xd5,
	0x97, 0x70, 0xa6, 0x9d, 0xe3, 0xcc, 0x6c, 0x53, 0xbf, 0x01, 0x3b, 0x8f, 0x30, 0xf1, 0x66, 0xc1,
	0x33, 0x16, 0x9f, 0xc3, 0x00, 0x5d, 0x97, 0x13, 0x2f, 0xc3, 0x41, 0xd8, 0x14, 0xf4, 0x11, 0x33,
	0x76, 0x21, 0xe4, 0xfc, 0xfd, 0x12, 0xa9, 0xcb, 0x66, 0x69, 0x5b, 0x9a, 0xe2, 0xc3, 0x0f, 0xd4,
	0xc1, 0xa3, 0xb2, 0x91, 0xac, 0x50, 0xbe, 0x70, 0x5f, 0xcf, 0x76, 0x28, 0xcf, 0x20, 0x61, 0x36,
	0x7f, 0x19, 0xe3, 0xd6, 0xa0, 0x12, 0x84, 0x0b, 0xcb, 0x83, 0x19, 0x0b, 0xe5, 0xfd, 0x2b, 0x0d,
	0xaa, 0xe0, 0x5b, 0x5f, 0x23, 0xcd, 0xd7, 0x4c, 0x27, 0xe8, 0x74, 0x49, 0x93, 0x8b, 0x81, 0x3f,
	0x94, 0xe6, 0xe2, 0x6c, 0x93, 0x96, 0xf8, 0x08, 0x6a, 0x01, 0xab, 0xbf, 0xc2, 0x67, 0x34, 0xc6,
	0x7a, 0x94, 0xd1, 0x9a, 0x17, 0xa0, 0xf3, 0x1f, 0xcb, 0xa4, 0xee, 0x45, 0x47, 0xe9, 0x73, 0x3f,
	0xbe, 0x44, 0xda, 0x1c, 0x37, 0x8e, 0xa6, 0x8b, 0x89, 0x6c, 0x89, 0x04, 0x61, 0xbb, 0x18, 0x24,
	0xaa, 0xcc, 0xfa, 0x2a, 0x20, 0x7d, 0x55, 0xaf, 0x9a, 0x9b, 0x95, 0xef, 0x90, 0x0d, 0xc3, 0xdf,
	0x20, 0x53, 0x54, 0xe7, 0xb0, 0xb0, 0xdf, 0x01, 0x9a, 0x31, 0xc8, 0x76, 0xf4, 0xa9, 0x67, 0x18,
	0x08, 0xe4, 0x75, 0xfb, 0x94, 0x25, 0x8b, 0x59, 0x2a, 0xa5, 0x95, 0x86, 0x01, 0xc9, 0x20, 0x3c,
	0x73, 0x38, 0xd3, 0x25, 0x28, 0xd6, 0xa6, 0xe8, 0xb9, 0xcc, 0x63, 0x2e, 0x80, 0xec, 0x7f, 0xa0,
	0x12, 0x12, 0xfd, 0x7f, 0xd2, 0x95, 0x36, 0x8a, 0x52, 0xcc, 0x4f, 0xde, 0xa0, 0x02, 0xe0, 0x7f,
	0x79, 0xc2, 0x9e, 0x26, 0x41, 0xca, 0x50, 0x73, 0x96, 0x20, 0xe7, 0xce, 0x7d, 0x0f, 0x67, 0x6c,
	0x79, 0xdf, 0x73, 0xfe, 0xa0, 0xac, 0x1a, 0x74, 0x89, 0x7c, 0x31, 0x52, 0xf8, 0x97, 0xfb, 0xee,
	0x85, 0x17, 0x03, 0x69, 0x76, 0xcb, 0xb6, 0x1f, 0x86, 0x4a, 0xcc, 0x23, 0xb4, 0x94, 0x6e, 0x48,
	0x77, 0x68, 0x28, 0x5a, 0xac, 0xeb, 0xb4, 0xd0, 0xc6, 0xbb, 0xbe, 0x6a, 0xbc, 0x1b, 0xab, 0xc6,
	0x9b, 0x98, 0xe3, 0x5d, 0x4c, 0xb7, 0xbb, 0xa4, 0x09, 0x66, 0xb6, 0x90, 0x12, 0xa8, 0xd5, 0xe8,
	0x28, 0x55, 0x43, 0xc8, 0x18, 0xd4, 0x6e, 0x74, 0x94, 0xb8, 0x71, 0x25, 0x49, 0x43, 0x79, 0xc7,
	0x4d, 0x83, 0x2a, 0x18, 0xa9, 0x7f, 0x45, 0x51, 0xff, 0x2f, 0x97, 0x48, 0xb3, 0x1b, 0x33, 0xc8,
	0x4b, 0xe6, 0xcf, 0x92, 0x4b, 0xdc, 0x75, 0x87, 0xbc, 0x53, 0x36, 0x79, 0x87, 0xaf, 0x51, 0xb3,
	0xe8, 0xb9, 0x5a, 0xa3, 0x66, 0xd1, 0x73, 0xb5, 0xb8, 0x56, 0xb5, 0xc5, 0x95, 0xd3, 0xdc, 0x4f,
	0x92, 0xe7, 0x51, 0x3c, 0x55, 0xb7, 0xba, 0x20, 0x9c, 0x51, 0x64, 0x4d, 0xa3, 0x88, 0xf3, 0x37,
	0x4b, 0xa4, 0xe2, 0x79, 0x7b, 0x17, 0xe7, 0xdb, 0xd8, 0xeb, 0x78, 0xde, 0x9e, 0x94, 0x2b, 0x00,
	0x14, 0xb6, 0x4a, 0xfd, 0xa5, 0xaa, 0xd3, 0x5d, 0xd9, 0xa4, 0x35, 0xdd, 0x26, 0xbd, 0x43, 0x48,
	0x67, 0x76, 0x1c, 0xc5, 0x41, 0x7a, 0x72, 0x26, 0x9b, 0xa5, 0x61, 0xe0, 0xb0, 0xaf, 0x1c, 0x08,
	0xb1, 0xa7, 0xa1, 0x60, 0xe7, 0xcf, 0x97, 0x49, 0xfb, 0x70, 0x31, 0x0b, 0x59, 0x2c, 0x76, 0x6b,
	0xce, 0x2f, 0x9d, 0x0d, 0x49, 0x48, 0xed, 0xbb, 0xa4, 0x29, 0x83, 0xf4, 0x34, 0x5f, 0x95, 0x86,
	0x12, 0x8b, 0xcb, 0x33, 0x06, 0x61, 0x52, 0x55, 0xb9, 0xb8, 0x08, 0x18, 0xf8, 0x6e, 0xcb, 0x9b,
	0x44, 0x31, 0xc3, 0x1e, 0x49, 0x50, 0xa4, 0x7d, 0x9f, 0xb0, 0x24, 0x39, 0x64, 0x93, 0x34, 0x92,
	0xa9, 0xa4, 0x0d, 0x9c, 0xd0, 0x0f, 0xe3, 0x44, 0xf3, 0x4b, 0x29, 0x38, 0xa3, 0x5f, 0x5d, 0xa7,
	0xdf, 0x97, 0x32, 0x99, 0x89, 0x27, 0x2b, 0xe5, 0x6a, 0x29, 0xd1, 0x54, 0x55, 0x70, 0xfe, 0x52,
	0x19, 0xd2, 0xb2, 0xce, 0xa2, 0x20, 0xfd, 0xbe, 0x13, 0x45, 0x5e, 0xe1, 0x84, 0x4c, 0x07, 0xae,
	0x0e, 0xd5, 0xe4, 0x9a, 0xde, 0x64, 0xa9, 0x08, 0xad, 0x69, 0x8a, 0x10, 0xa4, 0xc8, 0x48, 0x4f,
	0xa2, 0x58, 0x3a, 0x21, 0x04, 0x04, 0xa1, 0x56, 0xe7, 0x73, 0xec, 0x32, 0x7f, 0x34, 0x62, 0x4b,
	0x1a, 0xb9, 0xd8, 0x12, 0x29, 0x98, 0x08, 0x6a, 0x90, 0x5c, 0x30, 0xe9, 0x04, 0x6a, 0x5e, 0x44,
	0xa0, 0xbf, 0x57, 0x26, 0xb5, 0xce, 0x8c, 0xc5, 0xe9, 0x6b, 0x78, 0x69, 0x2e, 0x26, 0x51, 0x71,
	0x42, 0x76, 0xcd, 0x96, 0x42, 0x8e, 0x91, 0xb6, 0x54, 0x61, 0x6e, 0x39, 0xdd, 0xc2, 0xc2, 0xb0,
	0x1b, 0xed, 0x8e, 0xeb, 0x61, 0x7f, 0x4c, 0x77, 0x24, 0x87, 0x00, 0x00, 0xb9, 0x06, 0x5c, 0xca,
	0xe6, 0x8b, 0x34, 0xcb, 0x31, 0xd2, 0xa0, 0x06, 0x6e, 0xe5, 0x0e, 0x6e, 0x3e, 0xca, 0x3c, 0x27,
	0xa9, 0xc5, 0xe0, 0xb6, 0xb4, 0xc1, 0xbd, 0xf7, 0xaf, 0x36, 0x44, 0x6c, 0x98, 0xdd, 0x26, 0x8d,
	0x51, 0xf7, 0x63, 0xa1, 0x94, 0x58, 0x9f, 0xb1, 0x5b, 0xa4, 0x3e, 0xea, 0x7e, 0xbc, 0xed, 0xa7,
	0x93, 0x13, 0xab, 0x64, 0x5f, 0x25, 0xed, 0x51, 0xf7, 0xe3, 0x6e, 0x14, 0x86, 0x22, 0x45, 0x98,
	0x55, 0xb1, 0xaf, 0x90, 0xe6, 0xa8, 0xfb, 0xf1, 0x4e, 0x7a, 0xc2, 0xe2, 0x90, 0xa5, 0xd6, 0xba,
	0x4d, 0xc8, 0xda, 0xa8, 0xfb, 0x71, 0x87, 0xba, 0x56, 0x1d, 0xdf, 0xee, 0x45, 0xe9, 0xfb, 0x8f,
	0xad, 0x86, 0x06, 0xbd, 0x6f, 0x11, 0x7c, 0x11, 0xa0, 0xc7, 0xfb, 0x9e, 0xd5, 0xb4, 0xdf, 0x20,
	0x57, 0x25, 0x62, 0x6f, 0x8c, 0xd1, 0xd3, 0x56, 0xcb, 0xde, 0x24, 0xd7, 0x97, 0xd0, 0x87, 0x7b,
	0x63, 0xab, 0x6d, 0xdf, 0x24, 0xd7, 0x96, 0x4a, 0xf6, 0xc6, 0xd6, 0x46, 0xe1, 0x2b, 0xc3, 0xdd,
	0x6d, 0xeb, 0x8a, 0x7d, 0x97, 0xdc, 0x96, 0x25, 0xe2, 0xe2, 0x2c, 0x7f, 0xee, 0xa7, 0x59, 0x38,
	0xbf, 0x65, 0xd9, 0x16, 0x69, 0xc9, 0x1a, 0x1d, 0x6f, 0x67, 0x60, 0x5d, 0xb5, 0xdf, 0x24, 0x6f,
	0x8c, 0xba, 0x1f, 0xc3, 0x51, 0x29, 0xff, 0x9c, 0xc5, 0x6a, 0xeb, 0xd3, 0xb2, 0xed, 0xeb, 0xc4,
	0xe2, 0x45, 0x83, 0x9e, 0x8b, 0x5b, 0x93, 0xfd, 0x9e, 0x75, 0x0d, 0xa9, 0xc4, 0xb1, 0x22, 0x5a,
	0xcb, 0xba, 0x6e, 0xdf, 0x21, 0xb7, 0x0a, 0xbf, 0x01, 0x56, 0x9d, 0xf5, 0x86, 0x6d, 0x93, 0x0d,
	0x8d, 0x8a, 0xdd, 0xb1, 0x6b, 0xdd, 0xc0, 0xee, 0x69, 0x38, 0xb0, 0x10, 0xac, 0x9b, 0xf6, 0x67,
	0xc9, 0x9b, 0x85, 0x1f, 0xeb, 0x87, 0x47, 0x91, 0xb5, 0x69, 0xdf, 0x22, 0x37, 0xf0, 0xf7, 0xde,
	0x79, 0xa2, 0x6f, 0x7e, 0x5b, 0x6f, 0xe2, 0x37, 0xa1, 0xc1, 0x7a, 0xc1, 0x2d, 0xfb, 0x06, 0xb1,
	0xb1, 0x40, 0x0b, 0x0f, 0xb2, 0xde, 0x92, 0x9d, 0x1f, 0xf4, 0xdc, 0xfd, 0xf8, 0x58, 0x6e, 0x0b,
	0x8d, 0x07, 0x87, 0xd6, 0x6d, 0xbb, 0x49, 0xd6, 0x47, 0xdd, 0x8f, 0xfb, 0xee, 0xb3, 0x0f, 0xac,
	0xcf, 0x62, 0x9f, 0x39, 0x20, 0xf6, 0xbe, 0xac, 0x3b, 0x59, 0xf9, 0x87, 0xd6, 0xe7, 0x90, 0xad,
	0xc4, 0xed, 0xec, 0xd6, 0x5d, 0x1d, 0xfc, 0xd0, 0xfa, 0xbc, 0xed, 0x90, 0x3b, 0x0a, 0x2c, 0xbc,
	0x7f, 0xdc, 0x72, 0x70, 0xe8, 0x56, 0x5e, 0xe7, 0x6d, 0xfd, 0x80, 0x7d, 0x8d, 0x5c, 0x51, 0x35,
	0xb0, 0x15, 0x6f, 0x23, 0x3b, 0x1e, 0xf4, 0x5c, 0xeb, 0x0b, 0xf8, 0x3c, 0xee, 0xba, 0xd6, 0x3b,
	0x38, 0xce, 0xea, 0x86, 0x5c, 0xeb, 0x8b, 0xd8, 0x5e, 0x8f, 0x13, 0xff, 0x5d, 0xac, 0xda, 0x1b,
	0x79, 0xd6, 0x0f, 0x4a, 0x76, 0xca, 0xdf, 0xcb, 0x69, 0xdd, 0xc3, 0x6e, 0x88, 0xbb, 0x25, 0xad,
	0x2f, 0x69, 0x20, 0x3d, 0xb4, 0xde, 0x93, 0xfc, 0x3e, 0xf2, 0x86, 0x1f, 0x59, 0x5f, 0xc6, 0x21,
	0xd6, 0x2e, 0x4d, 0xb4, 0xee, 0xcb, 0x17, 0xe0, 0xea, 0x43, 0xeb, 0x87, 0x90, 0x88, 0xd9, 0x75,
	0x74, 0xd6, 0x57, 0xf4, 0x1a, 0x1f, 0x5a, 0xef, 0x63, 0x17, 0xf5, 0x4b, 0xcf, 0xac, 0x2d, 0x6c,
	0xeb, 0x60, 0xd0, 0xb5, 0x1e, 0xe0, 0xf3, 0x68, 0xec, 0x5a, 0x1f, 0xe0, 0xb3, 0xd7, 0x77, 0xad,
	0x1f, 0x96, 0x83, 0xf1, 0x70, 0xe8, 0x5a, 0x1f, 0x62, 0x87, 0x96, 0x2e, 0xa0, 0xb1, 0x7e, 0x44,
	0x92, 0x50, 0xbb, 0x54, 0xc4, 0xfa, 0x2a, 0xf2, 0xc0, 0xf2, 0x4d, 0x23, 0xd6, 0xd7, 0xe4, 0xc0,
	0xad, 0xbe, 0x84, 0xc4, 0xfa, 0xba, 0xa4, 0xeb, 0xa8, 0xe3, 0x5a, 0xdf, 0x90, 0x7c, 0xa2, 0xee,
	0x01, 0xb1, 0xbe, 0x69, 0x7f, 0x9e, 0x7c, 0x76, 0x69, 0xf0, 0xf5, 0x7b, 0x2c, 0xac, 0x6f, 0xd9,
	0x9f, 0x23, 0x6f, 0xe5, 0xc6, 0xde, 0xa8, 0xf0, 0xff, 0xe1, 0x3f, 0xf6, 0xc6, 0x63, 0xd7, 0xfa,
	0x51, 0x14, 0x24, 0x66, 0x12, 0x71, 0xeb, 0xc7, 0xec, 0x0d, 0x42, 0xa0, 0xad, 0x90, 0x43, 0xd5,
	0xea, 0xa0, 0x00, 0x92, 0xd9, 0x48, 0xad, 0x6d, 0xa4, 0xb5, 0x48, 0x7a, 0x69, 0x75, 0x35, 0x5a,
	0xc8, 0x74, 0x69, 0x56, 0x0f, 0xc7, 0x14, 0x72, 0x53, 0x5a, 0x3b, 0x92, 0xb9, 0xbc, 0x6d, 0x6b,
	0x57, 0x8e, 0x42, 0x77, 0x68, 0x3d, 0xc4, 0xe6, 0x0c, 0xdd, 0x81, 0x67, 0xed, 0xe1, 0x67, 0x45,
	0xba, 0x31, 0xab, 0x8f, 0xa0, 0x48, 0x91, 0x65, 0x7d, 0x5b, 0x07, 0x1f, 0x58, 0x8f, 0xf0, 0x2b,
	0xdb, 0xbb, 0x3d, 0x6b, 0x80, 0xcf, 0x0f, 0xe9, 0x8e, 0x35, 0xc4, 0x2f, 0xee, 0xf6, 0x7a, 0x7d,
	0x6b, 0x84, 0x05, 0x3b, 0x1d, 0xd7, 0xda, 0xc7, 0xf7, 0x45, 0xe0, 0xb9, 0xe5, 0x62, 0xfb, 0xe0,
	0x90, 0x84, 0xf5, 0x58, 0x0a, 0x67, 0x3c, 0x32, 0x61, 0x51, 0x24, 0x8d, 0x19, 0xba, 0x66, 0x79,
	0x38, 0xc2, 0xcb, 0x41, 0xb0, 0xd6, 0xd8, 0x7e, 0x8b, 0xdc, 0x14, 0x5d, 0x5c, 0x4a, 0x0c, 0x68,
	0x1d, 0xa0, 0xd4, 0xc8, 0x85, 0x84, 0x58, 0x87, 0xd8, 0xc0, 0x6e, 0xdf, 0xb5, 0x9e, 0x60, 0xcb,
	0x77, 0x46, 0x7d, 0xd7, 0xfa, 0x08, 0x05, 0xa6, 0x61, 0xa1, 0x59, 0xdf, 0x91, 0x9d, 0xe3, 0xc0,
	0x77, 0x25, 0xbb, 0x0c, 0xc7, 0xae, 0xf5, 0xe3, 0x72, 0x91, 0x40, 0x0f, 0xb0, 0xf5, 0xff, 0x63,
	0x29, 0xb7, 0x59, 0xad, 0x3f, 0x92, 0x0d, 0xb4, 0x96, 0xcc, 0xda, 0xfa, 0xa3, 0xf8, 0x92, 0x54,
	0x0e, 0xac, 0x8f, 0x71, 0xe4, 0x51, 0xf5, 0xb6, 0xfe, 0x18, 0x4e, 0x45, 0x4d, 0x8d, 0xb7, 0x7c,
	0x39, 0x59, 0xbc, 0x3d, 0xeb, 0x29, 0xb6, 0xd2, 0x50, 0x46, 0xad, 0x09, 0x7e, 0x05, 0xf5, 0x30,
	0x6b, 0x8a, 0x12, 0x44, 0x6d, 0xe4, 0x59, 0x4c, 0x0e, 0xbb, 0x1f, 0xcc, 0xac, 0x23, 0x1c, 0x09,
	0xd0, 0x4a, 0xac, 0xe3, 0xed, 0xaf, 0xfd, 0xe3, 0xdf, 0xb9, 0x53, 0xfa, 0x8d, 0xdf, 0xb9, 0x53,
	0xfa, 0xd7, 0xbf, 0x73, 0xa7, 0xf4, 0x67, 0x7e, 0xf7, 0xce, 0x67, 0x7e, 0xe3, 0x77, 0xef, 0x7c,
	0xe6, 0xb7, 0x7e, 0xf7, 0xce, 0x67, 0x48, 0x63, 0x12, 0x9d, 0x09, 0xcd, 0x66, 0xbb, 0x39, 0x62,
	0xe9, 0xc4, 0x9f, 0xc3, 0x52, 0xed, 0x96, 0xbe, 0x5b, 0x03, 0xec, 0xd3, 0xb5, 0x39, 0x87, 0x1f,
	0xfc, 0xef, 0x00, 0x00, 0x00, 0xff, 0xff, 0x03, 0x48, 0x06, 0x19, 0x4f, 0x9e, 0x00, 0x00,
}

func (m *Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ContainsPayloads {
		i--
		if m.ContainsPayloads {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x22
	}
	if m.Type != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if len(m.InputSource) > 0 {
		i -= len(m.InputSource)
		copy(dAtA[i:], m.InputSource)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.InputSource)))
		i--
		dAtA[i] = 0x12
	}
	if m.Created != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Created))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Batch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Batch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Batch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ContainsPayloads {
		i--
		if m.ContainsPayloads {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x22
	}
	if m.TotalSize != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.TotalSize))
		i--
		dAtA[i] = 0x18
	}
	if m.MessageType != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.MessageType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ClientID) > 0 {
		i -= len(m.ClientID)
		copy(dAtA[i:], m.ClientID)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ClientID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PacketContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PacketContext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PacketContext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DstPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.DstPort))
		i--
		dAtA[i] = 0x20
	}
	if m.SrcPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SrcPort))
		i--
		dAtA[i] = 0x18
	}
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Connection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Connection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Connection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MeanWindowSize != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.MeanWindowSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.NumNSFlags != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.NumNSFlags))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.NumCWRFlags != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.NumCWRFlags))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.NumPSHFlags != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.NumPSHFlags))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.NumECEFlags != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.NumECEFlags))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.NumURGFlags != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.NumURGFlags))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.NumSYNFlags != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.NumSYNFlags))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.NumACKFlags != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.NumACKFlags))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.NumRSTFlags != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.NumRSTFlags))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.NumFINFlags != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.NumFINFlags))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.BytesClientToServer != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.BytesClientToServer))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.BytesServerToClient != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.BytesServerToClient))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.Duration != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Duration))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.TimestampLast != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.TimestampLast))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if len(m.UID) > 0 {
		i -= len(m.UID)
		copy(dAtA[i:], m.UID)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.UID)))
		i--
		dAtA[i] = 0x7a
	}
	if m.NumPackets != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.NumPackets))
		i--
		dAtA[i] = 0x70
	}
	if m.AppPayloadSize != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.AppPayloadSize))
		i--
		dAtA[i] = 0x68
	}
	if m.TotalSize != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.TotalSize))
		i--
		dAtA[i] = 0x60
	}
	if len(m.DstPort) > 0 {
		i -= len(m.DstPort)
		copy(dAtA[i:], m.DstPort)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstPort)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.SrcPort) > 0 {
		i -= len(m.SrcPort)
		copy(dAtA[i:], m.SrcPort)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcPort)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.DstMAC) > 0 {
		i -= len(m.DstMAC)
		copy(dAtA[i:], m.DstMAC)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstMAC)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SrcMAC) > 0 {
		i -= len(m.SrcMAC)
		copy(dAtA[i:], m.SrcMAC)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcMAC)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ApplicationProto) > 0 {
		i -= len(m.ApplicationProto)
		copy(dAtA[i:], m.ApplicationProto)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ApplicationProto)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TransportProto) > 0 {
		i -= len(m.TransportProto)
		copy(dAtA[i:], m.TransportProto)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.TransportProto)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.NetworkProto) > 0 {
		i -= len(m.NetworkProto)
		copy(dAtA[i:], m.NetworkProto)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.NetworkProto)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.LinkProto) > 0 {
		i -= len(m.LinkProto)
		copy(dAtA[i:], m.LinkProto)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.LinkProto)))
		i--
		dAtA[i] = 0x12
	}
	if m.TimestampFirst != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.TimestampFirst))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Ethernet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ethernet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ethernet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PayloadSize != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.PayloadSize))
		i--
		dAtA[i] = 0x30
	}
	if m.PayloadEntropy != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PayloadEntropy))))
		i--
		dAtA[i] = 0x29
	}
	if m.EthernetType != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.EthernetType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.DstMAC) > 0 {
		i -= len(m.DstMAC)
		copy(dAtA[i:], m.DstMAC)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstMAC)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SrcMAC) > 0 {
		i -= len(m.SrcMAC)
		copy(dAtA[i:], m.SrcMAC)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcMAC)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ARP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ARP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ARP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DstProtocolAddress) > 0 {
		i -= len(m.DstProtocolAddress)
		copy(dAtA[i:], m.DstProtocolAddress)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstProtocolAddress)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.DstHwAddress) > 0 {
		i -= len(m.DstHwAddress)
		copy(dAtA[i:], m.DstHwAddress)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstHwAddress)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.SrcProtocolAddress) > 0 {
		i -= len(m.SrcProtocolAddress)
		copy(dAtA[i:], m.SrcProtocolAddress)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcProtocolAddress)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SrcHwAddress) > 0 {
		i -= len(m.SrcHwAddress)
		copy(dAtA[i:], m.SrcHwAddress)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcHwAddress)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Operation != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Operation))
		i--
		dAtA[i] = 0x30
	}
	if m.ProtocolAddressSize != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.ProtocolAddressSize))
		i--
		dAtA[i] = 0x28
	}
	if m.HwAddressSize != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.HwAddressSize))
		i--
		dAtA[i] = 0x20
	}
	if m.Protocol != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Protocol))
		i--
		dAtA[i] = 0x18
	}
	if m.AddrType != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.AddrType))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Dot1Q) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dot1Q) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Dot1Q) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x28
	}
	if m.VLANIdentifier != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.VLANIdentifier))
		i--
		dAtA[i] = 0x20
	}
	if m.DropEligible {
		i--
		if m.DropEligible {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Priority != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Dot11) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dot11) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Dot11) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HTControl != nil {
		{
			size, err := m.HTControl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.QOS != nil {
		{
			size, err := m.QOS.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.Checksum != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Checksum))
		i--
		dAtA[i] = 0x60
	}
	if m.FragmentNumber != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.FragmentNumber))
		i--
		dAtA[i] = 0x58
	}
	if m.SequenceNumber != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SequenceNumber))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Address4) > 0 {
		i -= len(m.Address4)
		copy(dAtA[i:], m.Address4)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Address4)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Address3) > 0 {
		i -= len(m.Address3)
		copy(dAtA[i:], m.Address3)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Address3)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Address2) > 0 {
		i -= len(m.Address2)
		copy(dAtA[i:], m.Address2)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Address2)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Address1) > 0 {
		i -= len(m.Address1)
		copy(dAtA[i:], m.Address1)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Address1)))
		i--
		dAtA[i] = 0x32
	}
	if m.DurationID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.DurationID))
		i--
		dAtA[i] = 0x28
	}
	if m.Flags != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Flags))
		i--
		dAtA[i] = 0x20
	}
	if m.Proto != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Proto))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Dot11QOS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dot11QOS) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Dot11QOS) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TXOP != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.TXOP))
		i--
		dAtA[i] = 0x20
	}
	if m.AckPolicy != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.AckPolicy))
		i--
		dAtA[i] = 0x18
	}
	if m.EOSP {
		i--
		if m.EOSP {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.TID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.TID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Dot11HTControl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dot11HTControl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Dot11HTControl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HT != nil {
		{
			size, err := m.HT.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.VHT != nil {
		{
			size, err := m.VHT.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.RDGMorePPDU {
		i--
		if m.RDGMorePPDU {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.ACConstraint {
		i--
		if m.ACConstraint {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Dot11HTControlVHT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dot11HTControlVHT) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Dot11HTControlVHT) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FbTXBeamformed {
		i--
		if m.FbTXBeamformed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.CodingType != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.CodingType))
		i--
		dAtA[i] = 0x48
	}
	if m.GID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.GID))
		i--
		dAtA[i] = 0x40
	}
	if m.MFSI != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.MFSI))
		i--
		dAtA[i] = 0x38
	}
	if m.STBCIndication {
		i--
		if m.STBCIndication {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.CompressedMSI != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.CompressedMSI))
		i--
		dAtA[i] = 0x28
	}
	if m.MFB != nil {
		{
			size, err := m.MFB.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.MSI != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.MSI))
		i--
		dAtA[i] = 0x18
	}
	if m.UnsolicitedMFB {
		i--
		if m.UnsolicitedMFB {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.MRQ {
		i--
		if m.MRQ {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Dot11HTControlHT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dot11HTControlHT) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Dot11HTControlHT) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DEI {
		i--
		if m.DEI {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.NDPAnnouncement {
		i--
		if m.NDPAnnouncement {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.CSISteering != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.CSISteering))
		i--
		dAtA[i] = 0x20
	}
	if m.CalibrationSequence != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.CalibrationSequence))
		i--
		dAtA[i] = 0x18
	}
	if m.CalibrationPosition != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.CalibrationPosition))
		i--
		dAtA[i] = 0x10
	}
	if m.LinkAdapationControl != nil {
		{
			size, err := m.LinkAdapationControl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Dot11HTControlMFB) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dot11HTControlMFB) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Dot11HTControlMFB) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SNR != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SNR))
		i--
		dAtA[i] = 0x20
	}
	if m.BW != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.BW))
		i--
		dAtA[i] = 0x18
	}
	if m.VHTMCS != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.VHTMCS))
		i--
		dAtA[i] = 0x10
	}
	if m.NumSTS != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.NumSTS))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Dot11LinkAdapationControl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dot11LinkAdapationControl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Dot11LinkAdapationControl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MFB != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.MFB))
		i--
		dAtA[i] = 0x30
	}
	if m.ASEL != nil {
		{
			size, err := m.ASEL.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.MFSI != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.MFSI))
		i--
		dAtA[i] = 0x20
	}
	if m.MSI != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.MSI))
		i--
		dAtA[i] = 0x18
	}
	if m.MRQ {
		i--
		if m.MRQ {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.TRQ {
		i--
		if m.TRQ {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Dot11ASEL) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dot11ASEL) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Dot11ASEL) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Data))
		i--
		dAtA[i] = 0x10
	}
	if m.Command != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Command))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LinkLayerDiscovery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinkLayerDiscovery) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LinkLayerDiscovery) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.TTL != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.TTL))
		i--
		dAtA[i] = 0x20
	}
	if m.PortID != nil {
		{
			size, err := m.PortID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ChassisID != nil {
		{
			size, err := m.ChassisID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LLDPChassisID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LLDPChassisID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LLDPChassisID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Subtype != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Subtype))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LLDPPortID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LLDPPortID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LLDPPortID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Subtype != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Subtype))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LinkLayerDiscoveryValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinkLayerDiscoveryValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LinkLayerDiscoveryValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Length != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EthernetCTP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EthernetCTP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EthernetCTP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SkipCount != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SkipCount))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EthernetCTPReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EthernetCTPReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EthernetCTPReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x22
	}
	if m.ReceiptNumber != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.ReceiptNumber))
		i--
		dAtA[i] = 0x18
	}
	if m.Function != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Function))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LinkLayerDiscoveryInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinkLayerDiscoveryInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LinkLayerDiscoveryInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Unknown) > 0 {
		for iNdEx := len(m.Unknown) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Unknown[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.OrgTLVs) > 0 {
		for iNdEx := len(m.OrgTLVs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OrgTLVs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.MgmtAddress != nil {
		{
			size, err := m.MgmtAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.SysCapabilities != nil {
		{
			size, err := m.SysCapabilities.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SysDescription) > 0 {
		i -= len(m.SysDescription)
		copy(dAtA[i:], m.SysDescription)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SysDescription)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SysName) > 0 {
		i -= len(m.SysName)
		copy(dAtA[i:], m.SysName)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SysName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PortDescription) > 0 {
		i -= len(m.PortDescription)
		copy(dAtA[i:], m.PortDescription)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.PortDescription)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LLDPSysCapabilities) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LLDPSysCapabilities) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LLDPSysCapabilities) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EnabledCap != nil {
		{
			size, err := m.EnabledCap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SystemCap != nil {
		{
			size, err := m.SystemCap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LLDPCapabilities) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LLDPCapabilities) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LLDPCapabilities) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TMPR {
		i--
		if m.TMPR {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.SVLAN {
		i--
		if m.SVLAN {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.CVLAN {
		i--
		if m.CVLAN {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.StationOnly {
		i--
		if m.StationOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.DocSis {
		i--
		if m.DocSis {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Phone {
		i--
		if m.Phone {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Router {
		i--
		if m.Router {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.WLANAP {
		i--
		if m.WLANAP {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Bridge {
		i--
		if m.Bridge {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Repeater {
		i--
		if m.Repeater {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Other {
		i--
		if m.Other {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LLDPMgmtAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LLDPMgmtAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LLDPMgmtAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OID) > 0 {
		i -= len(m.OID)
		copy(dAtA[i:], m.OID)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.OID)))
		i--
		dAtA[i] = 0x2a
	}
	if m.InterfaceNumber != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.InterfaceNumber))
		i--
		dAtA[i] = 0x20
	}
	if m.InterfaceSubtype != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.InterfaceSubtype))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if m.Subtype != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Subtype))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LLDPOrgSpecificTLV) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LLDPOrgSpecificTLV) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LLDPOrgSpecificTLV) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Info) > 0 {
		i -= len(m.Info)
		copy(dAtA[i:], m.Info)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Info)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SubType != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SubType))
		i--
		dAtA[i] = 0x10
	}
	if m.OUI != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.OUI))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IPv4) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPv4) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPv4) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DstPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.DstPort))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.SrcPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SrcPort))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.PayloadSize != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.PayloadSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.PayloadEntropy != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PayloadEntropy))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x81
	}
	if len(m.Options) > 0 {
		for iNdEx := len(m.Options) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Options[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if len(m.Padding) > 0 {
		i -= len(m.Padding)
		copy(dAtA[i:], m.Padding)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Padding)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x62
	}
	if m.Checksum != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Checksum))
		i--
		dAtA[i] = 0x58
	}
	if m.Protocol != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Protocol))
		i--
		dAtA[i] = 0x50
	}
	if m.TTL != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.TTL))
		i--
		dAtA[i] = 0x48
	}
	if m.FragOffset != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.FragOffset))
		i--
		dAtA[i] = 0x40
	}
	if m.Flags != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Flags))
		i--
		dAtA[i] = 0x38
	}
	if m.Id != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x30
	}
	if m.Length != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x28
	}
	if m.TOS != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.TOS))
		i--
		dAtA[i] = 0x20
	}
	if m.IHL != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.IHL))
		i--
		dAtA[i] = 0x18
	}
	if m.Version != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IPv4Option) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPv4Option) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPv4Option) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OptionData) > 0 {
		i -= len(m.OptionData)
		copy(dAtA[i:], m.OptionData)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.OptionData)))
		i--
		dAtA[i] = 0x1a
	}
	if m.OptionLength != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.OptionLength))
		i--
		dAtA[i] = 0x10
	}
	if m.OptionType != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.OptionType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IPv6) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPv6) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPv6) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DstPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.DstPort))
		i--
		dAtA[i] = 0x70
	}
	if m.SrcPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SrcPort))
		i--
		dAtA[i] = 0x68
	}
	if m.HopByHop != nil {
		{
			size, err := m.HopByHop.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.PayloadSize != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.PayloadSize))
		i--
		dAtA[i] = 0x58
	}
	if m.PayloadEntropy != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PayloadEntropy))))
		i--
		dAtA[i] = 0x51
	}
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x42
	}
	if m.HopLimit != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.HopLimit))
		i--
		dAtA[i] = 0x38
	}
	if m.NextHeader != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.NextHeader))
		i--
		dAtA[i] = 0x30
	}
	if m.Length != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x28
	}
	if m.FlowLabel != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.FlowLabel))
		i--
		dAtA[i] = 0x20
	}
	if m.TrafficClass != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.TrafficClass))
		i--
		dAtA[i] = 0x18
	}
	if m.Version != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IPv6Fragment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPv6Fragment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPv6Fragment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x52
	}
	if m.DstPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.DstPort))
		i--
		dAtA[i] = 0x48
	}
	if m.SrcPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SrcPort))
		i--
		dAtA[i] = 0x40
	}
	if m.Identification != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Identification))
		i--
		dAtA[i] = 0x38
	}
	if m.MoreFragments {
		i--
		if m.MoreFragments {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Reserved2 != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Reserved2))
		i--
		dAtA[i] = 0x28
	}
	if m.FragmentOffset != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.FragmentOffset))
		i--
		dAtA[i] = 0x20
	}
	if m.Reserved1 != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Reserved1))
		i--
		dAtA[i] = 0x18
	}
	if m.NextHeader != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.NextHeader))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ICMPv4) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ICMPv4) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ICMPv4) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x32
	}
	if m.Seq != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x28
	}
	if m.Id != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x20
	}
	if m.Checksum != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Checksum))
		i--
		dAtA[i] = 0x18
	}
	if m.TypeCode != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.TypeCode))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ICMPv6) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ICMPv6) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ICMPv6) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x22
	}
	if m.Checksum != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Checksum))
		i--
		dAtA[i] = 0x18
	}
	if m.TypeCode != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.TypeCode))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ICMPv6NeighborAdvertisement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ICMPv6NeighborAdvertisement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ICMPv6NeighborAdvertisement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Options) > 0 {
		for iNdEx := len(m.Options) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Options[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.TargetAddress) > 0 {
		i -= len(m.TargetAddress)
		copy(dAtA[i:], m.TargetAddress)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.TargetAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Flags != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Flags))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ICMPv6RouterAdvertisement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ICMPv6RouterAdvertisement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ICMPv6RouterAdvertisement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Options) > 0 {
		for iNdEx := len(m.Options) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Options[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.RetransTimer != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.RetransTimer))
		i--
		dAtA[i] = 0x30
	}
	if m.ReachableTime != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.ReachableTime))
		i--
		dAtA[i] = 0x28
	}
	if m.RouterLifetime != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.RouterLifetime))
		i--
		dAtA[i] = 0x20
	}
	if m.Flags != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Flags))
		i--
		dAtA[i] = 0x18
	}
	if m.HopLimit != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.HopLimit))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ICMPv6Option) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ICMPv6Option) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ICMPv6Option) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UDP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UDP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UDP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x42
	}
	if m.PayloadSize != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.PayloadSize))
		i--
		dAtA[i] = 0x38
	}
	if m.PayloadEntropy != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PayloadEntropy))))
		i--
		dAtA[i] = 0x31
	}
	if m.Checksum != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Checksum))
		i--
		dAtA[i] = 0x28
	}
	if m.Length != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x20
	}
	if m.DstPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.DstPort))
		i--
		dAtA[i] = 0x18
	}
	if m.SrcPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SrcPort))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TCP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TCP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TCP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.PayloadSize != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.PayloadSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.PayloadEntropy != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PayloadEntropy))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa9
	}
	if len(m.Options) > 0 {
		for iNdEx := len(m.Options) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Options[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.Padding) > 0 {
		i -= len(m.Padding)
		copy(dAtA[i:], m.Padding)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Padding)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.Urgent != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Urgent))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.Checksum != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Checksum))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.Window != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Window))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.NS {
		i--
		if m.NS {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.CWR {
		i--
		if m.CWR {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.ECE {
		i--
		if m.ECE {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.URG {
		i--
		if m.URG {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.ACK {
		i--
		if m.ACK {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.PSH {
		i--
		if m.PSH {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.RST {
		i--
		if m.RST {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.SYN {
		i--
		if m.SYN {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.FIN {
		i--
		if m.FIN {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.DataOffset != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.DataOffset))
		i--
		dAtA[i] = 0x30
	}
	if m.AckNum != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.AckNum))
		i--
		dAtA[i] = 0x28
	}
	if m.SeqNum != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SeqNum))
		i--
		dAtA[i] = 0x20
	}
	if m.DstPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.DstPort))
		i--
		dAtA[i] = 0x18
	}
	if m.SrcPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SrcPort))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TCPOption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TCPOption) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TCPOption) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OptionData) > 0 {
		i -= len(m.OptionData)
		copy(dAtA[i:], m.OptionData)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.OptionData)))
		i--
		dAtA[i] = 0x1a
	}
	if m.OptionLength != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.OptionLength))
		i--
		dAtA[i] = 0x10
	}
	if m.OptionType != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.OptionType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SCTP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCTP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCTP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x32
	}
	if m.Checksum != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Checksum))
		i--
		dAtA[i] = 0x28
	}
	if m.VerificationTag != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.VerificationTag))
		i--
		dAtA[i] = 0x20
	}
	if m.DstPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.DstPort))
		i--
		dAtA[i] = 0x18
	}
	if m.SrcPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SrcPort))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DNS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DNS) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DNS) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DstPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.DstPort))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.SrcPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SrcPort))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.Additionals) > 0 {
		for iNdEx := len(m.Additionals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Additionals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.Authorities) > 0 {
		for iNdEx := len(m.Authorities) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Authorities[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.Answers) > 0 {
		for iNdEx := len(m.Answers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Answers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.Questions) > 0 {
		for iNdEx := len(m.Questions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Questions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if m.ARCount != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.ARCount))
		i--
		dAtA[i] = 0x70
	}
	if m.NSCount != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.NSCount))
		i--
		dAtA[i] = 0x68
	}
	if m.ANCount != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.ANCount))
		i--
		dAtA[i] = 0x60
	}
	if m.QDCount != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.QDCount))
		i--
		dAtA[i] = 0x58
	}
	if m.ResponseCode != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.ResponseCode))
		i--
		dAtA[i] = 0x50
	}
	if m.Z != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Z))
		i--
		dAtA[i] = 0x48
	}
	if m.RA {
		i--
		if m.RA {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.RD {
		i--
		if m.RD {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.TC {
		i--
		if m.TC {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.AA {
		i--
		if m.AA {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.OpCode != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.OpCode))
		i--
		dAtA[i] = 0x20
	}
	if m.QR {
		i--
		if m.QR {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.ID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DNSResourceRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DNSResourceRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DNSResourceRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TXTs) > 0 {
		for iNdEx := len(m.TXTs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TXTs[iNdEx])
			copy(dAtA[i:], m.TXTs[iNdEx])
			i = encodeVarintNetcap(dAtA, i, uint64(len(m.TXTs[iNdEx])))
			i--
			dAtA[i] = 0x72
		}
	}
	if m.MX != nil {
		{
			size, err := m.MX.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.SRV != nil {
		{
			size, err := m.SRV.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.SOA != nil {
		{
			size, err := m.SOA.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.PTR) > 0 {
		i -= len(m.PTR)
		copy(dAtA[i:], m.PTR)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.PTR)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.CNAME) > 0 {
		i -= len(m.CNAME)
		copy(dAtA[i:], m.CNAME)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.CNAME)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.NS) > 0 {
		i -= len(m.NS)
		copy(dAtA[i:], m.NS)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.NS)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.IP) > 0 {
		i -= len(m.IP)
		copy(dAtA[i:], m.IP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.IP)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x32
	}
	if m.DataLength != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.DataLength))
		i--
		dAtA[i] = 0x28
	}
	if m.TTL != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.TTL))
		i--
		dAtA[i] = 0x20
	}
	if m.Class != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Class))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DNSSOA) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DNSSOA) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DNSSOA) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Minimum != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Minimum))
		i--
		dAtA[i] = 0x38
	}
	if m.Expire != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Expire))
		i--
		dAtA[i] = 0x30
	}
	if m.Retry != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Retry))
		i--
		dAtA[i] = 0x28
	}
	if m.Refresh != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Refresh))
		i--
		dAtA[i] = 0x20
	}
	if m.Serial != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Serial))
		i--
		dAtA[i] = 0x18
	}
	if len(m.RName) > 0 {
		i -= len(m.RName)
		copy(dAtA[i:], m.RName)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.RName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MName) > 0 {
		i -= len(m.MName)
		copy(dAtA[i:], m.MName)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.MName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DNSSRV) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DNSSRV) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DNSSRV) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if m.Port != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x18
	}
	if m.Weight != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Weight))
		i--
		dAtA[i] = 0x10
	}
	if m.Priority != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DNSMX) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DNSMX) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DNSMX) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Preference != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Preference))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DNSQuestion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DNSQuestion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DNSQuestion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Class != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Class))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DHCPv4) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHCPv4) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHCPv4) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DstPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.DstPort))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.SrcPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SrcPort))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.Fingerprint) > 0 {
		i -= len(m.Fingerprint)
		copy(dAtA[i:], m.Fingerprint)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Fingerprint)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.Options) > 0 {
		for iNdEx := len(m.Options) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Options[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.File) > 0 {
		i -= len(m.File)
		copy(dAtA[i:], m.File)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.File)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.ServerName) > 0 {
		i -= len(m.ServerName)
		copy(dAtA[i:], m.ServerName)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ServerName)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.ClientHWAddr) > 0 {
		i -= len(m.ClientHWAddr)
		copy(dAtA[i:], m.ClientHWAddr)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ClientHWAddr)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.RelayAgentIP) > 0 {
		i -= len(m.RelayAgentIP)
		copy(dAtA[i:], m.RelayAgentIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.RelayAgentIP)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.NextServerIP) > 0 {
		i -= len(m.NextServerIP)
		copy(dAtA[i:], m.NextServerIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.NextServerIP)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.YourClientIP) > 0 {
		i -= len(m.YourClientIP)
		copy(dAtA[i:], m.YourClientIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.YourClientIP)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.ClientIP) > 0 {
		i -= len(m.ClientIP)
		copy(dAtA[i:], m.ClientIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ClientIP)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Flags != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Flags))
		i--
		dAtA[i] = 0x40
	}
	if m.Secs != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Secs))
		i--
		dAtA[i] = 0x38
	}
	if m.Xid != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Xid))
		i--
		dAtA[i] = 0x30
	}
	if m.HardwareOpts != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.HardwareOpts))
		i--
		dAtA[i] = 0x28
	}
	if m.HardwareLen != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.HardwareLen))
		i--
		dAtA[i] = 0x20
	}
	if m.HardwareType != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.HardwareType))
		i--
		dAtA[i] = 0x18
	}
	if m.Operation != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Operation))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DHCPOption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHCPOption) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHCPOption) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Length != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DHCPv6) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHCPv6) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHCPv6) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DstPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.DstPort))
		i--
		dAtA[i] = 0x60
	}
	if m.SrcPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SrcPort))
		i--
		dAtA[i] = 0x58
	}
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Fingerprint) > 0 {
		i -= len(m.Fingerprint)
		copy(dAtA[i:], m.Fingerprint)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Fingerprint)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Options) > 0 {
		for iNdEx := len(m.Options) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Options[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.TransactionID) > 0 {
		i -= len(m.TransactionID)
		copy(dAtA[i:], m.TransactionID)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.TransactionID)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.PeerAddr) > 0 {
		i -= len(m.PeerAddr)
		copy(dAtA[i:], m.PeerAddr)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.PeerAddr)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.LinkAddr) > 0 {
		i -= len(m.LinkAddr)
		copy(dAtA[i:], m.LinkAddr)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.LinkAddr)))
		i--
		dAtA[i] = 0x22
	}
	if m.HopCount != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.HopCount))
		i--
		dAtA[i] = 0x18
	}
	if m.MsgType != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.MsgType))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DHCPv6Option) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHCPv6Option) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHCPv6Option) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Length != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x10
	}
	if m.Code != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LLC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LLC) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LLC) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Control != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Control))
		i--
		dAtA[i] = 0x30
	}
	if m.CR {
		i--
		if m.CR {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.SSAP != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SSAP))
		i--
		dAtA[i] = 0x20
	}
	if m.IG {
		i--
		if m.IG {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.DSAP != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.DSAP))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NTP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NTP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NTP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DstPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.DstPort))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.SrcPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SrcPort))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.ExtensionBytes) > 0 {
		i -= len(m.ExtensionBytes)
		copy(dAtA[i:], m.ExtensionBytes)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ExtensionBytes)))
		i--
		dAtA[i] = 0x7a
	}
	if m.TransmitTimestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.TransmitTimestamp))
		i--
		dAtA[i] = 0x70
	}
	if m.ReceiveTimestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.ReceiveTimestamp))
		i--
		dAtA[i] = 0x68
	}
	if m.OriginTimestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.OriginTimestamp))
		i--
		dAtA[i] = 0x60
	}
	if m.ReferenceTimestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.ReferenceTimestamp))
		i--
		dAtA[i] = 0x58
	}
	if m.ReferenceID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.ReferenceID))
		i--
		dAtA[i] = 0x50
	}
	if m.RootDispersion != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.RootDispersion))
		i--
		dAtA[i] = 0x48
	}
	if m.RootDelay != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.RootDelay))
		i--
		dAtA[i] = 0x40
	}
	if m.Precision != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Precision))
		i--
		dAtA[i] = 0x38
	}
	if m.Poll != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Poll))
		i--
		dAtA[i] = 0x30
	}
	if m.Stratum != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Stratum))
		i--
		dAtA[i] = 0x28
	}
	if m.Mode != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x20
	}
	if m.Version != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x18
	}
	if m.LeapIndicator != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.LeapIndicator))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SIP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SIP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SIP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DstPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.DstPort))
		i--
		dAtA[i] = 0x58
	}
	if m.SrcPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SrcPort))
		i--
		dAtA[i] = 0x50
	}
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ResponseStatus) > 0 {
		i -= len(m.ResponseStatus)
		copy(dAtA[i:], m.ResponseStatus)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ResponseStatus)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ResponseCode != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.ResponseCode))
		i--
		dAtA[i] = 0x30
	}
	if m.IsResponse {
		i--
		if m.IsResponse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Headers) > 0 {
		for iNdEx := len(m.Headers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Headers[iNdEx])
			copy(dAtA[i:], m.Headers[iNdEx])
			i = encodeVarintNetcap(dAtA, i, uint64(len(m.Headers[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Method != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Method))
		i--
		dAtA[i] = 0x18
	}
	if m.Version != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IGMP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IGMP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IGMP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x72
	}
	if m.Version != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x68
	}
	if len(m.GroupRecords) > 0 {
		for iNdEx := len(m.GroupRecords) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GroupRecords[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.NumberOfSources != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.NumberOfSources))
		i--
		dAtA[i] = 0x58
	}
	if m.NumberOfGroupRecords != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.NumberOfGroupRecords))
		i--
		dAtA[i] = 0x50
	}
	if len(m.SourceAddresses) > 0 {
		for iNdEx := len(m.SourceAddresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SourceAddresses[iNdEx])
			copy(dAtA[i:], m.SourceAddresses[iNdEx])
			i = encodeVarintNetcap(dAtA, i, uint64(len(m.SourceAddresses[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.IntervalTime != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.IntervalTime))
		i--
		dAtA[i] = 0x40
	}
	if m.RobustnessValue != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.RobustnessValue))
		i--
		dAtA[i] = 0x38
	}
	if m.SupressRouterProcessing {
		i--
		if m.SupressRouterProcessing {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.GroupAddress) > 0 {
		i -= len(m.GroupAddress)
		copy(dAtA[i:], m.GroupAddress)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.GroupAddress)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Checksum != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Checksum))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxResponseTime != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.MaxResponseTime))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IGMPv3GroupRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IGMPv3GroupRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IGMPv3GroupRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SourceAddresses) > 0 {
		for iNdEx := len(m.SourceAddresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SourceAddresses[iNdEx])
			copy(dAtA[i:], m.SourceAddresses[iNdEx])
			i = encodeVarintNetcap(dAtA, i, uint64(len(m.SourceAddresses[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.MulticastAddress) > 0 {
		i -= len(m.MulticastAddress)
		copy(dAtA[i:], m.MulticastAddress)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.MulticastAddress)))
		i--
		dAtA[i] = 0x22
	}
	if m.NumberOfSources != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.NumberOfSources))
		i--
		dAtA[i] = 0x18
	}
	if m.AuxDataLen != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.AuxDataLen))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IPv6HopByHop) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPv6HopByHop) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPv6HopByHop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Options) > 0 {
		for iNdEx := len(m.Options) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Options[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IPv6HopByHopOption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPv6HopByHopOption) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPv6HopByHopOption) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OptionAlignment != nil {
		{
			size, err := m.OptionAlignment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.OptionData) > 0 {
		i -= len(m.OptionData)
		copy(dAtA[i:], m.OptionData)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.OptionData)))
		i--
		dAtA[i] = 0x22
	}
	if m.ActualLength != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.ActualLength))
		i--
		dAtA[i] = 0x18
	}
	if m.OptionLength != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.OptionLength))
		i--
		dAtA[i] = 0x10
	}
	if m.OptionType != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.OptionType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IPv6HopByHopOptionAlignment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPv6HopByHopOptionAlignment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPv6HopByHopOptionAlignment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Two != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Two))
		i--
		dAtA[i] = 0x10
	}
	if m.One != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.One))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SNAP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SNAP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SNAP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if len(m.OrganizationalCode) > 0 {
		i -= len(m.OrganizationalCode)
		copy(dAtA[i:], m.OrganizationalCode)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.OrganizationalCode)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ICMPv6Echo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ICMPv6Echo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ICMPv6Echo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x22
	}
	if m.SeqNumber != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SeqNumber))
		i--
		dAtA[i] = 0x18
	}
	if m.Identifier != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Identifier))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ICMPv6NeighborSolicitation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ICMPv6NeighborSolicitation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ICMPv6NeighborSolicitation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Options) > 0 {
		for iNdEx := len(m.Options) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Options[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.TargetAddress) > 0 {
		i -= len(m.TargetAddress)
		copy(dAtA[i:], m.TargetAddress)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.TargetAddress)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ICMPv6RouterSolicitation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ICMPv6RouterSolicitation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ICMPv6RouterSolicitation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Options) > 0 {
		for iNdEx := len(m.Options) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Options[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HTTP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HTTP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HTTP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ResponseBody) > 0 {
		i -= len(m.ResponseBody)
		copy(dAtA[i:], m.ResponseBody)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ResponseBody)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if len(m.RequestBody) > 0 {
		i -= len(m.RequestBody)
		copy(dAtA[i:], m.RequestBody)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.RequestBody)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	if len(m.Parameters) > 0 {
		for k := range m.Parameters {
			v := m.Parameters[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintNetcap(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintNetcap(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintNetcap(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xe2
		}
	}
	if len(m.ResponseHeader) > 0 {
		for k := range m.ResponseHeader {
			v := m.ResponseHeader[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintNetcap(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintNetcap(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintNetcap(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xda
		}
	}
	if len(m.RequestHeader) > 0 {
		for k := range m.RequestHeader {
			v := m.RequestHeader[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintNetcap(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintNetcap(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintNetcap(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.ResContentTypeDetected) > 0 {
		i -= len(m.ResContentTypeDetected)
		copy(dAtA[i:], m.ResContentTypeDetected)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ResContentTypeDetected)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.ContentTypeDetected) > 0 {
		i -= len(m.ContentTypeDetected)
		copy(dAtA[i:], m.ContentTypeDetected)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ContentTypeDetected)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.TLSDoneAfter != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.TLSDoneAfter))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.FirstByteAfter != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.FirstByteAfter))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.DNSDoneAfter != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.DNSDoneAfter))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.DoneAfter != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.DoneAfter))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if len(m.ResContentType) > 0 {
		i -= len(m.ResContentType)
		copy(dAtA[i:], m.ResContentType)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ResContentType)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.ResCookies) > 0 {
		for iNdEx := len(m.ResCookies) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResCookies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.ServerName) > 0 {
		i -= len(m.ServerName)
		copy(dAtA[i:], m.ServerName)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ServerName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.ResContentEncoding) > 0 {
		i -= len(m.ResContentEncoding)
		copy(dAtA[i:], m.ResContentEncoding)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ResContentEncoding)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.ReqContentEncoding) > 0 {
		i -= len(m.ReqContentEncoding)
		copy(dAtA[i:], m.ReqContentEncoding)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ReqContentEncoding)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x6a
	}
	if m.StatusCode != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.StatusCode))
		i--
		dAtA[i] = 0x60
	}
	if len(m.ContentType) > 0 {
		i -= len(m.ContentType)
		copy(dAtA[i:], m.ContentType)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ContentType)))
		i--
		dAtA[i] = 0x5a
	}
	if m.ResContentLength != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.ResContentLength))
		i--
		dAtA[i] = 0x50
	}
	if len(m.URL) > 0 {
		i -= len(m.URL)
		copy(dAtA[i:], m.URL)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.URL)))
		i--
		dAtA[i] = 0x4a
	}
	if m.ReqContentLength != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.ReqContentLength))
		i--
		dAtA[i] = 0x40
	}
	if len(m.ReqCookies) > 0 {
		for iNdEx := len(m.ReqCookies) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ReqCookies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Referer) > 0 {
		i -= len(m.Referer)
		copy(dAtA[i:], m.Referer)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Referer)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.UserAgent) > 0 {
		i -= len(m.UserAgent)
		copy(dAtA[i:], m.UserAgent)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.UserAgent)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Host) > 0 {
		i -= len(m.Host)
		copy(dAtA[i:], m.Host)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Host)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Method) > 0 {
		i -= len(m.Method)
		copy(dAtA[i:], m.Method)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Method)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Proto) > 0 {
		i -= len(m.Proto)
		copy(dAtA[i:], m.Proto)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Proto)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HTTPCookie) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HTTPCookie) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HTTPCookie) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SameSite != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SameSite))
		i--
		dAtA[i] = 0x48
	}
	if m.HttpOnly {
		i--
		if m.HttpOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.Secure {
		i--
		if m.Secure {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.MaxAge != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.MaxAge))
		i--
		dAtA[i] = 0x30
	}
	if m.Expires != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Expires))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Domain) > 0 {
		i -= len(m.Domain)
		copy(dAtA[i:], m.Domain)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Domain)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLSClientHello) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLSClientHello) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLSClientHello) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Extensions) > 0 {
		dAtA20 := make([]byte, len(m.Extensions)*10)
		var j19 int
		for _, num1 := range m.Extensions {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA20[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA20[j19] = uint8(num)
			j19++
		}
		i -= j19
		copy(dAtA[i:], dAtA20[:j19])
		i = encodeVarintNetcap(dAtA, i, uint64(j19))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if m.DstPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.DstPort))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.SrcPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SrcPort))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if len(m.DstMAC) > 0 {
		i -= len(m.DstMAC)
		copy(dAtA[i:], m.DstMAC)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstMAC)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.SrcMAC) > 0 {
		i -= len(m.SrcMAC)
		copy(dAtA[i:], m.SrcMAC)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcMAC)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.Ja3) > 0 {
		i -= len(m.Ja3)
		copy(dAtA[i:], m.Ja3)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Ja3)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.ALPNs) > 0 {
		for iNdEx := len(m.ALPNs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ALPNs[iNdEx])
			copy(dAtA[i:], m.ALPNs[iNdEx])
			i = encodeVarintNetcap(dAtA, i, uint64(len(m.ALPNs[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.SupportedPoints) > 0 {
		dAtA22 := make([]byte, len(m.SupportedPoints)*10)
		var j21 int
		for _, num1 := range m.SupportedPoints {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA22[j21] = uint8(num)
			j21++
		}
		i -= j21
		copy(dAtA[i:], dAtA22[:j21])
		i = encodeVarintNetcap(dAtA, i, uint64(j21))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.SupportedGroups) > 0 {
		dAtA24 := make([]byte, len(m.SupportedGroups)*10)
		var j23 int
		for _, num1 := range m.SupportedGroups {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA24[j23] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j23++
			}
			dAtA24[j23] = uint8(num)
			j23++
		}
		i -= j23
		copy(dAtA[i:], dAtA24[:j23])
		i = encodeVarintNetcap(dAtA, i, uint64(j23))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.SignatureAlgs) > 0 {
		dAtA26 := make([]byte, len(m.SignatureAlgs)*10)
		var j25 int
		for _, num1 := range m.SignatureAlgs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA26[j25] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j25++
			}
			dAtA26[j25] = uint8(num)
			j25++
		}
		i -= j25
		copy(dAtA[i:], dAtA26[:j25])
		i = encodeVarintNetcap(dAtA, i, uint64(j25))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.CompressMethods) > 0 {
		dAtA28 := make([]byte, len(m.CompressMethods)*10)
		var j27 int
		for _, num1 := range m.CompressMethods {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA28[j27] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j27++
			}
			dAtA28[j27] = uint8(num)
			j27++
		}
		i -= j27
		copy(dAtA[i:], dAtA28[:j27])
		i = encodeVarintNetcap(dAtA, i, uint64(j27))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.CipherSuites) > 0 {
		dAtA30 := make([]byte, len(m.CipherSuites)*10)
		var j29 int
		for _, num1 := range m.CipherSuites {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA30[j29] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j29++
			}
			dAtA30[j29] = uint8(num)
			j29++
		}
		i -= j29
		copy(dAtA[i:], dAtA30[:j29])
		i = encodeVarintNetcap(dAtA, i, uint64(j29))
		i--
		dAtA[i] = 0x7a
	}
	if m.OSCP {
		i--
		if m.OSCP {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if len(m.SNI) > 0 {
		i -= len(m.SNI)
		copy(dAtA[i:], m.SNI)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SNI)))
		i--
		dAtA[i] = 0x6a
	}
	if m.ExtensionLen != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.ExtensionLen))
		i--
		dAtA[i] = 0x60
	}
	if m.CipherSuiteLen != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.CipherSuiteLen))
		i--
		dAtA[i] = 0x58
	}
	if len(m.SessionID) > 0 {
		i -= len(m.SessionID)
		copy(dAtA[i:], m.SessionID)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SessionID)))
		i--
		dAtA[i] = 0x52
	}
	if m.SessionIDLen != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SessionIDLen))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Random) > 0 {
		i -= len(m.Random)
		copy(dAtA[i:], m.Random)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Random)))
		i--
		dAtA[i] = 0x42
	}
	if m.HandshakeVersion != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.HandshakeVersion))
		i--
		dAtA[i] = 0x38
	}
	if m.HandshakeLen != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.HandshakeLen))
		i--
		dAtA[i] = 0x30
	}
	if m.HandshakeType != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.HandshakeType))
		i--
		dAtA[i] = 0x28
	}
	if m.MessageLen != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.MessageLen))
		i--
		dAtA[i] = 0x20
	}
	if m.Version != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLSServerHello) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLSServerHello) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLSServerHello) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ja3S) > 0 {
		i -= len(m.Ja3S)
		copy(dAtA[i:], m.Ja3S)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Ja3S)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	if m.DstPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.DstPort))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.SrcPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SrcPort))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if len(m.DstMAC) > 0 {
		i -= len(m.DstMAC)
		copy(dAtA[i:], m.DstMAC)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstMAC)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if len(m.SrcMAC) > 0 {
		i -= len(m.SrcMAC)
		copy(dAtA[i:], m.SrcMAC)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcMAC)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.Extensions) > 0 {
		dAtA32 := make([]byte, len(m.Extensions)*10)
		var j31 int
		for _, num1 := range m.Extensions {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA32[j31] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j31++
			}
			dAtA32[j31] = uint8(num)
			j31++
		}
		i -= j31
		copy(dAtA[i:], dAtA32[:j31])
		i = encodeVarintNetcap(dAtA, i, uint64(j31))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.SelectedGroup != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SelectedGroup))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if len(m.Cookie) > 0 {
		i -= len(m.Cookie)
		copy(dAtA[i:], m.Cookie)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Cookie)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.SelectedIdentity != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SelectedIdentity))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.SelectedIdentityPresent {
		i--
		if m.SelectedIdentityPresent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.SupportedVersion != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SupportedVersion))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if len(m.Scts) > 0 {
		for iNdEx := len(m.Scts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Scts[iNdEx])
			copy(dAtA[i:], m.Scts[iNdEx])
			i = encodeVarintNetcap(dAtA, i, uint64(len(m.Scts[iNdEx])))
			i--
			dAtA[i] = 0x7a
		}
	}
	if m.Ems {
		i--
		if m.Ems {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if len(m.AlpnProtocol) > 0 {
		i -= len(m.AlpnProtocol)
		copy(dAtA[i:], m.AlpnProtocol)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.AlpnProtocol)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.SecureRenegotiation) > 0 {
		i -= len(m.SecureRenegotiation)
		copy(dAtA[i:], m.SecureRenegotiation)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SecureRenegotiation)))
		i--
		dAtA[i] = 0x62
	}
	if m.SecureRenegotiationSupported {
		i--
		if m.SecureRenegotiationSupported {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.TicketSupported {
		i--
		if m.TicketSupported {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.OCSPStapling {
		i--
		if m.OCSPStapling {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.NextProtos) > 0 {
		for iNdEx := len(m.NextProtos) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NextProtos[iNdEx])
			copy(dAtA[i:], m.NextProtos[iNdEx])
			i = encodeVarintNetcap(dAtA, i, uint64(len(m.NextProtos[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.NextProtoNeg {
		i--
		if m.NextProtoNeg {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.CompressionMethod != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.CompressionMethod))
		i--
		dAtA[i] = 0x30
	}
	if m.CipherSuite != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.CipherSuite))
		i--
		dAtA[i] = 0x28
	}
	if len(m.SessionID) > 0 {
		i -= len(m.SessionID)
		copy(dAtA[i:], m.SessionID)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SessionID)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Random) > 0 {
		i -= len(m.Random)
		copy(dAtA[i:], m.Random)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Random)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Version != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IPSecAH) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPSecAH) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPSecAH) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.AuthenticationData) > 0 {
		i -= len(m.AuthenticationData)
		copy(dAtA[i:], m.AuthenticationData)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.AuthenticationData)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Seq != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x20
	}
	if m.SPI != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SPI))
		i--
		dAtA[i] = 0x18
	}
	if m.Reserved != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Reserved))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IPSecESP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPSecESP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPSecESP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x2a
	}
	if m.LenEncrypted != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.LenEncrypted))
		i--
		dAtA[i] = 0x20
	}
	if m.Seq != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x18
	}
	if m.SPI != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SPI))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Geneve) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Geneve) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Geneve) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Options) > 0 {
		for iNdEx := len(m.Options) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Options[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.VNI != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.VNI))
		i--
		dAtA[i] = 0x38
	}
	if m.Protocol != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Protocol))
		i--
		dAtA[i] = 0x30
	}
	if m.CriticalOption {
		i--
		if m.CriticalOption {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.OAMPacket {
		i--
		if m.OAMPacket {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.OptionsLength != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.OptionsLength))
		i--
		dAtA[i] = 0x18
	}
	if m.Version != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GeneveOption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GeneveOption) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GeneveOption) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Length != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x20
	}
	if m.Flags != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Flags))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Class != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Class))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VXLAN) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VXLAN) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VXLAN) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GBPGroupPolicyID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.GBPGroupPolicyID))
		i--
		dAtA[i] = 0x38
	}
	if m.GBPApplied {
		i--
		if m.GBPApplied {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.GBPDontLearn {
		i--
		if m.GBPDontLearn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.GBPExtension {
		i--
		if m.GBPExtension {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.VNI != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.VNI))
		i--
		dAtA[i] = 0x18
	}
	if m.ValidIDFlag {
		i--
		if m.ValidIDFlag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *USB) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *USB) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *USB) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.IsoNumDesc != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.IsoNumDesc))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.UrbCopyOfTransferFlags != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.UrbCopyOfTransferFlags))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.UrbStartFrame != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.UrbStartFrame))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.UrbInterval != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.UrbInterval))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.UrbDataLength != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.UrbDataLength))
		i--
		dAtA[i] = 0x78
	}
	if m.UrbLength != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.UrbLength))
		i--
		dAtA[i] = 0x70
	}
	if m.Status != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x68
	}
	if m.Data {
		i--
		if m.Data {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.Setup {
		i--
		if m.Setup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.TimestampUsec != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.TimestampUsec))
		i--
		dAtA[i] = 0x50
	}
	if m.TimestampSec != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.TimestampSec))
		i--
		dAtA[i] = 0x48
	}
	if m.BusID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.BusID))
		i--
		dAtA[i] = 0x40
	}
	if m.DeviceAddress != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.DeviceAddress))
		i--
		dAtA[i] = 0x38
	}
	if m.EndpointNumber != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.EndpointNumber))
		i--
		dAtA[i] = 0x30
	}
	if m.Direction != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Direction))
		i--
		dAtA[i] = 0x28
	}
	if m.TransferType != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.TransferType))
		i--
		dAtA[i] = 0x20
	}
	if m.EventType != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.EventType))
		i--
		dAtA[i] = 0x18
	}
	if m.ID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *USBRequestBlockSetup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *USBRequestBlockSetup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *USBRequestBlockSetup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Length != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x30
	}
	if m.Index != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x28
	}
	if m.Value != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x20
	}
	if m.Request != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Request))
		i--
		dAtA[i] = 0x18
	}
	if m.RequestType != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.RequestType))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LCM) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LCM) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LCM) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DstPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.DstPort))
		i--
		dAtA[i] = 0x68
	}
	if m.SrcPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SrcPort))
		i--
		dAtA[i] = 0x60
	}
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x52
	}
	if m.Fragmented {
		i--
		if m.Fragmented {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.ChannelName) > 0 {
		i -= len(m.ChannelName)
		copy(dAtA[i:], m.ChannelName)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ChannelName)))
		i--
		dAtA[i] = 0x42
	}
	if m.TotalFragments != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.TotalFragments))
		i--
		dAtA[i] = 0x38
	}
	if m.FragmentNumber != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.FragmentNumber))
		i--
		dAtA[i] = 0x30
	}
	if m.FragmentOffset != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.FragmentOffset))
		i--
		dAtA[i] = 0x28
	}
	if m.PayloadSize != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.PayloadSize))
		i--
		dAtA[i] = 0x20
	}
	if m.SequenceNumber != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SequenceNumber))
		i--
		dAtA[i] = 0x18
	}
	if m.Magic != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Magic))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MPLS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MPLS) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MPLS) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TTL != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.TTL))
		i--
		dAtA[i] = 0x28
	}
	if m.StackBottom {
		i--
		if m.StackBottom {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.TrafficClass != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.TrafficClass))
		i--
		dAtA[i] = 0x18
	}
	if m.Label != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Label))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Modbus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Modbus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Modbus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DstPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.DstPort))
		i--
		dAtA[i] = 0x60
	}
	if m.SrcPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SrcPort))
		i--
		dAtA[i] = 0x58
	}
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x4a
	}
	if m.FunctionCode != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.FunctionCode))
		i--
		dAtA[i] = 0x40
	}
	if m.Exception {
		i--
		if m.Exception {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x32
	}
	if m.UnitID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.UnitID))
		i--
		dAtA[i] = 0x28
	}
	if m.Length != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x20
	}
	if m.ProtocolID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.ProtocolID))
		i--
		dAtA[i] = 0x18
	}
	if m.TransactionID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.TransactionID))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OSPFv2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OSPFv2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OSPFv2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x7a
	}
	if m.HelloV2 != nil {
		{
			size, err := m.HelloV2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.DbDesc != nil {
		{
			size, err := m.DbDesc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if len(m.LSR) > 0 {
		for iNdEx := len(m.LSR) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LSR[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.LSU != nil {
		{
			size, err := m.LSU.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.LSAs) > 0 {
		for iNdEx := len(m.LSAs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LSAs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.Authentication != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Authentication))
		i--
		dAtA[i] = 0x48
	}
	if m.AuType != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.AuType))
		i--
		dAtA[i] = 0x40
	}
	if m.Checksum != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Checksum))
		i--
		dAtA[i] = 0x38
	}
	if m.AreaID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.AreaID))
		i--
		dAtA[i] = 0x30
	}
	if m.RouterID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.RouterID))
		i--
		dAtA[i] = 0x28
	}
	if m.PacketLength != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.PacketLength))
		i--
		dAtA[i] = 0x20
	}
	if m.Type != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if m.Version != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HelloPkg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HelloPkg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HelloPkg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NeighborID) > 0 {
		dAtA37 := make([]byte, len(m.NeighborID)*10)
		var j36 int
		for _, num := range m.NeighborID {
			for num >= 1<<7 {
				dAtA37[j36] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j36++
			}
			dAtA37[j36] = uint8(num)
			j36++
		}
		i -= j36
		copy(dAtA[i:], dAtA37[:j36])
		i = encodeVarintNetcap(dAtA, i, uint64(j36))
		i--
		dAtA[i] = 0x42
	}
	if m.BackupDesignatedRouterID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.BackupDesignatedRouterID))
		i--
		dAtA[i] = 0x38
	}
	if m.DesignatedRouterID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.DesignatedRouterID))
		i--
		dAtA[i] = 0x30
	}
	if m.RouterDeadInterval != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.RouterDeadInterval))
		i--
		dAtA[i] = 0x28
	}
	if m.HelloInterval != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.HelloInterval))
		i--
		dAtA[i] = 0x20
	}
	if m.Options != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Options))
		i--
		dAtA[i] = 0x18
	}
	if m.RtrPriority != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.RtrPriority))
		i--
		dAtA[i] = 0x10
	}
	if m.InterfaceID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.InterfaceID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HelloPkgV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HelloPkgV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HelloPkgV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NetworkMask != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.NetworkMask))
		i--
		dAtA[i] = 0x48
	}
	if len(m.NeighborID) > 0 {
		dAtA39 := make([]byte, len(m.NeighborID)*10)
		var j38 int
		for _, num := range m.NeighborID {
			for num >= 1<<7 {
				dAtA39[j38] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j38++
			}
			dAtA39[j38] = uint8(num)
			j38++
		}
		i -= j38
		copy(dAtA[i:], dAtA39[:j38])
		i = encodeVarintNetcap(dAtA, i, uint64(j38))
		i--
		dAtA[i] = 0x42
	}
	if m.BackupDesignatedRouterID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.BackupDesignatedRouterID))
		i--
		dAtA[i] = 0x38
	}
	if m.DesignatedRouterID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.DesignatedRouterID))
		i--
		dAtA[i] = 0x30
	}
	if m.RouterDeadInterval != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.RouterDeadInterval))
		i--
		dAtA[i] = 0x28
	}
	if m.HelloInterval != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.HelloInterval))
		i--
		dAtA[i] = 0x20
	}
	if m.Options != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Options))
		i--
		dAtA[i] = 0x18
	}
	if m.RtrPriority != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.RtrPriority))
		i--
		dAtA[i] = 0x10
	}
	if m.InterfaceID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.InterfaceID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DbDescPkg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DbDescPkg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DbDescPkg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LSAinfo) > 0 {
		for iNdEx := len(m.LSAinfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LSAinfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.DDSeqNumber != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.DDSeqNumber))
		i--
		dAtA[i] = 0x20
	}
	if m.Flags != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Flags))
		i--
		dAtA[i] = 0x18
	}
	if m.InterfaceMTU != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.InterfaceMTU))
		i--
		dAtA[i] = 0x10
	}
	if m.Options != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Options))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OSPFv3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OSPFv3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OSPFv3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.LSAs) > 0 {
		for iNdEx := len(m.LSAs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LSAs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if m.LSU != nil {
		{
			size, err := m.LSU.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if len(m.LSR) > 0 {
		for iNdEx := len(m.LSR) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LSR[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.DbDesc != nil {
		{
			size, err := m.DbDesc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Hello != nil {
		{
			size, err := m.Hello.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Reserved != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Reserved))
		i--
		dAtA[i] = 0x48
	}
	if m.Instance != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Instance))
		i--
		dAtA[i] = 0x40
	}
	if m.Checksum != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Checksum))
		i--
		dAtA[i] = 0x38
	}
	if m.AreaID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.AreaID))
		i--
		dAtA[i] = 0x30
	}
	if m.RouterID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.RouterID))
		i--
		dAtA[i] = 0x28
	}
	if m.PacketLength != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.PacketLength))
		i--
		dAtA[i] = 0x20
	}
	if m.Type != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if m.Version != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LSAheader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LSAheader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LSAheader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LSOptions != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.LSOptions))
		i--
		dAtA[i] = 0x40
	}
	if m.Length != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x38
	}
	if m.LSChecksum != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.LSChecksum))
		i--
		dAtA[i] = 0x30
	}
	if m.LSSeqNumber != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.LSSeqNumber))
		i--
		dAtA[i] = 0x28
	}
	if m.AdvRouter != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.AdvRouter))
		i--
		dAtA[i] = 0x20
	}
	if m.LinkStateID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.LinkStateID))
		i--
		dAtA[i] = 0x18
	}
	if m.LSType != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.LSType))
		i--
		dAtA[i] = 0x10
	}
	if m.LSAge != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.LSAge))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LSA) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LSA) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LSA) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x5a
	}
	if m.IntraAPrefixLSA != nil {
		{
			size, err := m.IntraAPrefixLSA.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.LLSA != nil {
		{
			size, err := m.LLSA.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.ASELSA != nil {
		{
			size, err := m.ASELSA.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.IARouterLSA != nil {
		{
			size, err := m.IARouterLSA.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.InterAPrefixLSA != nil {
		{
			size, err := m.InterAPrefixLSA.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.NLSA != nil {
		{
			size, err := m.NLSA.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.RLSA != nil {
		{
			size, err := m.RLSA.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ASELSAV2 != nil {
		{
			size, err := m.ASELSAV2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.RLSAV2 != nil {
		{
			size, err := m.RLSAV2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LSReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LSReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LSReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AdvRouter != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.AdvRouter))
		i--
		dAtA[i] = 0x18
	}
	if m.LSID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.LSID))
		i--
		dAtA[i] = 0x10
	}
	if m.LSType != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.LSType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LSUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LSUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LSUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LSAs) > 0 {
		for iNdEx := len(m.LSAs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LSAs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.NumOfLSAs != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.NumOfLSAs))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IntraAreaPrefixLSA) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IntraAreaPrefixLSA) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IntraAreaPrefixLSA) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Prefixes) > 0 {
		for iNdEx := len(m.Prefixes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Prefixes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.RefAdvRouter != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.RefAdvRouter))
		i--
		dAtA[i] = 0x20
	}
	if m.RefLinkStateID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.RefLinkStateID))
		i--
		dAtA[i] = 0x18
	}
	if m.RefLSType != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.RefLSType))
		i--
		dAtA[i] = 0x10
	}
	if m.NumOfPrefixes != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.NumOfPrefixes))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ASExternalLSA) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ASExternalLSA) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ASExternalLSA) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RefLinkStateID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.RefLinkStateID))
		i--
		dAtA[i] = 0x48
	}
	if m.ExternalRouteTag != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.ExternalRouteTag))
		i--
		dAtA[i] = 0x40
	}
	if len(m.ForwardingAddress) > 0 {
		i -= len(m.ForwardingAddress)
		copy(dAtA[i:], m.ForwardingAddress)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ForwardingAddress)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.AddressPrefix) > 0 {
		i -= len(m.AddressPrefix)
		copy(dAtA[i:], m.AddressPrefix)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.AddressPrefix)))
		i--
		dAtA[i] = 0x32
	}
	if m.RefLSType != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.RefLSType))
		i--
		dAtA[i] = 0x28
	}
	if m.PrefixOptions != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.PrefixOptions))
		i--
		dAtA[i] = 0x20
	}
	if m.PrefixLength != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.PrefixLength))
		i--
		dAtA[i] = 0x18
	}
	if m.Metric != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Metric))
		i--
		dAtA[i] = 0x10
	}
	if m.Flags != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Flags))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InterAreaPrefixLSA) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterAreaPrefixLSA) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterAreaPrefixLSA) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AddressPrefix) > 0 {
		i -= len(m.AddressPrefix)
		copy(dAtA[i:], m.AddressPrefix)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.AddressPrefix)))
		i--
		dAtA[i] = 0x22
	}
	if m.PrefixOptions != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.PrefixOptions))
		i--
		dAtA[i] = 0x18
	}
	if m.PrefixLength != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.PrefixLength))
		i--
		dAtA[i] = 0x10
	}
	if m.Metric != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Metric))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InterAreaRouterLSA) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterAreaRouterLSA) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterAreaRouterLSA) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DestinationRouterID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.DestinationRouterID))
		i--
		dAtA[i] = 0x18
	}
	if m.Metric != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Metric))
		i--
		dAtA[i] = 0x10
	}
	if m.Options != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Options))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ASExternalLSAV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ASExternalLSAV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ASExternalLSAV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExternalRouteTag != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.ExternalRouteTag))
		i--
		dAtA[i] = 0x28
	}
	if m.ForwardingAddress != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.ForwardingAddress))
		i--
		dAtA[i] = 0x20
	}
	if m.Metric != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Metric))
		i--
		dAtA[i] = 0x18
	}
	if m.ExternalBit != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.ExternalBit))
		i--
		dAtA[i] = 0x10
	}
	if m.NetworkMask != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.NetworkMask))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RouterLSA) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouterLSA) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouterLSA) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Routers) > 0 {
		for iNdEx := len(m.Routers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Routers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Options != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Options))
		i--
		dAtA[i] = 0x10
	}
	if m.Flags != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Flags))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Router) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Router) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Router) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NeighborRouterID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.NeighborRouterID))
		i--
		dAtA[i] = 0x28
	}
	if m.NeighborInterfaceID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.NeighborInterfaceID))
		i--
		dAtA[i] = 0x20
	}
	if m.InterfaceID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.InterfaceID))
		i--
		dAtA[i] = 0x18
	}
	if m.Metric != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Metric))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RouterLSAV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouterLSAV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouterLSAV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Routers) > 0 {
		for iNdEx := len(m.Routers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Routers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Links != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Links))
		i--
		dAtA[i] = 0x10
	}
	if m.Flags != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Flags))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RouterV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouterV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouterV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metric != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Metric))
		i--
		dAtA[i] = 0x20
	}
	if m.LinkData != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.LinkData))
		i--
		dAtA[i] = 0x18
	}
	if m.LinkID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.LinkID))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NetworkLSA) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkLSA) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkLSA) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AttachedRouter) > 0 {
		dAtA54 := make([]byte, len(m.AttachedRouter)*10)
		var j53 int
		for _, num := range m.AttachedRouter {
			for num >= 1<<7 {
				dAtA54[j53] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j53++
			}
			dAtA54[j53] = uint8(num)
			j53++
		}
		i -= j53
		copy(dAtA[i:], dAtA54[:j53])
		i = encodeVarintNetcap(dAtA, i, uint64(j53))
		i--
		dAtA[i] = 0x12
	}
	if m.Options != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Options))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LinkLSA) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinkLSA) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LinkLSA) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Prefixes) > 0 {
		for iNdEx := len(m.Prefixes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Prefixes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.NumOfPrefixes != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.NumOfPrefixes))
		i--
		dAtA[i] = 0x20
	}
	if len(m.LinkLocalAddress) > 0 {
		i -= len(m.LinkLocalAddress)
		copy(dAtA[i:], m.LinkLocalAddress)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.LinkLocalAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Options != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Options))
		i--
		dAtA[i] = 0x10
	}
	if m.RtrPriority != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.RtrPriority))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LSAPrefix) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LSAPrefix) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LSAPrefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AddressPrefix) > 0 {
		i -= len(m.AddressPrefix)
		copy(dAtA[i:], m.AddressPrefix)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.AddressPrefix)))
		i--
		dAtA[i] = 0x22
	}
	if m.Metric != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Metric))
		i--
		dAtA[i] = 0x18
	}
	if m.PrefixOptions != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.PrefixOptions))
		i--
		dAtA[i] = 0x10
	}
	if m.PrefixLength != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.PrefixLength))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BFD) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BFD) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BFD) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AuthHeader != nil {
		{
			size, err := m.AuthHeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.RequiredMinEchoRxInterval != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.RequiredMinEchoRxInterval))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.RequiredMinRxInterval != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.RequiredMinRxInterval))
		i--
		dAtA[i] = 0x78
	}
	if m.DesiredMinTxInterval != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.DesiredMinTxInterval))
		i--
		dAtA[i] = 0x70
	}
	if m.YourDiscriminator != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.YourDiscriminator))
		i--
		dAtA[i] = 0x68
	}
	if m.MyDiscriminator != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.MyDiscriminator))
		i--
		dAtA[i] = 0x60
	}
	if m.DetectMultiplier != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.DetectMultiplier))
		i--
		dAtA[i] = 0x58
	}
	if m.Multipoint {
		i--
		if m.Multipoint {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.Demand {
		i--
		if m.Demand {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.AuthPresent {
		i--
		if m.AuthPresent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.ControlPlaneIndependent {
		i--
		if m.ControlPlaneIndependent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Final {
		i--
		if m.Final {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Poll {
		i--
		if m.Poll {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.State != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x20
	}
	if m.Diagnostic != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Diagnostic))
		i--
		dAtA[i] = 0x18
	}
	if m.Version != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BFDAuthHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BFDAuthHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BFDAuthHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x22
	}
	if m.SequenceNumber != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SequenceNumber))
		i--
		dAtA[i] = 0x18
	}
	if m.KeyID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.KeyID))
		i--
		dAtA[i] = 0x10
	}
	if m.AuthType != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.AuthType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GRE) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GRE) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GRE) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.Routing != nil {
		{
			size, err := m.Routing.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.Ack != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Ack))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Seq != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x78
	}
	if m.Key != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x70
	}
	if m.Offset != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x68
	}
	if m.Checksum != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Checksum))
		i--
		dAtA[i] = 0x60
	}
	if m.Protocol != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Protocol))
		i--
		dAtA[i] = 0x58
	}
	if m.Version != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x50
	}
	if m.Flags != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Flags))
		i--
		dAtA[i] = 0x48
	}
	if m.RecursionControl != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.RecursionControl))
		i--
		dAtA[i] = 0x40
	}
	if m.AckPresent {
		i--
		if m.AckPresent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.StrictSourceRoute {
		i--
		if m.StrictSourceRoute {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.SeqPresent {
		i--
		if m.SeqPresent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.KeyPresent {
		i--
		if m.KeyPresent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.RoutingPresent {
		i--
		if m.RoutingPresent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.ChecksumPresent {
		i--
		if m.ChecksumPresent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GRERouting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GRERouting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GRERouting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Next != nil {
		{
			size, err := m.Next.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.RoutingInformation) > 0 {
		i -= len(m.RoutingInformation)
		copy(dAtA[i:], m.RoutingInformation)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.RoutingInformation)))
		i--
		dAtA[i] = 0x22
	}
	if m.SRELength != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SRELength))
		i--
		dAtA[i] = 0x18
	}
	if m.SREOffset != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SREOffset))
		i--
		dAtA[i] = 0x10
	}
	if m.AddressFamily != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.AddressFamily))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FDDI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FDDI) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FDDI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DstMAC) > 0 {
		i -= len(m.DstMAC)
		copy(dAtA[i:], m.DstMAC)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstMAC)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SrcMAC) > 0 {
		i -= len(m.SrcMAC)
		copy(dAtA[i:], m.SrcMAC)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcMAC)))
		i--
		dAtA[i] = 0x22
	}
	if m.Priority != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x18
	}
	if m.FrameControl != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.FrameControl))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EAP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EAP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EAP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TypeData) > 0 {
		i -= len(m.TypeData)
		copy(dAtA[i:], m.TypeData)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.TypeData)))
		i--
		dAtA[i] = 0x32
	}
	if m.Type != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x28
	}
	if m.Length != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x20
	}
	if m.Id != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x18
	}
	if m.Code != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EAPOL) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EAPOL) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EAPOL) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Length != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x20
	}
	if m.Type != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if m.Version != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EAPOLKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EAPOLKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EAPOLKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EncryptedKeyData) > 0 {
		i -= len(m.EncryptedKeyData)
		copy(dAtA[i:], m.EncryptedKeyData)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.EncryptedKeyData)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.KeyDataLength != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.KeyDataLength))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if len(m.MIC) > 0 {
		i -= len(m.MIC)
		copy(dAtA[i:], m.MIC)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.MIC)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.ID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.RSC != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.RSC))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.IV) > 0 {
		i -= len(m.IV)
		copy(dAtA[i:], m.IV)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.IV)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.ReplayCounter != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.ReplayCounter))
		i--
		dAtA[i] = 0x78
	}
	if m.KeyLength != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.KeyLength))
		i--
		dAtA[i] = 0x70
	}
	if m.SMKMessage {
		i--
		if m.SMKMessage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.HasEncryptedKeyData {
		i--
		if m.HasEncryptedKeyData {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.Request {
		i--
		if m.Request {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.MICError {
		i--
		if m.MICError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.Secure {
		i--
		if m.Secure {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.KeyMIC {
		i--
		if m.KeyMIC {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.KeyACK {
		i--
		if m.KeyACK {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Install {
		i--
		if m.Install {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.KeyIndex != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.KeyIndex))
		i--
		dAtA[i] = 0x28
	}
	if m.KeyType != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.KeyType))
		i--
		dAtA[i] = 0x20
	}
	if m.KeyDescriptorVersion != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.KeyDescriptorVersion))
		i--
		dAtA[i] = 0x18
	}
	if m.KeyDescriptorType != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.KeyDescriptorType))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VRRPv2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VRRPv2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VRRPv2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.IPAddress) > 0 {
		for iNdEx := len(m.IPAddress) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IPAddress[iNdEx])
			copy(dAtA[i:], m.IPAddress[iNdEx])
			i = encodeVarintNetcap(dAtA, i, uint64(len(m.IPAddress[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if m.Checksum != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Checksum))
		i--
		dAtA[i] = 0x48
	}
	if m.AdverInt != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.AdverInt))
		i--
		dAtA[i] = 0x40
	}
	if m.AuthType != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.AuthType))
		i--
		dAtA[i] = 0x38
	}
	if m.CountIPAddr != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.CountIPAddr))
		i--
		dAtA[i] = 0x30
	}
	if m.Priority != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x28
	}
	if m.VirtualRtrID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.VirtualRtrID))
		i--
		dAtA[i] = 0x20
	}
	if m.Type != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if m.Version != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CiscoDiscovery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CiscoDiscovery) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CiscoDiscovery) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Checksum != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Checksum))
		i--
		dAtA[i] = 0x20
	}
	if m.TTL != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.TTL))
		i--
		dAtA[i] = 0x18
	}
	if m.Version != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CiscoDiscoveryValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CiscoDiscoveryValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CiscoDiscoveryValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Length != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CDPVLANDialogue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDPVLANDialogue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDPVLANDialogue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VLAN != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.VLAN))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CDPLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDPLocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDPLocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Location) > 0 {
		i -= len(m.Location)
		copy(dAtA[i:], m.Location)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Location)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CDPPowerDialogue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDPPowerDialogue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDPPowerDialogue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		dAtA59 := make([]byte, len(m.Values)*10)
		var j58 int
		for _, num := range m.Values {
			for num >= 1<<7 {
				dAtA59[j58] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j58++
			}
			dAtA59[j58] = uint8(num)
			j58++
		}
		i -= j58
		copy(dAtA[i:], dAtA59[:j58])
		i = encodeVarintNetcap(dAtA, i, uint64(j58))
		i--
		dAtA[i] = 0x1a
	}
	if m.MgmtID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.MgmtID))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CDPSparePairPoE) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDPSparePairPoE) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDPSparePairPoE) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PSEOn {
		i--
		if m.PSEOn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.PDRequestOn {
		i--
		if m.PDRequestOn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.PDArchShared {
		i--
		if m.PDArchShared {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.PSEFourWire {
		i--
		if m.PSEFourWire {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CiscoDiscoveryInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CiscoDiscoveryInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CiscoDiscoveryInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Unknown) > 0 {
		for iNdEx := len(m.Unknown) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Unknown[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xda
		}
	}
	if m.EnergyWise != nil {
		{
			size, err := m.EnergyWise.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.SparePairPoe != nil {
		{
			size, err := m.SparePairPoe.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.PowerAvailable != nil {
		{
			size, err := m.PowerAvailable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.PowerRequest != nil {
		{
			size, err := m.PowerRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.MgmtAddresses) > 0 {
		for iNdEx := len(m.MgmtAddresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.MgmtAddresses[iNdEx])
			copy(dAtA[i:], m.MgmtAddresses[iNdEx])
			i = encodeVarintNetcap(dAtA, i, uint64(len(m.MgmtAddresses[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.SysOID) > 0 {
		i -= len(m.SysOID)
		copy(dAtA[i:], m.SysOID)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SysOID)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.SysName) > 0 {
		i -= len(m.SysName)
		copy(dAtA[i:], m.SysName)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SysName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.UntrustedCOS != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.UntrustedCOS))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.ExtendedTrust != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.ExtendedTrust))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.MTU != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.MTU))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.PowerConsumption != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.PowerConsumption))
		i--
		dAtA[i] = 0x78
	}
	if m.VLANQuery != nil {
		{
			size, err := m.VLANQuery.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.VLANReply != nil {
		{
			size, err := m.VLANReply.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.FullDuplex {
		i--
		if m.FullDuplex {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.NativeVLAN != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.NativeVLAN))
		i--
		dAtA[i] = 0x58
	}
	if len(m.VTPDomain) > 0 {
		i -= len(m.VTPDomain)
		copy(dAtA[i:], m.VTPDomain)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.VTPDomain)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.IPPrefixes) > 0 {
		for iNdEx := len(m.IPPrefixes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IPPrefixes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Platform) > 0 {
		i -= len(m.Platform)
		copy(dAtA[i:], m.Platform)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Platform)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Capabilities != nil {
		{
			size, err := m.Capabilities.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.PortID) > 0 {
		i -= len(m.PortID)
		copy(dAtA[i:], m.PortID)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.PortID)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Addresses) > 0 {
		for iNdEx := len(m.Addresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Addresses[iNdEx])
			copy(dAtA[i:], m.Addresses[iNdEx])
			i = encodeVarintNetcap(dAtA, i, uint64(len(m.Addresses[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.DeviceID) > 0 {
		i -= len(m.DeviceID)
		copy(dAtA[i:], m.DeviceID)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DeviceID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.CDPHello != nil {
		{
			size, err := m.CDPHello.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CDPHello) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDPHello) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDPHello) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ManagementVLAN != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.ManagementVLAN))
		i--
		dAtA[i] = 0x60
	}
	if m.Unknown3 != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Unknown3))
		i--
		dAtA[i] = 0x58
	}
	if len(m.SwitchMAC) > 0 {
		i -= len(m.SwitchMAC)
		copy(dAtA[i:], m.SwitchMAC)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SwitchMAC)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.ClusterCommander) > 0 {
		i -= len(m.ClusterCommander)
		copy(dAtA[i:], m.ClusterCommander)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ClusterCommander)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Unknown2 != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Unknown2))
		i--
		dAtA[i] = 0x40
	}
	if m.Status != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x38
	}
	if m.SubVersion != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SubVersion))
		i--
		dAtA[i] = 0x30
	}
	if m.Version != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Unknown1) > 0 {
		i -= len(m.Unknown1)
		copy(dAtA[i:], m.Unknown1)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Unknown1)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ClusterMaster) > 0 {
		i -= len(m.ClusterMaster)
		copy(dAtA[i:], m.ClusterMaster)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ClusterMaster)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ProtocolID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.ProtocolID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.OUI) > 0 {
		i -= len(m.OUI)
		copy(dAtA[i:], m.OUI)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.OUI)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CDPEnergyWise) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDPEnergyWise) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDPEnergyWise) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ReplyUnknown3) > 0 {
		i -= len(m.ReplyUnknown3)
		copy(dAtA[i:], m.ReplyUnknown3)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ReplyUnknown3)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.ReplyUnknown2) > 0 {
		i -= len(m.ReplyUnknown2)
		copy(dAtA[i:], m.ReplyUnknown2)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ReplyUnknown2)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.ReplyAddress) > 0 {
		i -= len(m.ReplyAddress)
		copy(dAtA[i:], m.ReplyAddress)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ReplyAddress)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.ReplyPort) > 0 {
		i -= len(m.ReplyPort)
		copy(dAtA[i:], m.ReplyPort)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ReplyPort)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.ReplyUnknown1) > 0 {
		i -= len(m.ReplyUnknown1)
		copy(dAtA[i:], m.ReplyUnknown1)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ReplyUnknown1)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Domain) > 0 {
		i -= len(m.Domain)
		copy(dAtA[i:], m.Domain)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Domain)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Unknown3) > 0 {
		i -= len(m.Unknown3)
		copy(dAtA[i:], m.Unknown3)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Unknown3)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SerialNum) > 0 {
		i -= len(m.SerialNum)
		copy(dAtA[i:], m.SerialNum)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SerialNum)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.HardwareID) > 0 {
		i -= len(m.HardwareID)
		copy(dAtA[i:], m.HardwareID)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.HardwareID)))
		i--
		dAtA[i] = 0x32
	}
	if m.Unknown2 != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Unknown2))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ModelNumber) > 0 {
		i -= len(m.ModelNumber)
		copy(dAtA[i:], m.ModelNumber)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ModelNumber)))
		i--
		dAtA[i] = 0x22
	}
	if m.SequenceNumber != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SequenceNumber))
		i--
		dAtA[i] = 0x18
	}
	if m.Unknown1 != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Unknown1))
		i--
		dAtA[i] = 0x10
	}
	if len(m.EncryptedData) > 0 {
		i -= len(m.EncryptedData)
		copy(dAtA[i:], m.EncryptedData)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.EncryptedData)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CDPCapabilities) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDPCapabilities) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDPCapabilities) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RemotelyManaged {
		i--
		if m.RemotelyManaged {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.IsPhone {
		i--
		if m.IsPhone {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.L1Repeater {
		i--
		if m.L1Repeater {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.IGMPFilter {
		i--
		if m.IGMPFilter {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.IsHost {
		i--
		if m.IsHost {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.L2Switch {
		i--
		if m.L2Switch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.SPBridge {
		i--
		if m.SPBridge {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.TBBridge {
		i--
		if m.TBBridge {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.L3Router {
		i--
		if m.L3Router {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IPNet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPNet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPNet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IPMask) > 0 {
		i -= len(m.IPMask)
		copy(dAtA[i:], m.IPMask)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.IPMask)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.IP) > 0 {
		i -= len(m.IP)
		copy(dAtA[i:], m.IP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.IP)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NortelDiscovery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NortelDiscovery) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NortelDiscovery) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DstMac) > 0 {
		i -= len(m.DstMac)
		copy(dAtA[i:], m.DstMac)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstMac)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.SrcMac) > 0 {
		i -= len(m.SrcMac)
		copy(dAtA[i:], m.SrcMac)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcMac)))
		i--
		dAtA[i] = 0x42
	}
	if m.NumLinks != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.NumLinks))
		i--
		dAtA[i] = 0x38
	}
	if m.State != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x30
	}
	if m.Backplane != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Backplane))
		i--
		dAtA[i] = 0x28
	}
	if m.Chassis != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Chassis))
		i--
		dAtA[i] = 0x20
	}
	if len(m.SegmentID) > 0 {
		i -= len(m.SegmentID)
		copy(dAtA[i:], m.SegmentID)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SegmentID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.IPAddress) > 0 {
		i -= len(m.IPAddress)
		copy(dAtA[i:], m.IPAddress)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.IPAddress)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CIP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CIP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CIP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DstPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.DstPort))
		i--
		dAtA[i] = 0x60
	}
	if m.SrcPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SrcPort))
		i--
		dAtA[i] = 0x58
	}
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.AdditionalStatus) > 0 {
		dAtA70 := make([]byte, len(m.AdditionalStatus)*10)
		var j69 int
		for _, num := range m.AdditionalStatus {
			for num >= 1<<7 {
				dAtA70[j69] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j69++
			}
			dAtA70[j69] = uint8(num)
			j69++
		}
		i -= j69
		copy(dAtA[i:], dAtA70[:j69])
		i = encodeVarintNetcap(dAtA, i, uint64(j69))
		i--
		dAtA[i] = 0x3a
	}
	if m.Status != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x30
	}
	if m.InstanceID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.InstanceID))
		i--
		dAtA[i] = 0x28
	}
	if m.ClassID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.ClassID))
		i--
		dAtA[i] = 0x20
	}
	if m.ServiceID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.ServiceID))
		i--
		dAtA[i] = 0x18
	}
	if m.Response {
		i--
		if m.Response {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ENIP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ENIP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ENIP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DstPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.DstPort))
		i--
		dAtA[i] = 0x60
	}
	if m.SrcPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SrcPort))
		i--
		dAtA[i] = 0x58
	}
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x4a
	}
	if m.CommandSpecific != nil {
		{
			size, err := m.CommandSpecific.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Options != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Options))
		i--
		dAtA[i] = 0x38
	}
	if len(m.SenderContext) > 0 {
		i -= len(m.SenderContext)
		copy(dAtA[i:], m.SenderContext)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SenderContext)))
		i--
		dAtA[i] = 0x32
	}
	if m.Status != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x28
	}
	if m.SessionHandle != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SessionHandle))
		i--
		dAtA[i] = 0x20
	}
	if m.Length != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x18
	}
	if m.Command != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Command))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ENIPCommandSpecificData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ENIPCommandSpecificData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ENIPCommandSpecificData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if m.Cmd != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Cmd))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeviceProfile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceProfile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceProfile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Bytes != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Bytes))
		i--
		dAtA[i] = 0x38
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x30
	}
	if m.NumPackets != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.NumPackets))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Contacts) > 0 {
		for iNdEx := len(m.Contacts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Contacts[iNdEx])
			copy(dAtA[i:], m.Contacts[iNdEx])
			i = encodeVarintNetcap(dAtA, i, uint64(len(m.Contacts[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.DeviceIPs) > 0 {
		for iNdEx := len(m.DeviceIPs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DeviceIPs[iNdEx])
			copy(dAtA[i:], m.DeviceIPs[iNdEx])
			i = encodeVarintNetcap(dAtA, i, uint64(len(m.DeviceIPs[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.DeviceManufacturer) > 0 {
		i -= len(m.DeviceManufacturer)
		copy(dAtA[i:], m.DeviceManufacturer)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DeviceManufacturer)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MacAddr) > 0 {
		i -= len(m.MacAddr)
		copy(dAtA[i:], m.MacAddr)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.MacAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Port) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Port) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Port) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0x12
	}
	if m.PortNumber != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.PortNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PortStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Bytes != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Bytes))
		i--
		dAtA[i] = 0x10
	}
	if m.Packets != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Packets))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IPProfile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPProfile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPProfile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ContactedPorts) > 0 {
		for iNdEx := len(m.ContactedPorts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ContactedPorts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.DstPorts) > 0 {
		for iNdEx := len(m.DstPorts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DstPorts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.SrcPorts) > 0 {
		for iNdEx := len(m.SrcPorts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SrcPorts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.SNIs) > 0 {
		for k := range m.SNIs {
			v := m.SNIs[k]
			baseI := i
			i = encodeVarintNetcap(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintNetcap(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintNetcap(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.Bytes != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Bytes))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Protocols) > 0 {
		for k := range m.Protocols {
			v := m.Protocols[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintNetcap(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintNetcap(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintNetcap(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Ja3Hashes) > 0 {
		for k := range m.Ja3Hashes {
			v := m.Ja3Hashes[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintNetcap(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintNetcap(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintNetcap(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Applications) > 0 {
		for iNdEx := len(m.Applications) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Applications[iNdEx])
			copy(dAtA[i:], m.Applications[iNdEx])
			i = encodeVarintNetcap(dAtA, i, uint64(len(m.Applications[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.TimestampLast != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.TimestampLast))
		i--
		dAtA[i] = 0x30
	}
	if m.TimestampFirst != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.TimestampFirst))
		i--
		dAtA[i] = 0x28
	}
	if len(m.DNSNames) > 0 {
		for iNdEx := len(m.DNSNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DNSNames[iNdEx])
			copy(dAtA[i:], m.DNSNames[iNdEx])
			i = encodeVarintNetcap(dAtA, i, uint64(len(m.DNSNames[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Geolocation) > 0 {
		i -= len(m.Geolocation)
		copy(dAtA[i:], m.Geolocation)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Geolocation)))
		i--
		dAtA[i] = 0x1a
	}
	if m.NumPackets != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.NumPackets))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Protocol) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Protocol) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Protocol) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Category) > 0 {
		i -= len(m.Category)
		copy(dAtA[i:], m.Category)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Category)))
		i--
		dAtA[i] = 0x12
	}
	if m.Packets != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Packets))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *File) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *File) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *File) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DstPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.DstPort))
		i--
		dAtA[i] = 0x70
	}
	if m.SrcPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SrcPort))
		i--
		dAtA[i] = 0x68
	}
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.ContentTypeDetected) > 0 {
		i -= len(m.ContentTypeDetected)
		copy(dAtA[i:], m.ContentTypeDetected)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ContentTypeDetected)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Host) > 0 {
		i -= len(m.Host)
		copy(dAtA[i:], m.Host)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Host)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ContentType) > 0 {
		i -= len(m.ContentType)
		copy(dAtA[i:], m.ContentType)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ContentType)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Ident) > 0 {
		i -= len(m.Ident)
		copy(dAtA[i:], m.Ident)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Ident)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Location) > 0 {
		i -= len(m.Location)
		copy(dAtA[i:], m.Location)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Location)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x22
	}
	if m.Length != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SMTPResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SMTPResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SMTPResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Parameter) > 0 {
		i -= len(m.Parameter)
		copy(dAtA[i:], m.Parameter)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Parameter)))
		i--
		dAtA[i] = 0x12
	}
	if m.ResponseCode != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.ResponseCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SMTPRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SMTPRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SMTPRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Argument) > 0 {
		i -= len(m.Argument)
		copy(dAtA[i:], m.Argument)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Argument)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Command) > 0 {
		i -= len(m.Command)
		copy(dAtA[i:], m.Command)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Command)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SMTPCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SMTPCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SMTPCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Parameter) > 0 {
		i -= len(m.Parameter)
		copy(dAtA[i:], m.Parameter)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Parameter)))
		i--
		dAtA[i] = 0x12
	}
	if m.Command != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Command))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SMTP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SMTP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SMTP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Commands) > 0 {
		for iNdEx := len(m.Commands) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Commands[iNdEx])
			copy(dAtA[i:], m.Commands[iNdEx])
			i = encodeVarintNetcap(dAtA, i, uint64(len(m.Commands[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.MailIDs) > 0 {
		for iNdEx := len(m.MailIDs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.MailIDs[iNdEx])
			copy(dAtA[i:], m.MailIDs[iNdEx])
			i = encodeVarintNetcap(dAtA, i, uint64(len(m.MailIDs[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if m.DstPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.DstPort))
		i--
		dAtA[i] = 0x48
	}
	if m.SrcPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SrcPort))
		i--
		dAtA[i] = 0x40
	}
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x32
	}
	if m.IsResponse {
		i--
		if m.IsResponse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.IsEncrypted {
		i--
		if m.IsEncrypted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Diameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Diameter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Diameter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DstPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.DstPort))
		i--
		dAtA[i] = 0x68
	}
	if m.SrcPort != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.SrcPort))
		i--
		dAtA[i] = 0x60
	}
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.AVPs) > 0 {
		for iNdEx := len(m.AVPs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AVPs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.EndToEndID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.EndToEndID))
		i--
		dAtA[i] = 0x40
	}
	if m.HopByHopID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.HopByHopID))
		i--
		dAtA[i] = 0x38
	}
	if m.ApplicationID != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.ApplicationID))
		i--
		dAtA[i] = 0x30
	}
	if m.CommandCode != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.CommandCode))
		i--
		dAtA[i] = 0x28
	}
	if m.MessageLen != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.MessageLen))
		i--
		dAtA[i] = 0x20
	}
	if m.Flags != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Flags))
		i--
		dAtA[i] = 0x18
	}
	if m.Version != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AVP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AVP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AVP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ValueLen != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.ValueLen))
		i--
		dAtA[i] = 0x68
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x62
	}
	if m.Padding != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Padding))
		i--
		dAtA[i] = 0x58
	}
	if len(m.DecodedValue) > 0 {
		i -= len(m.DecodedValue)
		copy(dAtA[i:], m.DecodedValue)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DecodedValue)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.VendorID) > 0 {
		i -= len(m.VendorID)
		copy(dAtA[i:], m.VendorID)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.VendorID)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.VendorName) > 0 {
		i -= len(m.VendorName)
		copy(dAtA[i:], m.VendorName)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.VendorName)))
		i--
		dAtA[i] = 0x42
	}
	if m.VendorCode != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.VendorCode))
		i--
		dAtA[i] = 0x38
	}
	if m.Len != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Len))
		i--
		dAtA[i] = 0x30
	}
	if m.HeaderLen != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.HeaderLen))
		i--
		dAtA[i] = 0x28
	}
	if m.Flags != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Flags))
		i--
		dAtA[i] = 0x20
	}
	if len(m.AttributeFormat) > 0 {
		i -= len(m.AttributeFormat)
		copy(dAtA[i:], m.AttributeFormat)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.AttributeFormat)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AttributeName) > 0 {
		i -= len(m.AttributeName)
		copy(dAtA[i:], m.AttributeName)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.AttributeName)))
		i--
		dAtA[i] = 0x12
	}
	if m.AttributeCode != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.AttributeCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *POP3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *POP3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *POP3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Commands) > 0 {
		for iNdEx := len(m.Commands) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Commands[iNdEx])
			copy(dAtA[i:], m.Commands[iNdEx])
			i = encodeVarintNetcap(dAtA, i, uint64(len(m.Commands[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.MailIDs) > 0 {
		for iNdEx := len(m.MailIDs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.MailIDs[iNdEx])
			copy(dAtA[i:], m.MailIDs[iNdEx])
			i = encodeVarintNetcap(dAtA, i, uint64(len(m.MailIDs[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Pass) > 0 {
		i -= len(m.Pass)
		copy(dAtA[i:], m.Pass)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Pass)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AuthToken) > 0 {
		i -= len(m.AuthToken)
		copy(dAtA[i:], m.AuthToken)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.AuthToken)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ServerIP) > 0 {
		i -= len(m.ServerIP)
		copy(dAtA[i:], m.ServerIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ServerIP)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClientIP) > 0 {
		i -= len(m.ClientIP)
		copy(dAtA[i:], m.ClientIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ClientIP)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Mail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Mail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Mail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Origin) > 0 {
		i -= len(m.Origin)
		copy(dAtA[i:], m.Origin)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Origin)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.DeliveryDate) > 0 {
		i -= len(m.DeliveryDate)
		copy(dAtA[i:], m.DeliveryDate)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DeliveryDate)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.ServerIP) > 0 {
		i -= len(m.ServerIP)
		copy(dAtA[i:], m.ServerIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ServerIP)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.ClientIP) > 0 {
		i -= len(m.ClientIP)
		copy(dAtA[i:], m.ClientIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ClientIP)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.Body) > 0 {
		for iNdEx := len(m.Body) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Body[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetcap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.EnvelopeTo) > 0 {
		i -= len(m.EnvelopeTo)
		copy(dAtA[i:], m.EnvelopeTo)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.EnvelopeTo)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.ContentType) > 0 {
		i -= len(m.ContentType)
		copy(dAtA[i:], m.ContentType)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ContentType)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.XOriginatingIP) > 0 {
		i -= len(m.XOriginatingIP)
		copy(dAtA[i:], m.XOriginatingIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.XOriginatingIP)))
		i--
		dAtA[i] = 0x6a
	}
	if m.HasAttachments {
		i--
		if m.HasAttachments {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if len(m.ContentLanguage) > 0 {
		i -= len(m.ContentLanguage)
		copy(dAtA[i:], m.ContentLanguage)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ContentLanguage)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.InReplyTo) > 0 {
		i -= len(m.InReplyTo)
		copy(dAtA[i:], m.InReplyTo)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.InReplyTo)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.References) > 0 {
		i -= len(m.References)
		copy(dAtA[i:], m.References)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.References)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.MessageID) > 0 {
		i -= len(m.MessageID)
		copy(dAtA[i:], m.MessageID)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.MessageID)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Date) > 0 {
		i -= len(m.Date)
		copy(dAtA[i:], m.Date)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Date)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Subject) > 0 {
		i -= len(m.Subject)
		copy(dAtA[i:], m.Subject)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Subject)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.CC) > 0 {
		i -= len(m.CC)
		copy(dAtA[i:], m.CC)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.CC)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ReturnPath) > 0 {
		i -= len(m.ReturnPath)
		copy(dAtA[i:], m.ReturnPath)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ReturnPath)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MailPart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailPart) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MailPart) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Filename) > 0 {
		i -= len(m.Filename)
		copy(dAtA[i:], m.Filename)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Filename)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Header) > 0 {
		for k := range m.Header {
			v := m.Header[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintNetcap(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintNetcap(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintNetcap(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *POP3Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *POP3Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *POP3Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Argument) > 0 {
		i -= len(m.Argument)
		copy(dAtA[i:], m.Argument)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Argument)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Command) > 0 {
		i -= len(m.Command)
		copy(dAtA[i:], m.Command)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Command)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *POP3Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *POP3Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *POP3Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Command) > 0 {
		i -= len(m.Command)
		copy(dAtA[i:], m.Command)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Command)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Software) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Software) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Software) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OS) > 0 {
		i -= len(m.OS)
		copy(dAtA[i:], m.OS)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.OS)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Website) > 0 {
		i -= len(m.Website)
		copy(dAtA[i:], m.Website)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Website)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Notes) > 0 {
		i -= len(m.Notes)
		copy(dAtA[i:], m.Notes)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Notes)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.SourceData) > 0 {
		i -= len(m.SourceData)
		copy(dAtA[i:], m.SourceData)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SourceData)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Flows) > 0 {
		for iNdEx := len(m.Flows) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Flows[iNdEx])
			copy(dAtA[i:], m.Flows[iNdEx])
			i = encodeVarintNetcap(dAtA, i, uint64(len(m.Flows[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Service) > 0 {
		i -= len(m.Service)
		copy(dAtA[i:], m.Service)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Service)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.DPIResults) > 0 {
		for iNdEx := len(m.DPIResults) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DPIResults[iNdEx])
			copy(dAtA[i:], m.DPIResults[iNdEx])
			i = encodeVarintNetcap(dAtA, i, uint64(len(m.DPIResults[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.SourceName) > 0 {
		i -= len(m.SourceName)
		copy(dAtA[i:], m.SourceName)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SourceName)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.DeviceProfiles) > 0 {
		for iNdEx := len(m.DeviceProfiles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DeviceProfiles[iNdEx])
			copy(dAtA[i:], m.DeviceProfiles[iNdEx])
			i = encodeVarintNetcap(dAtA, i, uint64(len(m.DeviceProfiles[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Vendor) > 0 {
		i -= len(m.Vendor)
		copy(dAtA[i:], m.Vendor)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Vendor)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Product) > 0 {
		i -= len(m.Product)
		copy(dAtA[i:], m.Product)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Product)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Service) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Service) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Service) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OS) > 0 {
		i -= len(m.OS)
		copy(dAtA[i:], m.OS)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.OS)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x72
	}
	if m.BytesClient != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.BytesClient))
		i--
		dAtA[i] = 0x68
	}
	if m.BytesServer != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.BytesServer))
		i--
		dAtA[i] = 0x60
	}
	if len(m.Notes) > 0 {
		i -= len(m.Notes)
		copy(dAtA[i:], m.Notes)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Notes)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Vendor) > 0 {
		i -= len(m.Vendor)
		copy(dAtA[i:], m.Vendor)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Vendor)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Product) > 0 {
		i -= len(m.Product)
		copy(dAtA[i:], m.Product)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Product)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Flows) > 0 {
		for iNdEx := len(m.Flows) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Flows[iNdEx])
			copy(dAtA[i:], m.Flows[iNdEx])
			i = encodeVarintNetcap(dAtA, i, uint64(len(m.Flows[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Banner) > 0 {
		i -= len(m.Banner)
		copy(dAtA[i:], m.Banner)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Banner)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if m.Port != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x18
	}
	if len(m.IP) > 0 {
		i -= len(m.IP)
		copy(dAtA[i:], m.IP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.IP)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Credentials) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Credentials) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Credentials) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Notes) > 0 {
		i -= len(m.Notes)
		copy(dAtA[i:], m.Notes)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Notes)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Flow) > 0 {
		i -= len(m.Flow)
		copy(dAtA[i:], m.Flow)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Flow)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Service) > 0 {
		i -= len(m.Service)
		copy(dAtA[i:], m.Service)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Service)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SSH) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SSH) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SSH) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsClient {
		i--
		if m.IsClient {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.Algorithms) > 0 {
		i -= len(m.Algorithms)
		copy(dAtA[i:], m.Algorithms)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Algorithms)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Ident) > 0 {
		i -= len(m.Ident)
		copy(dAtA[i:], m.Ident)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Ident)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Notes) > 0 {
		i -= len(m.Notes)
		copy(dAtA[i:], m.Notes)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Notes)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Flow) > 0 {
		i -= len(m.Flow)
		copy(dAtA[i:], m.Flow)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Flow)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.HASSH) > 0 {
		i -= len(m.HASSH)
		copy(dAtA[i:], m.HASSH)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.HASSH)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Vulnerability) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vulnerability) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vulnerability) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Software != nil {
		{
			size, err := m.Software.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Notes) > 0 {
		i -= len(m.Notes)
		copy(dAtA[i:], m.Notes)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Notes)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Versions) > 0 {
		for iNdEx := len(m.Versions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Versions[iNdEx])
			copy(dAtA[i:], m.Versions[iNdEx])
			i = encodeVarintNetcap(dAtA, i, uint64(len(m.Versions[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.AccessVector) > 0 {
		i -= len(m.AccessVector)
		copy(dAtA[i:], m.AccessVector)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.AccessVector)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.V2Score) > 0 {
		i -= len(m.V2Score)
		copy(dAtA[i:], m.V2Score)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.V2Score)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Severity) > 0 {
		i -= len(m.Severity)
		copy(dAtA[i:], m.Severity)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Severity)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Exploit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Exploit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Exploit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Software != nil {
		{
			size, err := m.Software.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetcap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Port) > 0 {
		i -= len(m.Port)
		copy(dAtA[i:], m.Port)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Port)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Platform) > 0 {
		i -= len(m.Platform)
		copy(dAtA[i:], m.Platform)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Platform)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Typ) > 0 {
		i -= len(m.Typ)
		copy(dAtA[i:], m.Typ)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Typ)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Author) > 0 {
		i -= len(m.Author)
		copy(dAtA[i:], m.Author)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Author)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Date) > 0 {
		i -= len(m.Date)
		copy(dAtA[i:], m.Date)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Date)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Notes) > 0 {
		i -= len(m.Notes)
		copy(dAtA[i:], m.Notes)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Notes)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.File) > 0 {
		i -= len(m.File)
		copy(dAtA[i:], m.File)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.File)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Alert) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Alert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Alert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Notes) > 0 {
		i -= len(m.Notes)
		copy(dAtA[i:], m.Notes)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Notes)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Domain) > 0 {
		i -= len(m.Domain)
		copy(dAtA[i:], m.Domain)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Domain)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.IPReputation) > 0 {
		i -= len(m.IPReputation)
		copy(dAtA[i:], m.IPReputation)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.IPReputation)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.MITRE) > 0 {
		i -= len(m.MITRE)
		copy(dAtA[i:], m.MITRE)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.MITRE)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.DstPort) > 0 {
		i -= len(m.DstPort)
		copy(dAtA[i:], m.DstPort)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstPort)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.DstIP) > 0 {
		i -= len(m.DstIP)
		copy(dAtA[i:], m.DstIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.DstIP)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SrcPort) > 0 {
		i -= len(m.SrcPort)
		copy(dAtA[i:], m.SrcPort)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcPort)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SrcIP) > 0 {
		i -= len(m.SrcIP)
		copy(dAtA[i:], m.SrcIP)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.SrcIP)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNetcap(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintNetcap(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintNetcap(dAtA []byte, offset int, v uint64) int {
	offset -= sovNetcap(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Created != 0 {
		n += 1 + sovNetcap(uint64(m.Created))
	}
	l = len(m.InputSource)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.ContainsPayloads {
		n += 2
	}
	return n
}

func (m *Batch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.MessageType != 0 {
		n += 1 + sovNetcap(uint64(m.MessageType))
	}
	if m.TotalSize != 0 {
		n += 1 + sovNetcap(uint64(m.TotalSize))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.ContainsPayloads {
		n += 2
	}
	return n
}

func (m *PacketContext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.SrcPort != 0 {
		n += 1 + sovNetcap(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 1 + sovNetcap(uint64(m.DstPort))
	}
	return n
}

func (m *Connection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TimestampFirst != 0 {
		n += 1 + sovNetcap(uint64(m.TimestampFirst))
	}
	l = len(m.LinkProto)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.NetworkProto)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.TransportProto)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.ApplicationProto)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SrcMAC)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstMAC)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SrcPort)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstPort)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.TotalSize != 0 {
		n += 1 + sovNetcap(uint64(m.TotalSize))
	}
	if m.AppPayloadSize != 0 {
		n += 1 + sovNetcap(uint64(m.AppPayloadSize))
	}
	if m.NumPackets != 0 {
		n += 1 + sovNetcap(uint64(m.NumPackets))
	}
	l = len(m.UID)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.TimestampLast != 0 {
		n += 2 + sovNetcap(uint64(m.TimestampLast))
	}
	if m.Duration != 0 {
		n += 2 + sovNetcap(uint64(m.Duration))
	}
	if m.BytesServerToClient != 0 {
		n += 2 + sovNetcap(uint64(m.BytesServerToClient))
	}
	if m.BytesClientToServer != 0 {
		n += 2 + sovNetcap(uint64(m.BytesClientToServer))
	}
	if m.NumFINFlags != 0 {
		n += 2 + sovNetcap(uint64(m.NumFINFlags))
	}
	if m.NumRSTFlags != 0 {
		n += 2 + sovNetcap(uint64(m.NumRSTFlags))
	}
	if m.NumACKFlags != 0 {
		n += 2 + sovNetcap(uint64(m.NumACKFlags))
	}
	if m.NumSYNFlags != 0 {
		n += 2 + sovNetcap(uint64(m.NumSYNFlags))
	}
	if m.NumURGFlags != 0 {
		n += 2 + sovNetcap(uint64(m.NumURGFlags))
	}
	if m.NumECEFlags != 0 {
		n += 2 + sovNetcap(uint64(m.NumECEFlags))
	}
	if m.NumPSHFlags != 0 {
		n += 2 + sovNetcap(uint64(m.NumPSHFlags))
	}
	if m.NumCWRFlags != 0 {
		n += 2 + sovNetcap(uint64(m.NumCWRFlags))
	}
	if m.NumNSFlags != 0 {
		n += 2 + sovNetcap(uint64(m.NumNSFlags))
	}
	if m.MeanWindowSize != 0 {
		n += 2 + sovNetcap(uint64(m.MeanWindowSize))
	}
	return n
}

func (m *Ethernet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	l = len(m.SrcMAC)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstMAC)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.EthernetType != 0 {
		n += 1 + sovNetcap(uint64(m.EthernetType))
	}
	if m.PayloadEntropy != 0 {
		n += 9
	}
	if m.PayloadSize != 0 {
		n += 1 + sovNetcap(uint64(m.PayloadSize))
	}
	return n
}

func (m *ARP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.AddrType != 0 {
		n += 1 + sovNetcap(uint64(m.AddrType))
	}
	if m.Protocol != 0 {
		n += 1 + sovNetcap(uint64(m.Protocol))
	}
	if m.HwAddressSize != 0 {
		n += 1 + sovNetcap(uint64(m.HwAddressSize))
	}
	if m.ProtocolAddressSize != 0 {
		n += 1 + sovNetcap(uint64(m.ProtocolAddressSize))
	}
	if m.Operation != 0 {
		n += 1 + sovNetcap(uint64(m.Operation))
	}
	l = len(m.SrcHwAddress)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SrcProtocolAddress)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstHwAddress)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstProtocolAddress)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *Dot1Q) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.Priority != 0 {
		n += 1 + sovNetcap(uint64(m.Priority))
	}
	if m.DropEligible {
		n += 2
	}
	if m.VLANIdentifier != 0 {
		n += 1 + sovNetcap(uint64(m.VLANIdentifier))
	}
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	return n
}

func (m *Dot11) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	if m.Proto != 0 {
		n += 1 + sovNetcap(uint64(m.Proto))
	}
	if m.Flags != 0 {
		n += 1 + sovNetcap(uint64(m.Flags))
	}
	if m.DurationID != 0 {
		n += 1 + sovNetcap(uint64(m.DurationID))
	}
	l = len(m.Address1)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Address2)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Address3)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Address4)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.SequenceNumber != 0 {
		n += 1 + sovNetcap(uint64(m.SequenceNumber))
	}
	if m.FragmentNumber != 0 {
		n += 1 + sovNetcap(uint64(m.FragmentNumber))
	}
	if m.Checksum != 0 {
		n += 1 + sovNetcap(uint64(m.Checksum))
	}
	if m.QOS != nil {
		l = m.QOS.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.HTControl != nil {
		l = m.HTControl.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *Dot11QOS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TID != 0 {
		n += 1 + sovNetcap(uint64(m.TID))
	}
	if m.EOSP {
		n += 2
	}
	if m.AckPolicy != 0 {
		n += 1 + sovNetcap(uint64(m.AckPolicy))
	}
	if m.TXOP != 0 {
		n += 1 + sovNetcap(uint64(m.TXOP))
	}
	return n
}

func (m *Dot11HTControl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ACConstraint {
		n += 2
	}
	if m.RDGMorePPDU {
		n += 2
	}
	if m.VHT != nil {
		l = m.VHT.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.HT != nil {
		l = m.HT.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *Dot11HTControlVHT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MRQ {
		n += 2
	}
	if m.UnsolicitedMFB {
		n += 2
	}
	if m.MSI != 0 {
		n += 1 + sovNetcap(uint64(m.MSI))
	}
	if m.MFB != nil {
		l = m.MFB.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.CompressedMSI != 0 {
		n += 1 + sovNetcap(uint64(m.CompressedMSI))
	}
	if m.STBCIndication {
		n += 2
	}
	if m.MFSI != 0 {
		n += 1 + sovNetcap(uint64(m.MFSI))
	}
	if m.GID != 0 {
		n += 1 + sovNetcap(uint64(m.GID))
	}
	if m.CodingType != 0 {
		n += 1 + sovNetcap(uint64(m.CodingType))
	}
	if m.FbTXBeamformed {
		n += 2
	}
	return n
}

func (m *Dot11HTControlHT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LinkAdapationControl != nil {
		l = m.LinkAdapationControl.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.CalibrationPosition != 0 {
		n += 1 + sovNetcap(uint64(m.CalibrationPosition))
	}
	if m.CalibrationSequence != 0 {
		n += 1 + sovNetcap(uint64(m.CalibrationSequence))
	}
	if m.CSISteering != 0 {
		n += 1 + sovNetcap(uint64(m.CSISteering))
	}
	if m.NDPAnnouncement {
		n += 2
	}
	if m.DEI {
		n += 2
	}
	return n
}

func (m *Dot11HTControlMFB) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NumSTS != 0 {
		n += 1 + sovNetcap(uint64(m.NumSTS))
	}
	if m.VHTMCS != 0 {
		n += 1 + sovNetcap(uint64(m.VHTMCS))
	}
	if m.BW != 0 {
		n += 1 + sovNetcap(uint64(m.BW))
	}
	if m.SNR != 0 {
		n += 1 + sovNetcap(uint64(m.SNR))
	}
	return n
}

func (m *Dot11LinkAdapationControl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TRQ {
		n += 2
	}
	if m.MRQ {
		n += 2
	}
	if m.MSI != 0 {
		n += 1 + sovNetcap(uint64(m.MSI))
	}
	if m.MFSI != 0 {
		n += 1 + sovNetcap(uint64(m.MFSI))
	}
	if m.ASEL != nil {
		l = m.ASEL.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.MFB != 0 {
		n += 1 + sovNetcap(uint64(m.MFB))
	}
	return n
}

func (m *Dot11ASEL) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Command != 0 {
		n += 1 + sovNetcap(uint64(m.Command))
	}
	if m.Data != 0 {
		n += 1 + sovNetcap(uint64(m.Data))
	}
	return n
}

func (m *LinkLayerDiscovery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.ChassisID != nil {
		l = m.ChassisID.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.PortID != nil {
		l = m.PortID.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.TTL != 0 {
		n += 1 + sovNetcap(uint64(m.TTL))
	}
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *LLDPChassisID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subtype != 0 {
		n += 1 + sovNetcap(uint64(m.Subtype))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *LLDPPortID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subtype != 0 {
		n += 1 + sovNetcap(uint64(m.Subtype))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *LinkLayerDiscoveryValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	if m.Length != 0 {
		n += 1 + sovNetcap(uint64(m.Length))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *EthernetCTP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.SkipCount != 0 {
		n += 1 + sovNetcap(uint64(m.SkipCount))
	}
	return n
}

func (m *EthernetCTPReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.Function != 0 {
		n += 1 + sovNetcap(uint64(m.Function))
	}
	if m.ReceiptNumber != 0 {
		n += 1 + sovNetcap(uint64(m.ReceiptNumber))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *LinkLayerDiscoveryInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	l = len(m.PortDescription)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SysName)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SysDescription)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.SysCapabilities != nil {
		l = m.SysCapabilities.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.MgmtAddress != nil {
		l = m.MgmtAddress.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.OrgTLVs) > 0 {
		for _, e := range m.OrgTLVs {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	if len(m.Unknown) > 0 {
		for _, e := range m.Unknown {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *LLDPSysCapabilities) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SystemCap != nil {
		l = m.SystemCap.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.EnabledCap != nil {
		l = m.EnabledCap.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *LLDPCapabilities) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Other {
		n += 2
	}
	if m.Repeater {
		n += 2
	}
	if m.Bridge {
		n += 2
	}
	if m.WLANAP {
		n += 2
	}
	if m.Router {
		n += 2
	}
	if m.Phone {
		n += 2
	}
	if m.DocSis {
		n += 2
	}
	if m.StationOnly {
		n += 2
	}
	if m.CVLAN {
		n += 2
	}
	if m.SVLAN {
		n += 2
	}
	if m.TMPR {
		n += 2
	}
	return n
}

func (m *LLDPMgmtAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subtype != 0 {
		n += 1 + sovNetcap(uint64(m.Subtype))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.InterfaceSubtype != 0 {
		n += 1 + sovNetcap(uint64(m.InterfaceSubtype))
	}
	if m.InterfaceNumber != 0 {
		n += 1 + sovNetcap(uint64(m.InterfaceNumber))
	}
	l = len(m.OID)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *LLDPOrgSpecificTLV) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OUI != 0 {
		n += 1 + sovNetcap(uint64(m.OUI))
	}
	if m.SubType != 0 {
		n += 1 + sovNetcap(uint64(m.SubType))
	}
	l = len(m.Info)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *IPv4) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.Version != 0 {
		n += 1 + sovNetcap(uint64(m.Version))
	}
	if m.IHL != 0 {
		n += 1 + sovNetcap(uint64(m.IHL))
	}
	if m.TOS != 0 {
		n += 1 + sovNetcap(uint64(m.TOS))
	}
	if m.Length != 0 {
		n += 1 + sovNetcap(uint64(m.Length))
	}
	if m.Id != 0 {
		n += 1 + sovNetcap(uint64(m.Id))
	}
	if m.Flags != 0 {
		n += 1 + sovNetcap(uint64(m.Flags))
	}
	if m.FragOffset != 0 {
		n += 1 + sovNetcap(uint64(m.FragOffset))
	}
	if m.TTL != 0 {
		n += 1 + sovNetcap(uint64(m.TTL))
	}
	if m.Protocol != 0 {
		n += 1 + sovNetcap(uint64(m.Protocol))
	}
	if m.Checksum != 0 {
		n += 1 + sovNetcap(uint64(m.Checksum))
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Padding)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.Options) > 0 {
		for _, e := range m.Options {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	if m.PayloadEntropy != 0 {
		n += 10
	}
	if m.PayloadSize != 0 {
		n += 2 + sovNetcap(uint64(m.PayloadSize))
	}
	if m.SrcPort != 0 {
		n += 2 + sovNetcap(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 2 + sovNetcap(uint64(m.DstPort))
	}
	return n
}

func (m *IPv4Option) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OptionType != 0 {
		n += 1 + sovNetcap(uint64(m.OptionType))
	}
	if m.OptionLength != 0 {
		n += 1 + sovNetcap(uint64(m.OptionLength))
	}
	l = len(m.OptionData)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *IPv6) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.Version != 0 {
		n += 1 + sovNetcap(uint64(m.Version))
	}
	if m.TrafficClass != 0 {
		n += 1 + sovNetcap(uint64(m.TrafficClass))
	}
	if m.FlowLabel != 0 {
		n += 1 + sovNetcap(uint64(m.FlowLabel))
	}
	if m.Length != 0 {
		n += 1 + sovNetcap(uint64(m.Length))
	}
	if m.NextHeader != 0 {
		n += 1 + sovNetcap(uint64(m.NextHeader))
	}
	if m.HopLimit != 0 {
		n += 1 + sovNetcap(uint64(m.HopLimit))
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.PayloadEntropy != 0 {
		n += 9
	}
	if m.PayloadSize != 0 {
		n += 1 + sovNetcap(uint64(m.PayloadSize))
	}
	if m.HopByHop != nil {
		l = m.HopByHop.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.SrcPort != 0 {
		n += 1 + sovNetcap(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 1 + sovNetcap(uint64(m.DstPort))
	}
	return n
}

func (m *IPv6Fragment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.NextHeader != 0 {
		n += 1 + sovNetcap(uint64(m.NextHeader))
	}
	if m.Reserved1 != 0 {
		n += 1 + sovNetcap(uint64(m.Reserved1))
	}
	if m.FragmentOffset != 0 {
		n += 1 + sovNetcap(uint64(m.FragmentOffset))
	}
	if m.Reserved2 != 0 {
		n += 1 + sovNetcap(uint64(m.Reserved2))
	}
	if m.MoreFragments {
		n += 2
	}
	if m.Identification != 0 {
		n += 1 + sovNetcap(uint64(m.Identification))
	}
	if m.SrcPort != 0 {
		n += 1 + sovNetcap(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 1 + sovNetcap(uint64(m.DstPort))
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *ICMPv4) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.TypeCode != 0 {
		n += 1 + sovNetcap(uint64(m.TypeCode))
	}
	if m.Checksum != 0 {
		n += 1 + sovNetcap(uint64(m.Checksum))
	}
	if m.Id != 0 {
		n += 1 + sovNetcap(uint64(m.Id))
	}
	if m.Seq != 0 {
		n += 1 + sovNetcap(uint64(m.Seq))
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *ICMPv6) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.TypeCode != 0 {
		n += 1 + sovNetcap(uint64(m.TypeCode))
	}
	if m.Checksum != 0 {
		n += 1 + sovNetcap(uint64(m.Checksum))
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *ICMPv6NeighborAdvertisement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.Flags != 0 {
		n += 1 + sovNetcap(uint64(m.Flags))
	}
	l = len(m.TargetAddress)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.Options) > 0 {
		for _, e := range m.Options {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *ICMPv6RouterAdvertisement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.HopLimit != 0 {
		n += 1 + sovNetcap(uint64(m.HopLimit))
	}
	if m.Flags != 0 {
		n += 1 + sovNetcap(uint64(m.Flags))
	}
	if m.RouterLifetime != 0 {
		n += 1 + sovNetcap(uint64(m.RouterLifetime))
	}
	if m.ReachableTime != 0 {
		n += 1 + sovNetcap(uint64(m.ReachableTime))
	}
	if m.RetransTimer != 0 {
		n += 1 + sovNetcap(uint64(m.RetransTimer))
	}
	if len(m.Options) > 0 {
		for _, e := range m.Options {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *ICMPv6Option) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *UDP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.SrcPort != 0 {
		n += 1 + sovNetcap(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 1 + sovNetcap(uint64(m.DstPort))
	}
	if m.Length != 0 {
		n += 1 + sovNetcap(uint64(m.Length))
	}
	if m.Checksum != 0 {
		n += 1 + sovNetcap(uint64(m.Checksum))
	}
	if m.PayloadEntropy != 0 {
		n += 9
	}
	if m.PayloadSize != 0 {
		n += 1 + sovNetcap(uint64(m.PayloadSize))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *TCP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.SrcPort != 0 {
		n += 1 + sovNetcap(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 1 + sovNetcap(uint64(m.DstPort))
	}
	if m.SeqNum != 0 {
		n += 1 + sovNetcap(uint64(m.SeqNum))
	}
	if m.AckNum != 0 {
		n += 1 + sovNetcap(uint64(m.AckNum))
	}
	if m.DataOffset != 0 {
		n += 1 + sovNetcap(uint64(m.DataOffset))
	}
	if m.FIN {
		n += 2
	}
	if m.SYN {
		n += 2
	}
	if m.RST {
		n += 2
	}
	if m.PSH {
		n += 2
	}
	if m.ACK {
		n += 2
	}
	if m.URG {
		n += 2
	}
	if m.ECE {
		n += 2
	}
	if m.CWR {
		n += 2
	}
	if m.NS {
		n += 2
	}
	if m.Window != 0 {
		n += 2 + sovNetcap(uint64(m.Window))
	}
	if m.Checksum != 0 {
		n += 2 + sovNetcap(uint64(m.Checksum))
	}
	if m.Urgent != 0 {
		n += 2 + sovNetcap(uint64(m.Urgent))
	}
	l = len(m.Padding)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	if len(m.Options) > 0 {
		for _, e := range m.Options {
			l = e.Size()
			n += 2 + l + sovNetcap(uint64(l))
		}
	}
	if m.PayloadEntropy != 0 {
		n += 10
	}
	if m.PayloadSize != 0 {
		n += 2 + sovNetcap(uint64(m.PayloadSize))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *TCPOption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OptionType != 0 {
		n += 1 + sovNetcap(uint64(m.OptionType))
	}
	if m.OptionLength != 0 {
		n += 1 + sovNetcap(uint64(m.OptionLength))
	}
	l = len(m.OptionData)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *SCTP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.SrcPort != 0 {
		n += 1 + sovNetcap(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 1 + sovNetcap(uint64(m.DstPort))
	}
	if m.VerificationTag != 0 {
		n += 1 + sovNetcap(uint64(m.VerificationTag))
	}
	if m.Checksum != 0 {
		n += 1 + sovNetcap(uint64(m.Checksum))
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *DNS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.ID != 0 {
		n += 1 + sovNetcap(uint64(m.ID))
	}
	if m.QR {
		n += 2
	}
	if m.OpCode != 0 {
		n += 1 + sovNetcap(uint64(m.OpCode))
	}
	if m.AA {
		n += 2
	}
	if m.TC {
		n += 2
	}
	if m.RD {
		n += 2
	}
	if m.RA {
		n += 2
	}
	if m.Z != 0 {
		n += 1 + sovNetcap(uint64(m.Z))
	}
	if m.ResponseCode != 0 {
		n += 1 + sovNetcap(uint64(m.ResponseCode))
	}
	if m.QDCount != 0 {
		n += 1 + sovNetcap(uint64(m.QDCount))
	}
	if m.ANCount != 0 {
		n += 1 + sovNetcap(uint64(m.ANCount))
	}
	if m.NSCount != 0 {
		n += 1 + sovNetcap(uint64(m.NSCount))
	}
	if m.ARCount != 0 {
		n += 1 + sovNetcap(uint64(m.ARCount))
	}
	if len(m.Questions) > 0 {
		for _, e := range m.Questions {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	if len(m.Answers) > 0 {
		for _, e := range m.Answers {
			l = e.Size()
			n += 2 + l + sovNetcap(uint64(l))
		}
	}
	if len(m.Authorities) > 0 {
		for _, e := range m.Authorities {
			l = e.Size()
			n += 2 + l + sovNetcap(uint64(l))
		}
	}
	if len(m.Additionals) > 0 {
		for _, e := range m.Additionals {
			l = e.Size()
			n += 2 + l + sovNetcap(uint64(l))
		}
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	if m.SrcPort != 0 {
		n += 2 + sovNetcap(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 2 + sovNetcap(uint64(m.DstPort))
	}
	return n
}

func (m *DNSResourceRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	if m.Class != 0 {
		n += 1 + sovNetcap(uint64(m.Class))
	}
	if m.TTL != 0 {
		n += 1 + sovNetcap(uint64(m.TTL))
	}
	if m.DataLength != 0 {
		n += 1 + sovNetcap(uint64(m.DataLength))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.IP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.NS)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.CNAME)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.PTR)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.SOA != nil {
		l = m.SOA.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.SRV != nil {
		l = m.SRV.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.MX != nil {
		l = m.MX.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.TXTs) > 0 {
		for _, b := range m.TXTs {
			l = len(b)
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *DNSSOA) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MName)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.RName)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Serial != 0 {
		n += 1 + sovNetcap(uint64(m.Serial))
	}
	if m.Refresh != 0 {
		n += 1 + sovNetcap(uint64(m.Refresh))
	}
	if m.Retry != 0 {
		n += 1 + sovNetcap(uint64(m.Retry))
	}
	if m.Expire != 0 {
		n += 1 + sovNetcap(uint64(m.Expire))
	}
	if m.Minimum != 0 {
		n += 1 + sovNetcap(uint64(m.Minimum))
	}
	return n
}

func (m *DNSSRV) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Priority != 0 {
		n += 1 + sovNetcap(uint64(m.Priority))
	}
	if m.Weight != 0 {
		n += 1 + sovNetcap(uint64(m.Weight))
	}
	if m.Port != 0 {
		n += 1 + sovNetcap(uint64(m.Port))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *DNSMX) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Preference != 0 {
		n += 1 + sovNetcap(uint64(m.Preference))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *DNSQuestion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	if m.Class != 0 {
		n += 1 + sovNetcap(uint64(m.Class))
	}
	return n
}

func (m *DHCPv4) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.Operation != 0 {
		n += 1 + sovNetcap(uint64(m.Operation))
	}
	if m.HardwareType != 0 {
		n += 1 + sovNetcap(uint64(m.HardwareType))
	}
	if m.HardwareLen != 0 {
		n += 1 + sovNetcap(uint64(m.HardwareLen))
	}
	if m.HardwareOpts != 0 {
		n += 1 + sovNetcap(uint64(m.HardwareOpts))
	}
	if m.Xid != 0 {
		n += 1 + sovNetcap(uint64(m.Xid))
	}
	if m.Secs != 0 {
		n += 1 + sovNetcap(uint64(m.Secs))
	}
	if m.Flags != 0 {
		n += 1 + sovNetcap(uint64(m.Flags))
	}
	l = len(m.ClientIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.YourClientIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.NextServerIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.RelayAgentIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.ClientHWAddr)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.ServerName)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.File)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.Options) > 0 {
		for _, e := range m.Options {
			l = e.Size()
			n += 2 + l + sovNetcap(uint64(l))
		}
	}
	l = len(m.Fingerprint)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	if m.SrcPort != 0 {
		n += 2 + sovNetcap(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 2 + sovNetcap(uint64(m.DstPort))
	}
	return n
}

func (m *DHCPOption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	if m.Length != 0 {
		n += 1 + sovNetcap(uint64(m.Length))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *DHCPv6) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.MsgType != 0 {
		n += 1 + sovNetcap(uint64(m.MsgType))
	}
	if m.HopCount != 0 {
		n += 1 + sovNetcap(uint64(m.HopCount))
	}
	l = len(m.LinkAddr)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.PeerAddr)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.TransactionID)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.Options) > 0 {
		for _, e := range m.Options {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	l = len(m.Fingerprint)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.SrcPort != 0 {
		n += 1 + sovNetcap(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 1 + sovNetcap(uint64(m.DstPort))
	}
	return n
}

func (m *DHCPv6Option) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovNetcap(uint64(m.Code))
	}
	if m.Length != 0 {
		n += 1 + sovNetcap(uint64(m.Length))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *LLC) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.DSAP != 0 {
		n += 1 + sovNetcap(uint64(m.DSAP))
	}
	if m.IG {
		n += 2
	}
	if m.SSAP != 0 {
		n += 1 + sovNetcap(uint64(m.SSAP))
	}
	if m.CR {
		n += 2
	}
	if m.Control != 0 {
		n += 1 + sovNetcap(uint64(m.Control))
	}
	return n
}

func (m *NTP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.LeapIndicator != 0 {
		n += 1 + sovNetcap(uint64(m.LeapIndicator))
	}
	if m.Version != 0 {
		n += 1 + sovNetcap(uint64(m.Version))
	}
	if m.Mode != 0 {
		n += 1 + sovNetcap(uint64(m.Mode))
	}
	if m.Stratum != 0 {
		n += 1 + sovNetcap(uint64(m.Stratum))
	}
	if m.Poll != 0 {
		n += 1 + sovNetcap(uint64(m.Poll))
	}
	if m.Precision != 0 {
		n += 1 + sovNetcap(uint64(m.Precision))
	}
	if m.RootDelay != 0 {
		n += 1 + sovNetcap(uint64(m.RootDelay))
	}
	if m.RootDispersion != 0 {
		n += 1 + sovNetcap(uint64(m.RootDispersion))
	}
	if m.ReferenceID != 0 {
		n += 1 + sovNetcap(uint64(m.ReferenceID))
	}
	if m.ReferenceTimestamp != 0 {
		n += 1 + sovNetcap(uint64(m.ReferenceTimestamp))
	}
	if m.OriginTimestamp != 0 {
		n += 1 + sovNetcap(uint64(m.OriginTimestamp))
	}
	if m.ReceiveTimestamp != 0 {
		n += 1 + sovNetcap(uint64(m.ReceiveTimestamp))
	}
	if m.TransmitTimestamp != 0 {
		n += 1 + sovNetcap(uint64(m.TransmitTimestamp))
	}
	l = len(m.ExtensionBytes)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	if m.SrcPort != 0 {
		n += 2 + sovNetcap(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 2 + sovNetcap(uint64(m.DstPort))
	}
	return n
}

func (m *SIP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.Version != 0 {
		n += 1 + sovNetcap(uint64(m.Version))
	}
	if m.Method != 0 {
		n += 1 + sovNetcap(uint64(m.Method))
	}
	if len(m.Headers) > 0 {
		for _, s := range m.Headers {
			l = len(s)
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	if m.IsResponse {
		n += 2
	}
	if m.ResponseCode != 0 {
		n += 1 + sovNetcap(uint64(m.ResponseCode))
	}
	l = len(m.ResponseStatus)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.SrcPort != 0 {
		n += 1 + sovNetcap(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 1 + sovNetcap(uint64(m.DstPort))
	}
	return n
}

func (m *IGMP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	if m.MaxResponseTime != 0 {
		n += 1 + sovNetcap(uint64(m.MaxResponseTime))
	}
	if m.Checksum != 0 {
		n += 1 + sovNetcap(uint64(m.Checksum))
	}
	l = len(m.GroupAddress)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.SupressRouterProcessing {
		n += 2
	}
	if m.RobustnessValue != 0 {
		n += 1 + sovNetcap(uint64(m.RobustnessValue))
	}
	if m.IntervalTime != 0 {
		n += 1 + sovNetcap(uint64(m.IntervalTime))
	}
	if len(m.SourceAddresses) > 0 {
		for _, s := range m.SourceAddresses {
			l = len(s)
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	if m.NumberOfGroupRecords != 0 {
		n += 1 + sovNetcap(uint64(m.NumberOfGroupRecords))
	}
	if m.NumberOfSources != 0 {
		n += 1 + sovNetcap(uint64(m.NumberOfSources))
	}
	if len(m.GroupRecords) > 0 {
		for _, e := range m.GroupRecords {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	if m.Version != 0 {
		n += 1 + sovNetcap(uint64(m.Version))
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *IGMPv3GroupRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	if m.AuxDataLen != 0 {
		n += 1 + sovNetcap(uint64(m.AuxDataLen))
	}
	if m.NumberOfSources != 0 {
		n += 1 + sovNetcap(uint64(m.NumberOfSources))
	}
	l = len(m.MulticastAddress)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.SourceAddresses) > 0 {
		for _, s := range m.SourceAddresses {
			l = len(s)
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *IPv6HopByHop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if len(m.Options) > 0 {
		for _, e := range m.Options {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *IPv6HopByHopOption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OptionType != 0 {
		n += 1 + sovNetcap(uint64(m.OptionType))
	}
	if m.OptionLength != 0 {
		n += 1 + sovNetcap(uint64(m.OptionLength))
	}
	if m.ActualLength != 0 {
		n += 1 + sovNetcap(uint64(m.ActualLength))
	}
	l = len(m.OptionData)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.OptionAlignment != nil {
		l = m.OptionAlignment.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *IPv6HopByHopOptionAlignment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.One != 0 {
		n += 1 + sovNetcap(uint64(m.One))
	}
	if m.Two != 0 {
		n += 1 + sovNetcap(uint64(m.Two))
	}
	return n
}

func (m *SNAP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	l = len(m.OrganizationalCode)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	return n
}

func (m *ICMPv6Echo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.Identifier != 0 {
		n += 1 + sovNetcap(uint64(m.Identifier))
	}
	if m.SeqNumber != 0 {
		n += 1 + sovNetcap(uint64(m.SeqNumber))
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *ICMPv6NeighborSolicitation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	l = len(m.TargetAddress)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.Options) > 0 {
		for _, e := range m.Options {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *ICMPv6RouterSolicitation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if len(m.Options) > 0 {
		for _, e := range m.Options {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *HTTP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	l = len(m.Proto)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.UserAgent)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Referer)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.ReqCookies) > 0 {
		for _, e := range m.ReqCookies {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	if m.ReqContentLength != 0 {
		n += 1 + sovNetcap(uint64(m.ReqContentLength))
	}
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.ResContentLength != 0 {
		n += 1 + sovNetcap(uint64(m.ResContentLength))
	}
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.StatusCode != 0 {
		n += 1 + sovNetcap(uint64(m.StatusCode))
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.ReqContentEncoding)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.ResContentEncoding)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	l = len(m.ServerName)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	if len(m.ResCookies) > 0 {
		for _, e := range m.ResCookies {
			l = e.Size()
			n += 2 + l + sovNetcap(uint64(l))
		}
	}
	l = len(m.ResContentType)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	if m.DoneAfter != 0 {
		n += 2 + sovNetcap(uint64(m.DoneAfter))
	}
	if m.DNSDoneAfter != 0 {
		n += 2 + sovNetcap(uint64(m.DNSDoneAfter))
	}
	if m.FirstByteAfter != 0 {
		n += 2 + sovNetcap(uint64(m.FirstByteAfter))
	}
	if m.TLSDoneAfter != 0 {
		n += 2 + sovNetcap(uint64(m.TLSDoneAfter))
	}
	l = len(m.ContentTypeDetected)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	l = len(m.ResContentTypeDetected)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	if len(m.RequestHeader) > 0 {
		for k, v := range m.RequestHeader {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovNetcap(uint64(len(k))) + 1 + len(v) + sovNetcap(uint64(len(v)))
			n += mapEntrySize + 2 + sovNetcap(uint64(mapEntrySize))
		}
	}
	if len(m.ResponseHeader) > 0 {
		for k, v := range m.ResponseHeader {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovNetcap(uint64(len(k))) + 1 + len(v) + sovNetcap(uint64(len(v)))
			n += mapEntrySize + 2 + sovNetcap(uint64(mapEntrySize))
		}
	}
	if len(m.Parameters) > 0 {
		for k, v := range m.Parameters {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovNetcap(uint64(len(k))) + 1 + len(v) + sovNetcap(uint64(len(v)))
			n += mapEntrySize + 2 + sovNetcap(uint64(mapEntrySize))
		}
	}
	l = len(m.RequestBody)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	l = len(m.ResponseBody)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *HTTPCookie) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Expires != 0 {
		n += 1 + sovNetcap(uint64(m.Expires))
	}
	if m.MaxAge != 0 {
		n += 1 + sovNetcap(uint64(m.MaxAge))
	}
	if m.Secure {
		n += 2
	}
	if m.HttpOnly {
		n += 2
	}
	if m.SameSite != 0 {
		n += 1 + sovNetcap(uint64(m.SameSite))
	}
	return n
}

func (m *TLSClientHello) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	if m.Version != 0 {
		n += 1 + sovNetcap(uint64(m.Version))
	}
	if m.MessageLen != 0 {
		n += 1 + sovNetcap(uint64(m.MessageLen))
	}
	if m.HandshakeType != 0 {
		n += 1 + sovNetcap(uint64(m.HandshakeType))
	}
	if m.HandshakeLen != 0 {
		n += 1 + sovNetcap(uint64(m.HandshakeLen))
	}
	if m.HandshakeVersion != 0 {
		n += 1 + sovNetcap(uint64(m.HandshakeVersion))
	}
	l = len(m.Random)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.SessionIDLen != 0 {
		n += 1 + sovNetcap(uint64(m.SessionIDLen))
	}
	l = len(m.SessionID)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.CipherSuiteLen != 0 {
		n += 1 + sovNetcap(uint64(m.CipherSuiteLen))
	}
	if m.ExtensionLen != 0 {
		n += 1 + sovNetcap(uint64(m.ExtensionLen))
	}
	l = len(m.SNI)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.OSCP {
		n += 2
	}
	if len(m.CipherSuites) > 0 {
		l = 0
		for _, e := range m.CipherSuites {
			l += sovNetcap(uint64(e))
		}
		n += 1 + sovNetcap(uint64(l)) + l
	}
	if len(m.CompressMethods) > 0 {
		l = 0
		for _, e := range m.CompressMethods {
			l += sovNetcap(uint64(e))
		}
		n += 2 + sovNetcap(uint64(l)) + l
	}
	if len(m.SignatureAlgs) > 0 {
		l = 0
		for _, e := range m.SignatureAlgs {
			l += sovNetcap(uint64(e))
		}
		n += 2 + sovNetcap(uint64(l)) + l
	}
	if len(m.SupportedGroups) > 0 {
		l = 0
		for _, e := range m.SupportedGroups {
			l += sovNetcap(uint64(e))
		}
		n += 2 + sovNetcap(uint64(l)) + l
	}
	if len(m.SupportedPoints) > 0 {
		l = 0
		for _, e := range m.SupportedPoints {
			l += sovNetcap(uint64(e))
		}
		n += 2 + sovNetcap(uint64(l)) + l
	}
	if len(m.ALPNs) > 0 {
		for _, s := range m.ALPNs {
			l = len(s)
			n += 2 + l + sovNetcap(uint64(l))
		}
	}
	l = len(m.Ja3)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	l = len(m.SrcMAC)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstMAC)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	if m.SrcPort != 0 {
		n += 2 + sovNetcap(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 2 + sovNetcap(uint64(m.DstPort))
	}
	if len(m.Extensions) > 0 {
		l = 0
		for _, e := range m.Extensions {
			l += sovNetcap(uint64(e))
		}
		n += 2 + sovNetcap(uint64(l)) + l
	}
	return n
}

func (m *TLSServerHello) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.Version != 0 {
		n += 1 + sovNetcap(uint64(m.Version))
	}
	l = len(m.Random)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SessionID)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.CipherSuite != 0 {
		n += 1 + sovNetcap(uint64(m.CipherSuite))
	}
	if m.CompressionMethod != 0 {
		n += 1 + sovNetcap(uint64(m.CompressionMethod))
	}
	if m.NextProtoNeg {
		n += 2
	}
	if len(m.NextProtos) > 0 {
		for _, s := range m.NextProtos {
			l = len(s)
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	if m.OCSPStapling {
		n += 2
	}
	if m.TicketSupported {
		n += 2
	}
	if m.SecureRenegotiationSupported {
		n += 2
	}
	l = len(m.SecureRenegotiation)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.AlpnProtocol)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Ems {
		n += 2
	}
	if len(m.Scts) > 0 {
		for _, b := range m.Scts {
			l = len(b)
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	if m.SupportedVersion != 0 {
		n += 2 + sovNetcap(uint64(m.SupportedVersion))
	}
	if m.SelectedIdentityPresent {
		n += 3
	}
	if m.SelectedIdentity != 0 {
		n += 2 + sovNetcap(uint64(m.SelectedIdentity))
	}
	l = len(m.Cookie)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	if m.SelectedGroup != 0 {
		n += 2 + sovNetcap(uint64(m.SelectedGroup))
	}
	if len(m.Extensions) > 0 {
		l = 0
		for _, e := range m.Extensions {
			l += sovNetcap(uint64(e))
		}
		n += 2 + sovNetcap(uint64(l)) + l
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	l = len(m.SrcMAC)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstMAC)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	if m.SrcPort != 0 {
		n += 2 + sovNetcap(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 2 + sovNetcap(uint64(m.DstPort))
	}
	l = len(m.Ja3S)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *IPSecAH) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.Reserved != 0 {
		n += 1 + sovNetcap(uint64(m.Reserved))
	}
	if m.SPI != 0 {
		n += 1 + sovNetcap(uint64(m.SPI))
	}
	if m.Seq != 0 {
		n += 1 + sovNetcap(uint64(m.Seq))
	}
	l = len(m.AuthenticationData)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *IPSecESP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.SPI != 0 {
		n += 1 + sovNetcap(uint64(m.SPI))
	}
	if m.Seq != 0 {
		n += 1 + sovNetcap(uint64(m.Seq))
	}
	if m.LenEncrypted != 0 {
		n += 1 + sovNetcap(uint64(m.LenEncrypted))
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *Geneve) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.Version != 0 {
		n += 1 + sovNetcap(uint64(m.Version))
	}
	if m.OptionsLength != 0 {
		n += 1 + sovNetcap(uint64(m.OptionsLength))
	}
	if m.OAMPacket {
		n += 2
	}
	if m.CriticalOption {
		n += 2
	}
	if m.Protocol != 0 {
		n += 1 + sovNetcap(uint64(m.Protocol))
	}
	if m.VNI != 0 {
		n += 1 + sovNetcap(uint64(m.VNI))
	}
	if len(m.Options) > 0 {
		for _, e := range m.Options {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *GeneveOption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Class != 0 {
		n += 1 + sovNetcap(uint64(m.Class))
	}
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	if m.Flags != 0 {
		n += 1 + sovNetcap(uint64(m.Flags))
	}
	if m.Length != 0 {
		n += 1 + sovNetcap(uint64(m.Length))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *VXLAN) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.ValidIDFlag {
		n += 2
	}
	if m.VNI != 0 {
		n += 1 + sovNetcap(uint64(m.VNI))
	}
	if m.GBPExtension {
		n += 2
	}
	if m.GBPDontLearn {
		n += 2
	}
	if m.GBPApplied {
		n += 2
	}
	if m.GBPGroupPolicyID != 0 {
		n += 1 + sovNetcap(uint64(m.GBPGroupPolicyID))
	}
	return n
}

func (m *USB) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.ID != 0 {
		n += 1 + sovNetcap(uint64(m.ID))
	}
	if m.EventType != 0 {
		n += 1 + sovNetcap(uint64(m.EventType))
	}
	if m.TransferType != 0 {
		n += 1 + sovNetcap(uint64(m.TransferType))
	}
	if m.Direction != 0 {
		n += 1 + sovNetcap(uint64(m.Direction))
	}
	if m.EndpointNumber != 0 {
		n += 1 + sovNetcap(uint64(m.EndpointNumber))
	}
	if m.DeviceAddress != 0 {
		n += 1 + sovNetcap(uint64(m.DeviceAddress))
	}
	if m.BusID != 0 {
		n += 1 + sovNetcap(uint64(m.BusID))
	}
	if m.TimestampSec != 0 {
		n += 1 + sovNetcap(uint64(m.TimestampSec))
	}
	if m.TimestampUsec != 0 {
		n += 1 + sovNetcap(uint64(m.TimestampUsec))
	}
	if m.Setup {
		n += 2
	}
	if m.Data {
		n += 2
	}
	if m.Status != 0 {
		n += 1 + sovNetcap(uint64(m.Status))
	}
	if m.UrbLength != 0 {
		n += 1 + sovNetcap(uint64(m.UrbLength))
	}
	if m.UrbDataLength != 0 {
		n += 1 + sovNetcap(uint64(m.UrbDataLength))
	}
	if m.UrbInterval != 0 {
		n += 2 + sovNetcap(uint64(m.UrbInterval))
	}
	if m.UrbStartFrame != 0 {
		n += 2 + sovNetcap(uint64(m.UrbStartFrame))
	}
	if m.UrbCopyOfTransferFlags != 0 {
		n += 2 + sovNetcap(uint64(m.UrbCopyOfTransferFlags))
	}
	if m.IsoNumDesc != 0 {
		n += 2 + sovNetcap(uint64(m.IsoNumDesc))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *USBRequestBlockSetup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.RequestType != 0 {
		n += 1 + sovNetcap(uint64(m.RequestType))
	}
	if m.Request != 0 {
		n += 1 + sovNetcap(uint64(m.Request))
	}
	if m.Value != 0 {
		n += 1 + sovNetcap(uint64(m.Value))
	}
	if m.Index != 0 {
		n += 1 + sovNetcap(uint64(m.Index))
	}
	if m.Length != 0 {
		n += 1 + sovNetcap(uint64(m.Length))
	}
	return n
}

func (m *LCM) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.Magic != 0 {
		n += 1 + sovNetcap(uint64(m.Magic))
	}
	if m.SequenceNumber != 0 {
		n += 1 + sovNetcap(uint64(m.SequenceNumber))
	}
	if m.PayloadSize != 0 {
		n += 1 + sovNetcap(uint64(m.PayloadSize))
	}
	if m.FragmentOffset != 0 {
		n += 1 + sovNetcap(uint64(m.FragmentOffset))
	}
	if m.FragmentNumber != 0 {
		n += 1 + sovNetcap(uint64(m.FragmentNumber))
	}
	if m.TotalFragments != 0 {
		n += 1 + sovNetcap(uint64(m.TotalFragments))
	}
	l = len(m.ChannelName)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Fragmented {
		n += 2
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.SrcPort != 0 {
		n += 1 + sovNetcap(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 1 + sovNetcap(uint64(m.DstPort))
	}
	return n
}

func (m *MPLS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.Label != 0 {
		n += 1 + sovNetcap(uint64(m.Label))
	}
	if m.TrafficClass != 0 {
		n += 1 + sovNetcap(uint64(m.TrafficClass))
	}
	if m.StackBottom {
		n += 2
	}
	if m.TTL != 0 {
		n += 1 + sovNetcap(uint64(m.TTL))
	}
	return n
}

func (m *Modbus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.TransactionID != 0 {
		n += 1 + sovNetcap(uint64(m.TransactionID))
	}
	if m.ProtocolID != 0 {
		n += 1 + sovNetcap(uint64(m.ProtocolID))
	}
	if m.Length != 0 {
		n += 1 + sovNetcap(uint64(m.Length))
	}
	if m.UnitID != 0 {
		n += 1 + sovNetcap(uint64(m.UnitID))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Exception {
		n += 2
	}
	if m.FunctionCode != 0 {
		n += 1 + sovNetcap(uint64(m.FunctionCode))
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.SrcPort != 0 {
		n += 1 + sovNetcap(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 1 + sovNetcap(uint64(m.DstPort))
	}
	return n
}

func (m *OSPFv2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.Version != 0 {
		n += 1 + sovNetcap(uint64(m.Version))
	}
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	if m.PacketLength != 0 {
		n += 1 + sovNetcap(uint64(m.PacketLength))
	}
	if m.RouterID != 0 {
		n += 1 + sovNetcap(uint64(m.RouterID))
	}
	if m.AreaID != 0 {
		n += 1 + sovNetcap(uint64(m.AreaID))
	}
	if m.Checksum != 0 {
		n += 1 + sovNetcap(uint64(m.Checksum))
	}
	if m.AuType != 0 {
		n += 1 + sovNetcap(uint64(m.AuType))
	}
	if m.Authentication != 0 {
		n += 1 + sovNetcap(uint64(m.Authentication))
	}
	if len(m.LSAs) > 0 {
		for _, e := range m.LSAs {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	if m.LSU != nil {
		l = m.LSU.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.LSR) > 0 {
		for _, e := range m.LSR {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	if m.DbDesc != nil {
		l = m.DbDesc.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.HelloV2 != nil {
		l = m.HelloV2.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *HelloPkg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InterfaceID != 0 {
		n += 1 + sovNetcap(uint64(m.InterfaceID))
	}
	if m.RtrPriority != 0 {
		n += 1 + sovNetcap(uint64(m.RtrPriority))
	}
	if m.Options != 0 {
		n += 1 + sovNetcap(uint64(m.Options))
	}
	if m.HelloInterval != 0 {
		n += 1 + sovNetcap(uint64(m.HelloInterval))
	}
	if m.RouterDeadInterval != 0 {
		n += 1 + sovNetcap(uint64(m.RouterDeadInterval))
	}
	if m.DesignatedRouterID != 0 {
		n += 1 + sovNetcap(uint64(m.DesignatedRouterID))
	}
	if m.BackupDesignatedRouterID != 0 {
		n += 1 + sovNetcap(uint64(m.BackupDesignatedRouterID))
	}
	if len(m.NeighborID) > 0 {
		l = 0
		for _, e := range m.NeighborID {
			l += sovNetcap(uint64(e))
		}
		n += 1 + sovNetcap(uint64(l)) + l
	}
	return n
}

func (m *HelloPkgV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InterfaceID != 0 {
		n += 1 + sovNetcap(uint64(m.InterfaceID))
	}
	if m.RtrPriority != 0 {
		n += 1 + sovNetcap(uint64(m.RtrPriority))
	}
	if m.Options != 0 {
		n += 1 + sovNetcap(uint64(m.Options))
	}
	if m.HelloInterval != 0 {
		n += 1 + sovNetcap(uint64(m.HelloInterval))
	}
	if m.RouterDeadInterval != 0 {
		n += 1 + sovNetcap(uint64(m.RouterDeadInterval))
	}
	if m.DesignatedRouterID != 0 {
		n += 1 + sovNetcap(uint64(m.DesignatedRouterID))
	}
	if m.BackupDesignatedRouterID != 0 {
		n += 1 + sovNetcap(uint64(m.BackupDesignatedRouterID))
	}
	if len(m.NeighborID) > 0 {
		l = 0
		for _, e := range m.NeighborID {
			l += sovNetcap(uint64(e))
		}
		n += 1 + sovNetcap(uint64(l)) + l
	}
	if m.NetworkMask != 0 {
		n += 1 + sovNetcap(uint64(m.NetworkMask))
	}
	return n
}

func (m *DbDescPkg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Options != 0 {
		n += 1 + sovNetcap(uint64(m.Options))
	}
	if m.InterfaceMTU != 0 {
		n += 1 + sovNetcap(uint64(m.InterfaceMTU))
	}
	if m.Flags != 0 {
		n += 1 + sovNetcap(uint64(m.Flags))
	}
	if m.DDSeqNumber != 0 {
		n += 1 + sovNetcap(uint64(m.DDSeqNumber))
	}
	if len(m.LSAinfo) > 0 {
		for _, e := range m.LSAinfo {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *OSPFv3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.Version != 0 {
		n += 1 + sovNetcap(uint64(m.Version))
	}
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	if m.PacketLength != 0 {
		n += 1 + sovNetcap(uint64(m.PacketLength))
	}
	if m.RouterID != 0 {
		n += 1 + sovNetcap(uint64(m.RouterID))
	}
	if m.AreaID != 0 {
		n += 1 + sovNetcap(uint64(m.AreaID))
	}
	if m.Checksum != 0 {
		n += 1 + sovNetcap(uint64(m.Checksum))
	}
	if m.Instance != 0 {
		n += 1 + sovNetcap(uint64(m.Instance))
	}
	if m.Reserved != 0 {
		n += 1 + sovNetcap(uint64(m.Reserved))
	}
	if m.Hello != nil {
		l = m.Hello.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.DbDesc != nil {
		l = m.DbDesc.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.LSR) > 0 {
		for _, e := range m.LSR {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	if m.LSU != nil {
		l = m.LSU.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.LSAs) > 0 {
		for _, e := range m.LSAs {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *LSAheader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LSAge != 0 {
		n += 1 + sovNetcap(uint64(m.LSAge))
	}
	if m.LSType != 0 {
		n += 1 + sovNetcap(uint64(m.LSType))
	}
	if m.LinkStateID != 0 {
		n += 1 + sovNetcap(uint64(m.LinkStateID))
	}
	if m.AdvRouter != 0 {
		n += 1 + sovNetcap(uint64(m.AdvRouter))
	}
	if m.LSSeqNumber != 0 {
		n += 1 + sovNetcap(uint64(m.LSSeqNumber))
	}
	if m.LSChecksum != 0 {
		n += 1 + sovNetcap(uint64(m.LSChecksum))
	}
	if m.Length != 0 {
		n += 1 + sovNetcap(uint64(m.Length))
	}
	if m.LSOptions != 0 {
		n += 1 + sovNetcap(uint64(m.LSOptions))
	}
	return n
}

func (m *LSA) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.RLSAV2 != nil {
		l = m.RLSAV2.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.ASELSAV2 != nil {
		l = m.ASELSAV2.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.RLSA != nil {
		l = m.RLSA.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.NLSA != nil {
		l = m.NLSA.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.InterAPrefixLSA != nil {
		l = m.InterAPrefixLSA.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.IARouterLSA != nil {
		l = m.IARouterLSA.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.ASELSA != nil {
		l = m.ASELSA.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.LLSA != nil {
		l = m.LLSA.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.IntraAPrefixLSA != nil {
		l = m.IntraAPrefixLSA.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *LSReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LSType != 0 {
		n += 1 + sovNetcap(uint64(m.LSType))
	}
	if m.LSID != 0 {
		n += 1 + sovNetcap(uint64(m.LSID))
	}
	if m.AdvRouter != 0 {
		n += 1 + sovNetcap(uint64(m.AdvRouter))
	}
	return n
}

func (m *LSUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NumOfLSAs != 0 {
		n += 1 + sovNetcap(uint64(m.NumOfLSAs))
	}
	if len(m.LSAs) > 0 {
		for _, e := range m.LSAs {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *IntraAreaPrefixLSA) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NumOfPrefixes != 0 {
		n += 1 + sovNetcap(uint64(m.NumOfPrefixes))
	}
	if m.RefLSType != 0 {
		n += 1 + sovNetcap(uint64(m.RefLSType))
	}
	if m.RefLinkStateID != 0 {
		n += 1 + sovNetcap(uint64(m.RefLinkStateID))
	}
	if m.RefAdvRouter != 0 {
		n += 1 + sovNetcap(uint64(m.RefAdvRouter))
	}
	if len(m.Prefixes) > 0 {
		for _, e := range m.Prefixes {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *ASExternalLSA) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Flags != 0 {
		n += 1 + sovNetcap(uint64(m.Flags))
	}
	if m.Metric != 0 {
		n += 1 + sovNetcap(uint64(m.Metric))
	}
	if m.PrefixLength != 0 {
		n += 1 + sovNetcap(uint64(m.PrefixLength))
	}
	if m.PrefixOptions != 0 {
		n += 1 + sovNetcap(uint64(m.PrefixOptions))
	}
	if m.RefLSType != 0 {
		n += 1 + sovNetcap(uint64(m.RefLSType))
	}
	l = len(m.AddressPrefix)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.ForwardingAddress)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.ExternalRouteTag != 0 {
		n += 1 + sovNetcap(uint64(m.ExternalRouteTag))
	}
	if m.RefLinkStateID != 0 {
		n += 1 + sovNetcap(uint64(m.RefLinkStateID))
	}
	return n
}

func (m *InterAreaPrefixLSA) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metric != 0 {
		n += 1 + sovNetcap(uint64(m.Metric))
	}
	if m.PrefixLength != 0 {
		n += 1 + sovNetcap(uint64(m.PrefixLength))
	}
	if m.PrefixOptions != 0 {
		n += 1 + sovNetcap(uint64(m.PrefixOptions))
	}
	l = len(m.AddressPrefix)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *InterAreaRouterLSA) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Options != 0 {
		n += 1 + sovNetcap(uint64(m.Options))
	}
	if m.Metric != 0 {
		n += 1 + sovNetcap(uint64(m.Metric))
	}
	if m.DestinationRouterID != 0 {
		n += 1 + sovNetcap(uint64(m.DestinationRouterID))
	}
	return n
}

func (m *ASExternalLSAV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NetworkMask != 0 {
		n += 1 + sovNetcap(uint64(m.NetworkMask))
	}
	if m.ExternalBit != 0 {
		n += 1 + sovNetcap(uint64(m.ExternalBit))
	}
	if m.Metric != 0 {
		n += 1 + sovNetcap(uint64(m.Metric))
	}
	if m.ForwardingAddress != 0 {
		n += 1 + sovNetcap(uint64(m.ForwardingAddress))
	}
	if m.ExternalRouteTag != 0 {
		n += 1 + sovNetcap(uint64(m.ExternalRouteTag))
	}
	return n
}

func (m *RouterLSA) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Flags != 0 {
		n += 1 + sovNetcap(uint64(m.Flags))
	}
	if m.Options != 0 {
		n += 1 + sovNetcap(uint64(m.Options))
	}
	if len(m.Routers) > 0 {
		for _, e := range m.Routers {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *Router) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	if m.Metric != 0 {
		n += 1 + sovNetcap(uint64(m.Metric))
	}
	if m.InterfaceID != 0 {
		n += 1 + sovNetcap(uint64(m.InterfaceID))
	}
	if m.NeighborInterfaceID != 0 {
		n += 1 + sovNetcap(uint64(m.NeighborInterfaceID))
	}
	if m.NeighborRouterID != 0 {
		n += 1 + sovNetcap(uint64(m.NeighborRouterID))
	}
	return n
}

func (m *RouterLSAV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Flags != 0 {
		n += 1 + sovNetcap(uint64(m.Flags))
	}
	if m.Links != 0 {
		n += 1 + sovNetcap(uint64(m.Links))
	}
	if len(m.Routers) > 0 {
		for _, e := range m.Routers {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *RouterV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	if m.LinkID != 0 {
		n += 1 + sovNetcap(uint64(m.LinkID))
	}
	if m.LinkData != 0 {
		n += 1 + sovNetcap(uint64(m.LinkData))
	}
	if m.Metric != 0 {
		n += 1 + sovNetcap(uint64(m.Metric))
	}
	return n
}

func (m *NetworkLSA) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Options != 0 {
		n += 1 + sovNetcap(uint64(m.Options))
	}
	if len(m.AttachedRouter) > 0 {
		l = 0
		for _, e := range m.AttachedRouter {
			l += sovNetcap(uint64(e))
		}
		n += 1 + sovNetcap(uint64(l)) + l
	}
	return n
}

func (m *LinkLSA) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RtrPriority != 0 {
		n += 1 + sovNetcap(uint64(m.RtrPriority))
	}
	if m.Options != 0 {
		n += 1 + sovNetcap(uint64(m.Options))
	}
	l = len(m.LinkLocalAddress)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.NumOfPrefixes != 0 {
		n += 1 + sovNetcap(uint64(m.NumOfPrefixes))
	}
	if len(m.Prefixes) > 0 {
		for _, e := range m.Prefixes {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *LSAPrefix) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrefixLength != 0 {
		n += 1 + sovNetcap(uint64(m.PrefixLength))
	}
	if m.PrefixOptions != 0 {
		n += 1 + sovNetcap(uint64(m.PrefixOptions))
	}
	if m.Metric != 0 {
		n += 1 + sovNetcap(uint64(m.Metric))
	}
	l = len(m.AddressPrefix)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *BFD) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.Version != 0 {
		n += 1 + sovNetcap(uint64(m.Version))
	}
	if m.Diagnostic != 0 {
		n += 1 + sovNetcap(uint64(m.Diagnostic))
	}
	if m.State != 0 {
		n += 1 + sovNetcap(uint64(m.State))
	}
	if m.Poll {
		n += 2
	}
	if m.Final {
		n += 2
	}
	if m.ControlPlaneIndependent {
		n += 2
	}
	if m.AuthPresent {
		n += 2
	}
	if m.Demand {
		n += 2
	}
	if m.Multipoint {
		n += 2
	}
	if m.DetectMultiplier != 0 {
		n += 1 + sovNetcap(uint64(m.DetectMultiplier))
	}
	if m.MyDiscriminator != 0 {
		n += 1 + sovNetcap(uint64(m.MyDiscriminator))
	}
	if m.YourDiscriminator != 0 {
		n += 1 + sovNetcap(uint64(m.YourDiscriminator))
	}
	if m.DesiredMinTxInterval != 0 {
		n += 1 + sovNetcap(uint64(m.DesiredMinTxInterval))
	}
	if m.RequiredMinRxInterval != 0 {
		n += 1 + sovNetcap(uint64(m.RequiredMinRxInterval))
	}
	if m.RequiredMinEchoRxInterval != 0 {
		n += 2 + sovNetcap(uint64(m.RequiredMinEchoRxInterval))
	}
	if m.AuthHeader != nil {
		l = m.AuthHeader.Size()
		n += 2 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *BFDAuthHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuthType != 0 {
		n += 1 + sovNetcap(uint64(m.AuthType))
	}
	if m.KeyID != 0 {
		n += 1 + sovNetcap(uint64(m.KeyID))
	}
	if m.SequenceNumber != 0 {
		n += 1 + sovNetcap(uint64(m.SequenceNumber))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *GRE) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.ChecksumPresent {
		n += 2
	}
	if m.RoutingPresent {
		n += 2
	}
	if m.KeyPresent {
		n += 2
	}
	if m.SeqPresent {
		n += 2
	}
	if m.StrictSourceRoute {
		n += 2
	}
	if m.AckPresent {
		n += 2
	}
	if m.RecursionControl != 0 {
		n += 1 + sovNetcap(uint64(m.RecursionControl))
	}
	if m.Flags != 0 {
		n += 1 + sovNetcap(uint64(m.Flags))
	}
	if m.Version != 0 {
		n += 1 + sovNetcap(uint64(m.Version))
	}
	if m.Protocol != 0 {
		n += 1 + sovNetcap(uint64(m.Protocol))
	}
	if m.Checksum != 0 {
		n += 1 + sovNetcap(uint64(m.Checksum))
	}
	if m.Offset != 0 {
		n += 1 + sovNetcap(uint64(m.Offset))
	}
	if m.Key != 0 {
		n += 1 + sovNetcap(uint64(m.Key))
	}
	if m.Seq != 0 {
		n += 1 + sovNetcap(uint64(m.Seq))
	}
	if m.Ack != 0 {
		n += 2 + sovNetcap(uint64(m.Ack))
	}
	if m.Routing != nil {
		l = m.Routing.Size()
		n += 2 + l + sovNetcap(uint64(l))
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *GRERouting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddressFamily != 0 {
		n += 1 + sovNetcap(uint64(m.AddressFamily))
	}
	if m.SREOffset != 0 {
		n += 1 + sovNetcap(uint64(m.SREOffset))
	}
	if m.SRELength != 0 {
		n += 1 + sovNetcap(uint64(m.SRELength))
	}
	l = len(m.RoutingInformation)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Next != nil {
		l = m.Next.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *FDDI) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.FrameControl != 0 {
		n += 1 + sovNetcap(uint64(m.FrameControl))
	}
	if m.Priority != 0 {
		n += 1 + sovNetcap(uint64(m.Priority))
	}
	l = len(m.SrcMAC)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstMAC)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *EAP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.Code != 0 {
		n += 1 + sovNetcap(uint64(m.Code))
	}
	if m.Id != 0 {
		n += 1 + sovNetcap(uint64(m.Id))
	}
	if m.Length != 0 {
		n += 1 + sovNetcap(uint64(m.Length))
	}
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	l = len(m.TypeData)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *EAPOL) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.Version != 0 {
		n += 1 + sovNetcap(uint64(m.Version))
	}
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	if m.Length != 0 {
		n += 1 + sovNetcap(uint64(m.Length))
	}
	return n
}

func (m *EAPOLKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.KeyDescriptorType != 0 {
		n += 1 + sovNetcap(uint64(m.KeyDescriptorType))
	}
	if m.KeyDescriptorVersion != 0 {
		n += 1 + sovNetcap(uint64(m.KeyDescriptorVersion))
	}
	if m.KeyType != 0 {
		n += 1 + sovNetcap(uint64(m.KeyType))
	}
	if m.KeyIndex != 0 {
		n += 1 + sovNetcap(uint64(m.KeyIndex))
	}
	if m.Install {
		n += 2
	}
	if m.KeyACK {
		n += 2
	}
	if m.KeyMIC {
		n += 2
	}
	if m.Secure {
		n += 2
	}
	if m.MICError {
		n += 2
	}
	if m.Request {
		n += 2
	}
	if m.HasEncryptedKeyData {
		n += 2
	}
	if m.SMKMessage {
		n += 2
	}
	if m.KeyLength != 0 {
		n += 1 + sovNetcap(uint64(m.KeyLength))
	}
	if m.ReplayCounter != 0 {
		n += 1 + sovNetcap(uint64(m.ReplayCounter))
	}
	l = len(m.Nonce)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	l = len(m.IV)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	if m.RSC != 0 {
		n += 2 + sovNetcap(uint64(m.RSC))
	}
	if m.ID != 0 {
		n += 2 + sovNetcap(uint64(m.ID))
	}
	l = len(m.MIC)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	if m.KeyDataLength != 0 {
		n += 2 + sovNetcap(uint64(m.KeyDataLength))
	}
	l = len(m.EncryptedKeyData)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *VRRPv2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.Version != 0 {
		n += 1 + sovNetcap(uint64(m.Version))
	}
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	if m.VirtualRtrID != 0 {
		n += 1 + sovNetcap(uint64(m.VirtualRtrID))
	}
	if m.Priority != 0 {
		n += 1 + sovNetcap(uint64(m.Priority))
	}
	if m.CountIPAddr != 0 {
		n += 1 + sovNetcap(uint64(m.CountIPAddr))
	}
	if m.AuthType != 0 {
		n += 1 + sovNetcap(uint64(m.AuthType))
	}
	if m.AdverInt != 0 {
		n += 1 + sovNetcap(uint64(m.AdverInt))
	}
	if m.Checksum != 0 {
		n += 1 + sovNetcap(uint64(m.Checksum))
	}
	if len(m.IPAddress) > 0 {
		for _, s := range m.IPAddress {
			l = len(s)
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *CiscoDiscovery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.Version != 0 {
		n += 1 + sovNetcap(uint64(m.Version))
	}
	if m.TTL != 0 {
		n += 1 + sovNetcap(uint64(m.TTL))
	}
	if m.Checksum != 0 {
		n += 1 + sovNetcap(uint64(m.Checksum))
	}
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *CiscoDiscoveryValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	if m.Length != 0 {
		n += 1 + sovNetcap(uint64(m.Length))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *CDPVLANDialogue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovNetcap(uint64(m.ID))
	}
	if m.VLAN != 0 {
		n += 1 + sovNetcap(uint64(m.VLAN))
	}
	return n
}

func (m *CDPLocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovNetcap(uint64(m.Type))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *CDPPowerDialogue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovNetcap(uint64(m.ID))
	}
	if m.MgmtID != 0 {
		n += 1 + sovNetcap(uint64(m.MgmtID))
	}
	if len(m.Values) > 0 {
		l = 0
		for _, e := range m.Values {
			l += sovNetcap(uint64(e))
		}
		n += 1 + sovNetcap(uint64(l)) + l
	}
	return n
}

func (m *CDPSparePairPoE) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PSEFourWire {
		n += 2
	}
	if m.PDArchShared {
		n += 2
	}
	if m.PDRequestOn {
		n += 2
	}
	if m.PSEOn {
		n += 2
	}
	return n
}

func (m *CiscoDiscoveryInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.CDPHello != nil {
		l = m.CDPHello.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DeviceID)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.Addresses) > 0 {
		for _, s := range m.Addresses {
			l = len(s)
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	l = len(m.PortID)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Capabilities != nil {
		l = m.Capabilities.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.IPPrefixes) > 0 {
		for _, e := range m.IPPrefixes {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	l = len(m.VTPDomain)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.NativeVLAN != 0 {
		n += 1 + sovNetcap(uint64(m.NativeVLAN))
	}
	if m.FullDuplex {
		n += 2
	}
	if m.VLANReply != nil {
		l = m.VLANReply.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.VLANQuery != nil {
		l = m.VLANQuery.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.PowerConsumption != 0 {
		n += 1 + sovNetcap(uint64(m.PowerConsumption))
	}
	if m.MTU != 0 {
		n += 2 + sovNetcap(uint64(m.MTU))
	}
	if m.ExtendedTrust != 0 {
		n += 2 + sovNetcap(uint64(m.ExtendedTrust))
	}
	if m.UntrustedCOS != 0 {
		n += 2 + sovNetcap(uint64(m.UntrustedCOS))
	}
	l = len(m.SysName)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	l = len(m.SysOID)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	if len(m.MgmtAddresses) > 0 {
		for _, s := range m.MgmtAddresses {
			l = len(s)
			n += 2 + l + sovNetcap(uint64(l))
		}
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 2 + l + sovNetcap(uint64(l))
	}
	if m.PowerRequest != nil {
		l = m.PowerRequest.Size()
		n += 2 + l + sovNetcap(uint64(l))
	}
	if m.PowerAvailable != nil {
		l = m.PowerAvailable.Size()
		n += 2 + l + sovNetcap(uint64(l))
	}
	if m.SparePairPoe != nil {
		l = m.SparePairPoe.Size()
		n += 2 + l + sovNetcap(uint64(l))
	}
	if m.EnergyWise != nil {
		l = m.EnergyWise.Size()
		n += 2 + l + sovNetcap(uint64(l))
	}
	if len(m.Unknown) > 0 {
		for _, e := range m.Unknown {
			l = e.Size()
			n += 2 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *CDPHello) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OUI)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.ProtocolID != 0 {
		n += 1 + sovNetcap(uint64(m.ProtocolID))
	}
	l = len(m.ClusterMaster)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Unknown1)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovNetcap(uint64(m.Version))
	}
	if m.SubVersion != 0 {
		n += 1 + sovNetcap(uint64(m.SubVersion))
	}
	if m.Status != 0 {
		n += 1 + sovNetcap(uint64(m.Status))
	}
	if m.Unknown2 != 0 {
		n += 1 + sovNetcap(uint64(m.Unknown2))
	}
	l = len(m.ClusterCommander)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SwitchMAC)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Unknown3 != 0 {
		n += 1 + sovNetcap(uint64(m.Unknown3))
	}
	if m.ManagementVLAN != 0 {
		n += 1 + sovNetcap(uint64(m.ManagementVLAN))
	}
	return n
}

func (m *CDPEnergyWise) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EncryptedData)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Unknown1 != 0 {
		n += 1 + sovNetcap(uint64(m.Unknown1))
	}
	if m.SequenceNumber != 0 {
		n += 1 + sovNetcap(uint64(m.SequenceNumber))
	}
	l = len(m.ModelNumber)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Unknown2 != 0 {
		n += 1 + sovNetcap(uint64(m.Unknown2))
	}
	l = len(m.HardwareID)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SerialNum)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Unknown3)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.ReplyUnknown1)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.ReplyPort)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.ReplyAddress)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.ReplyUnknown2)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.ReplyUnknown3)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *CDPCapabilities) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.L3Router {
		n += 2
	}
	if m.TBBridge {
		n += 2
	}
	if m.SPBridge {
		n += 2
	}
	if m.L2Switch {
		n += 2
	}
	if m.IsHost {
		n += 2
	}
	if m.IGMPFilter {
		n += 2
	}
	if m.L1Repeater {
		n += 2
	}
	if m.IsPhone {
		n += 2
	}
	if m.RemotelyManaged {
		n += 2
	}
	return n
}

func (m *IPNet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.IPMask)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *NortelDiscovery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	l = len(m.IPAddress)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SegmentID)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Chassis != 0 {
		n += 1 + sovNetcap(uint64(m.Chassis))
	}
	if m.Backplane != 0 {
		n += 1 + sovNetcap(uint64(m.Backplane))
	}
	if m.State != 0 {
		n += 1 + sovNetcap(uint64(m.State))
	}
	if m.NumLinks != 0 {
		n += 1 + sovNetcap(uint64(m.NumLinks))
	}
	l = len(m.SrcMac)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstMac)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *CIP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.Response {
		n += 2
	}
	if m.ServiceID != 0 {
		n += 1 + sovNetcap(uint64(m.ServiceID))
	}
	if m.ClassID != 0 {
		n += 1 + sovNetcap(uint64(m.ClassID))
	}
	if m.InstanceID != 0 {
		n += 1 + sovNetcap(uint64(m.InstanceID))
	}
	if m.Status != 0 {
		n += 1 + sovNetcap(uint64(m.Status))
	}
	if len(m.AdditionalStatus) > 0 {
		l = 0
		for _, e := range m.AdditionalStatus {
			l += sovNetcap(uint64(e))
		}
		n += 1 + sovNetcap(uint64(l)) + l
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.SrcPort != 0 {
		n += 1 + sovNetcap(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 1 + sovNetcap(uint64(m.DstPort))
	}
	return n
}

func (m *ENIP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.Command != 0 {
		n += 1 + sovNetcap(uint64(m.Command))
	}
	if m.Length != 0 {
		n += 1 + sovNetcap(uint64(m.Length))
	}
	if m.SessionHandle != 0 {
		n += 1 + sovNetcap(uint64(m.SessionHandle))
	}
	if m.Status != 0 {
		n += 1 + sovNetcap(uint64(m.Status))
	}
	l = len(m.SenderContext)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Options != 0 {
		n += 1 + sovNetcap(uint64(m.Options))
	}
	if m.CommandSpecific != nil {
		l = m.CommandSpecific.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.SrcPort != 0 {
		n += 1 + sovNetcap(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 1 + sovNetcap(uint64(m.DstPort))
	}
	return n
}

func (m *ENIPCommandSpecificData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cmd != 0 {
		n += 1 + sovNetcap(uint64(m.Cmd))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *DeviceProfile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MacAddr)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DeviceManufacturer)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.DeviceIPs) > 0 {
		for _, s := range m.DeviceIPs {
			l = len(s)
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	if len(m.Contacts) > 0 {
		for _, s := range m.Contacts {
			l = len(s)
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	if m.NumPackets != 0 {
		n += 1 + sovNetcap(uint64(m.NumPackets))
	}
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.Bytes != 0 {
		n += 1 + sovNetcap(uint64(m.Bytes))
	}
	return n
}

func (m *Port) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PortNumber != 0 {
		n += 1 + sovNetcap(uint64(m.PortNumber))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *PortStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Packets != 0 {
		n += 1 + sovNetcap(uint64(m.Packets))
	}
	if m.Bytes != 0 {
		n += 1 + sovNetcap(uint64(m.Bytes))
	}
	return n
}

func (m *IPProfile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.NumPackets != 0 {
		n += 1 + sovNetcap(uint64(m.NumPackets))
	}
	l = len(m.Geolocation)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.DNSNames) > 0 {
		for _, s := range m.DNSNames {
			l = len(s)
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	if m.TimestampFirst != 0 {
		n += 1 + sovNetcap(uint64(m.TimestampFirst))
	}
	if m.TimestampLast != 0 {
		n += 1 + sovNetcap(uint64(m.TimestampLast))
	}
	if len(m.Applications) > 0 {
		for _, s := range m.Applications {
			l = len(s)
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	if len(m.Ja3Hashes) > 0 {
		for k, v := range m.Ja3Hashes {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovNetcap(uint64(len(k))) + 1 + len(v) + sovNetcap(uint64(len(v)))
			n += mapEntrySize + 1 + sovNetcap(uint64(mapEntrySize))
		}
	}
	if len(m.Protocols) > 0 {
		for k, v := range m.Protocols {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovNetcap(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovNetcap(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovNetcap(uint64(mapEntrySize))
		}
	}
	if m.Bytes != 0 {
		n += 1 + sovNetcap(uint64(m.Bytes))
	}
	if len(m.SNIs) > 0 {
		for k, v := range m.SNIs {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovNetcap(uint64(len(k))) + 1 + sovNetcap(uint64(v))
			n += mapEntrySize + 1 + sovNetcap(uint64(mapEntrySize))
		}
	}
	if len(m.SrcPorts) > 0 {
		for _, e := range m.SrcPorts {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	if len(m.DstPorts) > 0 {
		for _, e := range m.DstPorts {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	if len(m.ContactedPorts) > 0 {
		for _, e := range m.ContactedPorts {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *Protocol) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Packets != 0 {
		n += 1 + sovNetcap(uint64(m.Packets))
	}
	l = len(m.Category)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *File) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Length != 0 {
		n += 1 + sovNetcap(uint64(m.Length))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Ident)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.ContentTypeDetected)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.SrcPort != 0 {
		n += 1 + sovNetcap(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 1 + sovNetcap(uint64(m.DstPort))
	}
	return n
}

func (m *SMTPResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResponseCode != 0 {
		n += 1 + sovNetcap(uint64(m.ResponseCode))
	}
	l = len(m.Parameter)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *SMTPRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Command)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Argument)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *SMTPCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Command != 0 {
		n += 1 + sovNetcap(uint64(m.Command))
	}
	l = len(m.Parameter)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *SMTP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.IsEncrypted {
		n += 2
	}
	if m.IsResponse {
		n += 2
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.SrcPort != 0 {
		n += 1 + sovNetcap(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 1 + sovNetcap(uint64(m.DstPort))
	}
	if len(m.MailIDs) > 0 {
		for _, s := range m.MailIDs {
			l = len(s)
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	if len(m.Commands) > 0 {
		for _, s := range m.Commands {
			l = len(s)
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *Diameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	if m.Version != 0 {
		n += 1 + sovNetcap(uint64(m.Version))
	}
	if m.Flags != 0 {
		n += 1 + sovNetcap(uint64(m.Flags))
	}
	if m.MessageLen != 0 {
		n += 1 + sovNetcap(uint64(m.MessageLen))
	}
	if m.CommandCode != 0 {
		n += 1 + sovNetcap(uint64(m.CommandCode))
	}
	if m.ApplicationID != 0 {
		n += 1 + sovNetcap(uint64(m.ApplicationID))
	}
	if m.HopByHopID != 0 {
		n += 1 + sovNetcap(uint64(m.HopByHopID))
	}
	if m.EndToEndID != 0 {
		n += 1 + sovNetcap(uint64(m.EndToEndID))
	}
	if len(m.AVPs) > 0 {
		for _, e := range m.AVPs {
			l = e.Size()
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.SrcPort != 0 {
		n += 1 + sovNetcap(uint64(m.SrcPort))
	}
	if m.DstPort != 0 {
		n += 1 + sovNetcap(uint64(m.DstPort))
	}
	return n
}

func (m *AVP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AttributeCode != 0 {
		n += 1 + sovNetcap(uint64(m.AttributeCode))
	}
	l = len(m.AttributeName)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.AttributeFormat)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Flags != 0 {
		n += 1 + sovNetcap(uint64(m.Flags))
	}
	if m.HeaderLen != 0 {
		n += 1 + sovNetcap(uint64(m.HeaderLen))
	}
	if m.Len != 0 {
		n += 1 + sovNetcap(uint64(m.Len))
	}
	if m.VendorCode != 0 {
		n += 1 + sovNetcap(uint64(m.VendorCode))
	}
	l = len(m.VendorName)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.VendorID)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DecodedValue)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Padding != 0 {
		n += 1 + sovNetcap(uint64(m.Padding))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.ValueLen != 0 {
		n += 1 + sovNetcap(uint64(m.ValueLen))
	}
	return n
}

func (m *POP3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	l = len(m.ClientIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.ServerIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.AuthToken)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Pass)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.MailIDs) > 0 {
		for _, s := range m.MailIDs {
			l = len(s)
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	if len(m.Commands) > 0 {
		for _, s := range m.Commands {
			l = len(s)
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	return n
}

func (m *Mail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	l = len(m.ReturnPath)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.CC)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Subject)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Date)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.MessageID)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.References)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.InReplyTo)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.ContentLanguage)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.HasAttachments {
		n += 2
	}
	l = len(m.XOriginatingIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.EnvelopeTo)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.Body) > 0 {
		for _, e := range m.Body {
			l = e.Size()
			n += 2 + l + sovNetcap(uint64(l))
		}
	}
	l = len(m.ClientIP)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	l = len(m.ServerIP)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	l = len(m.DeliveryDate)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	l = len(m.Origin)
	if l > 0 {
		n += 2 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *MailPart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.Header) > 0 {
		for k, v := range m.Header {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovNetcap(uint64(len(k))) + 1 + len(v) + sovNetcap(uint64(len(v)))
			n += mapEntrySize + 1 + sovNetcap(uint64(mapEntrySize))
		}
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Filename)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *POP3Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Command)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Argument)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *POP3Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Command)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *Software) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	l = len(m.Product)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Vendor)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.DeviceProfiles) > 0 {
		for _, s := range m.DeviceProfiles {
			l = len(s)
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	l = len(m.SourceName)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.DPIResults) > 0 {
		for _, s := range m.DPIResults {
			l = len(s)
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	l = len(m.Service)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.Flows) > 0 {
		for _, s := range m.Flows {
			l = len(s)
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	l = len(m.SourceData)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Notes)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Website)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.OS)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *Service) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	l = len(m.IP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovNetcap(uint64(m.Port))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Banner)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.Flows) > 0 {
		for _, s := range m.Flows {
			l = len(s)
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	l = len(m.Product)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Vendor)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Notes)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.BytesServer != 0 {
		n += 1 + sovNetcap(uint64(m.BytesServer))
	}
	if m.BytesClient != 0 {
		n += 1 + sovNetcap(uint64(m.BytesClient))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.OS)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *Credentials) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	l = len(m.Service)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Flow)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Notes)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *SSH) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	l = len(m.HASSH)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Flow)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Notes)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Ident)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Algorithms)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.IsClient {
		n += 2
	}
	return n
}

func (m *Vulnerability) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Severity)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.V2Score)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.AccessVector)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if len(m.Versions) > 0 {
		for _, s := range m.Versions {
			l = len(s)
			n += 1 + l + sovNetcap(uint64(l))
		}
	}
	l = len(m.Notes)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Software != nil {
		l = m.Software.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *Exploit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.File)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Notes)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Date)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Author)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Typ)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Port)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	if m.Software != nil {
		l = m.Software.Size()
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func (m *Alert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNetcap(uint64(m.Timestamp))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SrcIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.SrcPort)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstIP)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.DstPort)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.MITRE)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.IPReputation)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	l = len(m.Notes)
	if l > 0 {
		n += 1 + l + sovNetcap(uint64(l))
	}
	return n
}

func sovNetcap(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNetcap(x uint64) (n int) {
	return sovNetcap(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			m.Created = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Created |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputSource = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainsPayloads", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ContainsPayloads = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Batch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Batch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Batch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageType", wireType)
			}
			m.MessageType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageType |= Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
			m.TotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainsPayloads", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ContainsPayloads = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PacketContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PacketContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PacketContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Connection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Connection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Connection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampFirst", wireType)
			}
			m.TimestampFirst = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampFirst |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkProto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinkProto = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkProto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkProto = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransportProto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransportProto = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationProto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApplicationProto = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcMAC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcMAC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstMAC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstMAC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcPort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstPort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
			m.TotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppPayloadSize", wireType)
			}
			m.AppPayloadSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppPayloadSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumPackets", wireType)
			}
			m.NumPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumPackets |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampLast", wireType)
			}
			m.TimestampLast = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampLast |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesServerToClient", wireType)
			}
			m.BytesServerToClient = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesServerToClient |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesClientToServer", wireType)
			}
			m.BytesClientToServer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesClientToServer |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumFINFlags", wireType)
			}
			m.NumFINFlags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumFINFlags |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRSTFlags", wireType)
			}
			m.NumRSTFlags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumRSTFlags |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumACKFlags", wireType)
			}
			m.NumACKFlags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumACKFlags |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumSYNFlags", wireType)
			}
			m.NumSYNFlags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumSYNFlags |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumURGFlags", wireType)
			}
			m.NumURGFlags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumURGFlags |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumECEFlags", wireType)
			}
			m.NumECEFlags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumECEFlags |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumPSHFlags", wireType)
			}
			m.NumPSHFlags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumPSHFlags |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumCWRFlags", wireType)
			}
			m.NumCWRFlags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumCWRFlags |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumNSFlags", wireType)
			}
			m.NumNSFlags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumNSFlags |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeanWindowSize", wireType)
			}
			m.MeanWindowSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MeanWindowSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ethernet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ethernet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ethernet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcMAC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcMAC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstMAC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstMAC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthernetType", wireType)
			}
			m.EthernetType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EthernetType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadEntropy", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PayloadEntropy = float64(math.Float64frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadSize", wireType)
			}
			m.PayloadSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayloadSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ARP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ARP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ARP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddrType", wireType)
			}
			m.AddrType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddrType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwAddressSize", wireType)
			}
			m.HwAddressSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HwAddressSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolAddressSize", wireType)
			}
			m.ProtocolAddressSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtocolAddressSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			m.Operation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operation |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcHwAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcHwAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcProtocolAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcProtocolAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstHwAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstHwAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstProtocolAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstProtocolAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dot1Q) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dot1Q: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dot1Q: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropEligible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropEligible = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VLANIdentifier", wireType)
			}
			m.VLANIdentifier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VLANIdentifier |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dot11) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dot11: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dot11: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proto", wireType)
			}
			m.Proto = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Proto |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationID", wireType)
			}
			m.DurationID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DurationID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address1 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address2 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address3", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address3 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address4 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FragmentNumber", wireType)
			}
			m.FragmentNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FragmentNumber |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			m.Checksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Checksum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QOS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QOS == nil {
				m.QOS = &Dot11QOS{}
			}
			if err := m.QOS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HTControl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HTControl == nil {
				m.HTControl = &Dot11HTControl{}
			}
			if err := m.HTControl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dot11QOS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dot11QOS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dot11QOS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TID", wireType)
			}
			m.TID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EOSP", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EOSP = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AckPolicy", wireType)
			}
			m.AckPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AckPolicy |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TXOP", wireType)
			}
			m.TXOP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TXOP |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dot11HTControl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dot11HTControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dot11HTControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ACConstraint", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ACConstraint = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RDGMorePPDU", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RDGMorePPDU = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VHT", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VHT == nil {
				m.VHT = &Dot11HTControlVHT{}
			}
			if err := m.VHT.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HT", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HT == nil {
				m.HT = &Dot11HTControlHT{}
			}
			if err := m.HT.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dot11HTControlVHT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dot11HTControlVHT: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dot11HTControlVHT: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MRQ", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MRQ = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnsolicitedMFB", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UnsolicitedMFB = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MSI", wireType)
			}
			m.MSI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MSI |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MFB", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MFB == nil {
				m.MFB = &Dot11HTControlMFB{}
			}
			if err := m.MFB.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressedMSI", wireType)
			}
			m.CompressedMSI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompressedMSI |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field STBCIndication", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.STBCIndication = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MFSI", wireType)
			}
			m.MFSI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MFSI |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GID", wireType)
			}
			m.GID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodingType", wireType)
			}
			m.CodingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CodingType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FbTXBeamformed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FbTXBeamformed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dot11HTControlHT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dot11HTControlHT: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dot11HTControlHT: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkAdapationControl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LinkAdapationControl == nil {
				m.LinkAdapationControl = &Dot11LinkAdapationControl{}
			}
			if err := m.LinkAdapationControl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CalibrationPosition", wireType)
			}
			m.CalibrationPosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CalibrationPosition |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CalibrationSequence", wireType)
			}
			m.CalibrationSequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CalibrationSequence |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CSISteering", wireType)
			}
			m.CSISteering = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CSISteering |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NDPAnnouncement", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NDPAnnouncement = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DEI", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DEI = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dot11HTControlMFB) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dot11HTControlMFB: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dot11HTControlMFB: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumSTS", wireType)
			}
			m.NumSTS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumSTS |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VHTMCS", wireType)
			}
			m.VHTMCS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VHTMCS |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BW", wireType)
			}
			m.BW = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BW |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SNR", wireType)
			}
			m.SNR = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SNR |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dot11LinkAdapationControl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dot11LinkAdapationControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dot11LinkAdapationControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TRQ", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TRQ = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MRQ", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MRQ = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MSI", wireType)
			}
			m.MSI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MSI |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MFSI", wireType)
			}
			m.MFSI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MFSI |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ASEL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ASEL == nil {
				m.ASEL = &Dot11ASEL{}
			}
			if err := m.ASEL.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MFB", wireType)
			}
			m.MFB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MFB |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dot11ASEL) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dot11ASEL: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dot11ASEL: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			m.Command = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Command |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			m.Data = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Data |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinkLayerDiscovery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinkLayerDiscovery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinkLayerDiscovery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChassisID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChassisID == nil {
				m.ChassisID = &LLDPChassisID{}
			}
			if err := m.ChassisID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortID == nil {
				m.PortID = &LLDPPortID{}
			}
			if err := m.PortID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			m.TTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTL |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &LinkLayerDiscoveryValue{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LLDPChassisID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LLDPChassisID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LLDPChassisID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subtype", wireType)
			}
			m.Subtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Subtype |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LLDPPortID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LLDPPortID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LLDPPortID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subtype", wireType)
			}
			m.Subtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Subtype |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinkLayerDiscoveryValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinkLayerDiscoveryValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinkLayerDiscoveryValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EthernetCTP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EthernetCTP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EthernetCTP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipCount", wireType)
			}
			m.SkipCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkipCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EthernetCTPReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EthernetCTPReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EthernetCTPReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Function", wireType)
			}
			m.Function = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Function |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiptNumber", wireType)
			}
			m.ReceiptNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReceiptNumber |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinkLayerDiscoveryInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinkLayerDiscoveryInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinkLayerDiscoveryInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SysName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SysName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SysDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SysDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SysCapabilities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SysCapabilities == nil {
				m.SysCapabilities = &LLDPSysCapabilities{}
			}
			if err := m.SysCapabilities.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MgmtAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MgmtAddress == nil {
				m.MgmtAddress = &LLDPMgmtAddress{}
			}
			if err := m.MgmtAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgTLVs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrgTLVs = append(m.OrgTLVs, &LLDPOrgSpecificTLV{})
			if err := m.OrgTLVs[len(m.OrgTLVs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unknown", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unknown = append(m.Unknown, &LinkLayerDiscoveryValue{})
			if err := m.Unknown[len(m.Unknown)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LLDPSysCapabilities) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LLDPSysCapabilities: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LLDPSysCapabilities: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemCap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SystemCap == nil {
				m.SystemCap = &LLDPCapabilities{}
			}
			if err := m.SystemCap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnabledCap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnabledCap == nil {
				m.EnabledCap = &LLDPCapabilities{}
			}
			if err := m.EnabledCap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LLDPCapabilities) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LLDPCapabilities: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LLDPCapabilities: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Other", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Other = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repeater", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Repeater = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bridge", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Bridge = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WLANAP", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WLANAP = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Router", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Router = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Phone = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocSis", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DocSis = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StationOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StationOnly = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CVLAN", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CVLAN = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SVLAN", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SVLAN = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TMPR", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TMPR = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LLDPMgmtAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LLDPMgmtAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LLDPMgmtAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subtype", wireType)
			}
			m.Subtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Subtype |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceSubtype", wireType)
			}
			m.InterfaceSubtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterfaceSubtype |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceNumber", wireType)
			}
			m.InterfaceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterfaceNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LLDPOrgSpecificTLV) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LLDPOrgSpecificTLV: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LLDPOrgSpecificTLV: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OUI", wireType)
			}
			m.OUI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OUI |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubType", wireType)
			}
			m.SubType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = append(m.Info[:0], dAtA[iNdEx:postIndex]...)
			if m.Info == nil {
				m.Info = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPv4) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPv4: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPv4: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IHL", wireType)
			}
			m.IHL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IHL |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TOS", wireType)
			}
			m.TOS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TOS |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FragOffset", wireType)
			}
			m.FragOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FragOffset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			m.TTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTL |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			m.Checksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Checksum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Padding", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Padding = append(m.Padding[:0], dAtA[iNdEx:postIndex]...)
			if m.Padding == nil {
				m.Padding = []byte{}
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, &IPv4Option{})
			if err := m.Options[len(m.Options)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadEntropy", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PayloadEntropy = float64(math.Float64frombits(v))
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadSize", wireType)
			}
			m.PayloadSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayloadSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPv4Option) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPv4Option: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPv4Option: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionType", wireType)
			}
			m.OptionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionLength", wireType)
			}
			m.OptionLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionData = append(m.OptionData[:0], dAtA[iNdEx:postIndex]...)
			if m.OptionData == nil {
				m.OptionData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPv6) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPv6: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPv6: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficClass", wireType)
			}
			m.TrafficClass = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrafficClass |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowLabel", wireType)
			}
			m.FlowLabel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlowLabel |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextHeader", wireType)
			}
			m.NextHeader = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextHeader |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HopLimit", wireType)
			}
			m.HopLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HopLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadEntropy", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PayloadEntropy = float64(math.Float64frombits(v))
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadSize", wireType)
			}
			m.PayloadSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayloadSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HopByHop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HopByHop == nil {
				m.HopByHop = &IPv6HopByHop{}
			}
			if err := m.HopByHop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPv6Fragment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPv6Fragment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPv6Fragment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextHeader", wireType)
			}
			m.NextHeader = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextHeader |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved1", wireType)
			}
			m.Reserved1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reserved1 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FragmentOffset", wireType)
			}
			m.FragmentOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FragmentOffset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved2", wireType)
			}
			m.Reserved2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reserved2 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoreFragments", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MoreFragments = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identification", wireType)
			}
			m.Identification = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Identification |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ICMPv4) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPv4: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPv4: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeCode", wireType)
			}
			m.TypeCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			m.Checksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Checksum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ICMPv6) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPv6: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPv6: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeCode", wireType)
			}
			m.TypeCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			m.Checksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Checksum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ICMPv6NeighborAdvertisement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPv6NeighborAdvertisement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPv6NeighborAdvertisement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, &ICMPv6Option{})
			if err := m.Options[len(m.Options)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ICMPv6RouterAdvertisement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPv6RouterAdvertisement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPv6RouterAdvertisement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HopLimit", wireType)
			}
			m.HopLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HopLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouterLifetime", wireType)
			}
			m.RouterLifetime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouterLifetime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReachableTime", wireType)
			}
			m.ReachableTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReachableTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetransTimer", wireType)
			}
			m.RetransTimer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetransTimer |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, &ICMPv6Option{})
			if err := m.Options[len(m.Options)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ICMPv6Option) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPv6Option: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPv6Option: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UDP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UDP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UDP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			m.Checksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Checksum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadEntropy", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PayloadEntropy = float64(math.Float64frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadSize", wireType)
			}
			m.PayloadSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayloadSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TCP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TCP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TCP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNum", wireType)
			}
			m.SeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AckNum", wireType)
			}
			m.AckNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AckNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataOffset", wireType)
			}
			m.DataOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataOffset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FIN", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FIN = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SYN", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SYN = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RST", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RST = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PSH", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PSH = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ACK", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ACK = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field URG", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.URG = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ECE", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ECE = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CWR", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CWR = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NS", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NS = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Window", wireType)
			}
			m.Window = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Window |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			m.Checksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Checksum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Urgent", wireType)
			}
			m.Urgent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Urgent |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Padding", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Padding = append(m.Padding[:0], dAtA[iNdEx:postIndex]...)
			if m.Padding == nil {
				m.Padding = []byte{}
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, &TCPOption{})
			if err := m.Options[len(m.Options)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadEntropy", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PayloadEntropy = float64(math.Float64frombits(v))
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadSize", wireType)
			}
			m.PayloadSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayloadSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TCPOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TCPOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TCPOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionType", wireType)
			}
			m.OptionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionLength", wireType)
			}
			m.OptionLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionData = append(m.OptionData[:0], dAtA[iNdEx:postIndex]...)
			if m.OptionData == nil {
				m.OptionData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCTP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCTP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCTP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerificationTag", wireType)
			}
			m.VerificationTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerificationTag |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			m.Checksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Checksum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DNS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QR", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QR = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpCode", wireType)
			}
			m.OpCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AA", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AA = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TC", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TC = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RD", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RD = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RA", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RA = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
			m.Z = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Z |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseCode", wireType)
			}
			m.ResponseCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QDCount", wireType)
			}
			m.QDCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QDCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ANCount", wireType)
			}
			m.ANCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ANCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NSCount", wireType)
			}
			m.NSCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NSCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ARCount", wireType)
			}
			m.ARCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ARCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Questions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Questions = append(m.Questions, &DNSQuestion{})
			if err := m.Questions[len(m.Questions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Answers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Answers = append(m.Answers, &DNSResourceRecord{})
			if err := m.Answers[len(m.Answers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authorities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authorities = append(m.Authorities, &DNSResourceRecord{})
			if err := m.Authorities[len(m.Authorities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Additionals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Additionals = append(m.Additionals, &DNSResourceRecord{})
			if err := m.Additionals[len(m.Additionals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DNSResourceRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNSResourceRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNSResourceRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Class", wireType)
			}
			m.Class = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Class |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			m.TTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTL |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataLength", wireType)
			}
			m.DataLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NS", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NS = append(m.NS[:0], dAtA[iNdEx:postIndex]...)
			if m.NS == nil {
				m.NS = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CNAME", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CNAME = append(m.CNAME[:0], dAtA[iNdEx:postIndex]...)
			if m.CNAME == nil {
				m.CNAME = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PTR", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PTR = append(m.PTR[:0], dAtA[iNdEx:postIndex]...)
			if m.PTR == nil {
				m.PTR = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SOA", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SOA == nil {
				m.SOA = &DNSSOA{}
			}
			if err := m.SOA.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SRV", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SRV == nil {
				m.SRV = &DNSSRV{}
			}
			if err := m.SRV.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MX", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MX == nil {
				m.MX = &DNSMX{}
			}
			if err := m.MX.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TXTs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TXTs = append(m.TXTs, make([]byte, postIndex-iNdEx))
			copy(m.TXTs[len(m.TXTs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DNSSOA) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNSSOA: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNSSOA: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MName = append(m.MName[:0], dAtA[iNdEx:postIndex]...)
			if m.MName == nil {
				m.MName = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RName = append(m.RName[:0], dAtA[iNdEx:postIndex]...)
			if m.RName == nil {
				m.RName = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Serial", wireType)
			}
			m.Serial = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Serial |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refresh", wireType)
			}
			m.Refresh = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Refresh |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retry", wireType)
			}
			m.Retry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Retry |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expire", wireType)
			}
			m.Expire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expire |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minimum", wireType)
			}
			m.Minimum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Minimum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DNSSRV) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNSSRV: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNSSRV: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = append(m.Name[:0], dAtA[iNdEx:postIndex]...)
			if m.Name == nil {
				m.Name = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DNSMX) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNSMX: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNSMX: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Preference", wireType)
			}
			m.Preference = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Preference |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DNSQuestion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNSQuestion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNSQuestion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Class", wireType)
			}
			m.Class = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Class |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHCPv4) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHCPv4: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHCPv4: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			m.Operation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operation |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardwareType", wireType)
			}
			m.HardwareType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HardwareType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardwareLen", wireType)
			}
			m.HardwareLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HardwareLen |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardwareOpts", wireType)
			}
			m.HardwareOpts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HardwareOpts |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Xid", wireType)
			}
			m.Xid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Xid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secs", wireType)
			}
			m.Secs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Secs |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field YourClientIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.YourClientIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextServerIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextServerIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayAgentIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelayAgentIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientHWAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientHWAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerName = append(m.ServerName[:0], dAtA[iNdEx:postIndex]...)
			if m.ServerName == nil {
				m.ServerName = []byte{}
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.File = append(m.File[:0], dAtA[iNdEx:postIndex]...)
			if m.File == nil {
				m.File = []byte{}
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, &DHCPOption{})
			if err := m.Options[len(m.Options)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fingerprint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fingerprint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHCPOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHCPOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHCPOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHCPv6) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHCPv6: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHCPv6: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgType", wireType)
			}
			m.MsgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HopCount", wireType)
			}
			m.HopCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HopCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinkAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionID = append(m.TransactionID[:0], dAtA[iNdEx:postIndex]...)
			if m.TransactionID == nil {
				m.TransactionID = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, &DHCPv6Option{})
			if err := m.Options[len(m.Options)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fingerprint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fingerprint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHCPv6Option) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHCPv6Option: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHCPv6Option: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LLC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LLC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LLC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DSAP", wireType)
			}
			m.DSAP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DSAP |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IG", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IG = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SSAP", wireType)
			}
			m.SSAP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SSAP |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CR", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CR = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Control", wireType)
			}
			m.Control = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Control |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NTP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NTP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NTP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeapIndicator", wireType)
			}
			m.LeapIndicator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeapIndicator |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stratum", wireType)
			}
			m.Stratum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stratum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poll", wireType)
			}
			m.Poll = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Poll |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Precision", wireType)
			}
			m.Precision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Precision |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootDelay", wireType)
			}
			m.RootDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RootDelay |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootDispersion", wireType)
			}
			m.RootDispersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RootDispersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceID", wireType)
			}
			m.ReferenceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReferenceID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceTimestamp", wireType)
			}
			m.ReferenceTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReferenceTimestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginTimestamp", wireType)
			}
			m.OriginTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginTimestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiveTimestamp", wireType)
			}
			m.ReceiveTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReceiveTimestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransmitTimestamp", wireType)
			}
			m.TransmitTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransmitTimestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtensionBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtensionBytes = append(m.ExtensionBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.ExtensionBytes == nil {
				m.ExtensionBytes = []byte{}
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SIP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SIP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SIP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			m.Method = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Method |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsResponse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsResponse = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseCode", wireType)
			}
			m.ResponseCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IGMP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IGMP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IGMP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxResponseTime", wireType)
			}
			m.MaxResponseTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxResponseTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			m.Checksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Checksum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupressRouterProcessing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SupressRouterProcessing = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RobustnessValue", wireType)
			}
			m.RobustnessValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RobustnessValue |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalTime", wireType)
			}
			m.IntervalTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IntervalTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceAddresses = append(m.SourceAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfGroupRecords", wireType)
			}
			m.NumberOfGroupRecords = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberOfGroupRecords |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfSources", wireType)
			}
			m.NumberOfSources = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberOfSources |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupRecords", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupRecords = append(m.GroupRecords, &IGMPv3GroupRecord{})
			if err := m.GroupRecords[len(m.GroupRecords)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IGMPv3GroupRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IGMPv3GroupRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IGMPv3GroupRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuxDataLen", wireType)
			}
			m.AuxDataLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuxDataLen |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfSources", wireType)
			}
			m.NumberOfSources = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberOfSources |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MulticastAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MulticastAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceAddresses = append(m.SourceAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPv6HopByHop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPv6HopByHop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPv6HopByHop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, &IPv6HopByHopOption{})
			if err := m.Options[len(m.Options)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPv6HopByHopOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPv6HopByHopOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPv6HopByHopOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionType", wireType)
			}
			m.OptionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionLength", wireType)
			}
			m.OptionLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActualLength", wireType)
			}
			m.ActualLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActualLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionData = append(m.OptionData[:0], dAtA[iNdEx:postIndex]...)
			if m.OptionData == nil {
				m.OptionData = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionAlignment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionAlignment == nil {
				m.OptionAlignment = &IPv6HopByHopOptionAlignment{}
			}
			if err := m.OptionAlignment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPv6HopByHopOptionAlignment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPv6HopByHopOptionAlignment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPv6HopByHopOptionAlignment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field One", wireType)
			}
			m.One = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.One |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Two", wireType)
			}
			m.Two = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Two |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SNAP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SNAP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SNAP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrganizationalCode", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrganizationalCode = append(m.OrganizationalCode[:0], dAtA[iNdEx:postIndex]...)
			if m.OrganizationalCode == nil {
				m.OrganizationalCode = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ICMPv6Echo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPv6Echo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPv6Echo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identifier", wireType)
			}
			m.Identifier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Identifier |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNumber", wireType)
			}
			m.SeqNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNumber |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ICMPv6NeighborSolicitation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPv6NeighborSolicitation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPv6NeighborSolicitation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, &ICMPv6Option{})
			if err := m.Options[len(m.Options)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ICMPv6RouterSolicitation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPv6RouterSolicitation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPv6RouterSolicitation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, &ICMPv6Option{})
			if err := m.Options[len(m.Options)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HTTP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proto = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserAgent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserAgent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Referer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Referer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqCookies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqCookies = append(m.ReqCookies, &HTTPCookie{})
			if err := m.ReqCookies[len(m.ReqCookies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqContentLength", wireType)
			}
			m.ReqContentLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqContentLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResContentLength", wireType)
			}
			m.ResContentLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResContentLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqContentEncoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqContentEncoding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResContentEncoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResContentEncoding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResCookies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResCookies = append(m.ResCookies, &HTTPCookie{})
			if err := m.ResCookies[len(m.ResCookies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoneAfter", wireType)
			}
			m.DoneAfter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DoneAfter |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNSDoneAfter", wireType)
			}
			m.DNSDoneAfter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DNSDoneAfter |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstByteAfter", wireType)
			}
			m.FirstByteAfter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FirstByteAfter |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TLSDoneAfter", wireType)
			}
			m.TLSDoneAfter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TLSDoneAfter |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentTypeDetected", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentTypeDetected = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResContentTypeDetected", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResContentTypeDetected = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestHeader == nil {
				m.RequestHeader = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthNetcap
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthNetcap
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthNetcap
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthNetcap
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipNetcap(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthNetcap
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RequestHeader[mapkey] = mapvalue
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResponseHeader == nil {
				m.ResponseHeader = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthNetcap
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthNetcap
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthNetcap
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthNetcap
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipNetcap(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthNetcap
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ResponseHeader[mapkey] = mapvalue
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Parameters == nil {
				m.Parameters = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthNetcap
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthNetcap
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthNetcap
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthNetcap
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipNetcap(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthNetcap
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Parameters[mapkey] = mapvalue
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestBody", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestBody = append(m.RequestBody[:0], dAtA[iNdEx:postIndex]...)
			if m.RequestBody == nil {
				m.RequestBody = []byte{}
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseBody", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseBody = append(m.ResponseBody[:0], dAtA[iNdEx:postIndex]...)
			if m.ResponseBody == nil {
				m.ResponseBody = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HTTPCookie) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTPCookie: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTPCookie: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expires", wireType)
			}
			m.Expires = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expires |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAge", wireType)
			}
			m.MaxAge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxAge |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Secure = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HttpOnly = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SameSite", wireType)
			}
			m.SameSite = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SameSite |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLSClientHello) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TLSClientHello: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TLSClientHello: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageLen", wireType)
			}
			m.MessageLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageLen |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HandshakeType", wireType)
			}
			m.HandshakeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HandshakeType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HandshakeLen", wireType)
			}
			m.HandshakeLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HandshakeLen |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HandshakeVersion", wireType)
			}
			m.HandshakeVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HandshakeVersion |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Random", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Random = append(m.Random[:0], dAtA[iNdEx:postIndex]...)
			if m.Random == nil {
				m.Random = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionIDLen", wireType)
			}
			m.SessionIDLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionIDLen |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionID = append(m.SessionID[:0], dAtA[iNdEx:postIndex]...)
			if m.SessionID == nil {
				m.SessionID = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CipherSuiteLen", wireType)
			}
			m.CipherSuiteLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CipherSuiteLen |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtensionLen", wireType)
			}
			m.ExtensionLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExtensionLen |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SNI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SNI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OSCP", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OSCP = bool(v != 0)
		case 15:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CipherSuites = append(m.CipherSuites, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNetcap
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNetcap
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CipherSuites) == 0 {
					m.CipherSuites = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CipherSuites = append(m.CipherSuites, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CipherSuites", wireType)
			}
		case 16:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CompressMethods = append(m.CompressMethods, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNetcap
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNetcap
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CompressMethods) == 0 {
					m.CompressMethods = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CompressMethods = append(m.CompressMethods, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressMethods", wireType)
			}
		case 17:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SignatureAlgs = append(m.SignatureAlgs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNetcap
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNetcap
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SignatureAlgs) == 0 {
					m.SignatureAlgs = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SignatureAlgs = append(m.SignatureAlgs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SignatureAlgs", wireType)
			}
		case 18:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SupportedGroups = append(m.SupportedGroups, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNetcap
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNetcap
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SupportedGroups) == 0 {
					m.SupportedGroups = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SupportedGroups = append(m.SupportedGroups, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportedGroups", wireType)
			}
		case 19:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SupportedPoints = append(m.SupportedPoints, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNetcap
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNetcap
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SupportedPoints) == 0 {
					m.SupportedPoints = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SupportedPoints = append(m.SupportedPoints, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportedPoints", wireType)
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ALPNs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ALPNs = append(m.ALPNs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ja3", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ja3 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcMAC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcMAC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstMAC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstMAC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Extensions = append(m.Extensions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNetcap
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNetcap
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Extensions) == 0 {
					m.Extensions = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Extensions = append(m.Extensions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Extensions", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLSServerHello) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TLSServerHello: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TLSServerHello: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Random", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Random = append(m.Random[:0], dAtA[iNdEx:postIndex]...)
			if m.Random == nil {
				m.Random = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionID = append(m.SessionID[:0], dAtA[iNdEx:postIndex]...)
			if m.SessionID == nil {
				m.SessionID = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CipherSuite", wireType)
			}
			m.CipherSuite = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CipherSuite |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressionMethod", wireType)
			}
			m.CompressionMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompressionMethod |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextProtoNeg", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NextProtoNeg = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextProtos", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextProtos = append(m.NextProtos, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OCSPStapling", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OCSPStapling = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketSupported", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TicketSupported = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecureRenegotiationSupported", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SecureRenegotiationSupported = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecureRenegotiation", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecureRenegotiation = append(m.SecureRenegotiation[:0], dAtA[iNdEx:postIndex]...)
			if m.SecureRenegotiation == nil {
				m.SecureRenegotiation = []byte{}
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlpnProtocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AlpnProtocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ems", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ems = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scts", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scts = append(m.Scts, make([]byte, postIndex-iNdEx))
			copy(m.Scts[len(m.Scts)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportedVersion", wireType)
			}
			m.SupportedVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SupportedVersion |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelectedIdentityPresent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SelectedIdentityPresent = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelectedIdentity", wireType)
			}
			m.SelectedIdentity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelectedIdentity |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cookie", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cookie = append(m.Cookie[:0], dAtA[iNdEx:postIndex]...)
			if m.Cookie == nil {
				m.Cookie = []byte{}
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelectedGroup", wireType)
			}
			m.SelectedGroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelectedGroup |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Extensions = append(m.Extensions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNetcap
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNetcap
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Extensions) == 0 {
					m.Extensions = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Extensions = append(m.Extensions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Extensions", wireType)
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcMAC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcMAC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstMAC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstMAC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ja3S", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ja3S = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPSecAH) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPSecAH: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPSecAH: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved", wireType)
			}
			m.Reserved = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reserved |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SPI", wireType)
			}
			m.SPI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SPI |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthenticationData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthenticationData = append(m.AuthenticationData[:0], dAtA[iNdEx:postIndex]...)
			if m.AuthenticationData == nil {
				m.AuthenticationData = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPSecESP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPSecESP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPSecESP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SPI", wireType)
			}
			m.SPI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SPI |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LenEncrypted", wireType)
			}
			m.LenEncrypted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LenEncrypted |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Geneve) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Geneve: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Geneve: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionsLength", wireType)
			}
			m.OptionsLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionsLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OAMPacket", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OAMPacket = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CriticalOption", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CriticalOption = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VNI", wireType)
			}
			m.VNI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VNI |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, &GeneveOption{})
			if err := m.Options[len(m.Options)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GeneveOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GeneveOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GeneveOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Class", wireType)
			}
			m.Class = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Class |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VXLAN) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VXLAN: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VXLAN: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidIDFlag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ValidIDFlag = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VNI", wireType)
			}
			m.VNI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VNI |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GBPExtension", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GBPExtension = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GBPDontLearn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GBPDontLearn = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GBPApplied", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GBPApplied = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GBPGroupPolicyID", wireType)
			}
			m.GBPGroupPolicyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GBPGroupPolicyID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *USB) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: USB: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: USB: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferType", wireType)
			}
			m.TransferType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransferType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointNumber", wireType)
			}
			m.EndpointNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndpointNumber |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceAddress", wireType)
			}
			m.DeviceAddress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeviceAddress |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BusID", wireType)
			}
			m.BusID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BusID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampSec", wireType)
			}
			m.TimestampSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampSec |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampUsec", wireType)
			}
			m.TimestampUsec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampUsec |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Setup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Setup = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Data = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrbLength", wireType)
			}
			m.UrbLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UrbLength |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrbDataLength", wireType)
			}
			m.UrbDataLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UrbDataLength |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrbInterval", wireType)
			}
			m.UrbInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UrbInterval |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrbStartFrame", wireType)
			}
			m.UrbStartFrame = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UrbStartFrame |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrbCopyOfTransferFlags", wireType)
			}
			m.UrbCopyOfTransferFlags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UrbCopyOfTransferFlags |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsoNumDesc", wireType)
			}
			m.IsoNumDesc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsoNumDesc |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *USBRequestBlockSetup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: USBRequestBlockSetup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: USBRequestBlockSetup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestType", wireType)
			}
			m.RequestType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			m.Request = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Request |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LCM) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LCM: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LCM: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Magic", wireType)
			}
			m.Magic = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Magic |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadSize", wireType)
			}
			m.PayloadSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayloadSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FragmentOffset", wireType)
			}
			m.FragmentOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FragmentOffset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FragmentNumber", wireType)
			}
			m.FragmentNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FragmentNumber |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalFragments", wireType)
			}
			m.TotalFragments = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalFragments |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fragmented", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fragmented = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MPLS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MPLS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MPLS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			m.Label = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Label |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficClass", wireType)
			}
			m.TrafficClass = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrafficClass |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StackBottom", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StackBottom = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			m.TTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTL |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Modbus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Modbus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Modbus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionID", wireType)
			}
			m.TransactionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransactionID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolID", wireType)
			}
			m.ProtocolID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtocolID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitID", wireType)
			}
			m.UnitID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnitID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exception", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exception = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionCode", wireType)
			}
			m.FunctionCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FunctionCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OSPFv2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OSPFv2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OSPFv2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketLength", wireType)
			}
			m.PacketLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouterID", wireType)
			}
			m.RouterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouterID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaID", wireType)
			}
			m.AreaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AreaID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			m.Checksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Checksum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuType", wireType)
			}
			m.AuType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authentication", wireType)
			}
			m.Authentication = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Authentication |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LSAs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LSAs = append(m.LSAs, &LSAheader{})
			if err := m.LSAs[len(m.LSAs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LSU", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LSU == nil {
				m.LSU = &LSUpdate{}
			}
			if err := m.LSU.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LSR", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LSR = append(m.LSR, &LSReq{})
			if err := m.LSR[len(m.LSR)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DbDesc == nil {
				m.DbDesc = &DbDescPkg{}
			}
			if err := m.DbDesc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HelloV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HelloV2 == nil {
				m.HelloV2 = &HelloPkgV2{}
			}
			if err := m.HelloV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HelloPkg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HelloPkg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HelloPkg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceID", wireType)
			}
			m.InterfaceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterfaceID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RtrPriority", wireType)
			}
			m.RtrPriority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RtrPriority |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			m.Options = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Options |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HelloInterval", wireType)
			}
			m.HelloInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HelloInterval |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouterDeadInterval", wireType)
			}
			m.RouterDeadInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouterDeadInterval |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesignatedRouterID", wireType)
			}
			m.DesignatedRouterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DesignatedRouterID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupDesignatedRouterID", wireType)
			}
			m.BackupDesignatedRouterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BackupDesignatedRouterID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NeighborID = append(m.NeighborID, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNetcap
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNetcap
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NeighborID) == 0 {
					m.NeighborID = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NeighborID = append(m.NeighborID, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NeighborID", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HelloPkgV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HelloPkgV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HelloPkgV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceID", wireType)
			}
			m.InterfaceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterfaceID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RtrPriority", wireType)
			}
			m.RtrPriority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RtrPriority |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			m.Options = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Options |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HelloInterval", wireType)
			}
			m.HelloInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HelloInterval |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouterDeadInterval", wireType)
			}
			m.RouterDeadInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouterDeadInterval |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesignatedRouterID", wireType)
			}
			m.DesignatedRouterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DesignatedRouterID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupDesignatedRouterID", wireType)
			}
			m.BackupDesignatedRouterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BackupDesignatedRouterID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NeighborID = append(m.NeighborID, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNetcap
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNetcap
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NeighborID) == 0 {
					m.NeighborID = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NeighborID = append(m.NeighborID, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NeighborID", wireType)
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkMask", wireType)
			}
			m.NetworkMask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkMask |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DbDescPkg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DbDescPkg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DbDescPkg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			m.Options = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Options |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceMTU", wireType)
			}
			m.InterfaceMTU = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterfaceMTU |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DDSeqNumber", wireType)
			}
			m.DDSeqNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DDSeqNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LSAinfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LSAinfo = append(m.LSAinfo, &LSAheader{})
			if err := m.LSAinfo[len(m.LSAinfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OSPFv3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OSPFv3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OSPFv3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketLength", wireType)
			}
			m.PacketLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouterID", wireType)
			}
			m.RouterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouterID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaID", wireType)
			}
			m.AreaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AreaID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			m.Checksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Checksum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			m.Instance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Instance |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved", wireType)
			}
			m.Reserved = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reserved |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hello", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hello == nil {
				m.Hello = &HelloPkg{}
			}
			if err := m.Hello.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DbDesc == nil {
				m.DbDesc = &DbDescPkg{}
			}
			if err := m.DbDesc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LSR", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LSR = append(m.LSR, &LSReq{})
			if err := m.LSR[len(m.LSR)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LSU", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LSU == nil {
				m.LSU = &LSUpdate{}
			}
			if err := m.LSU.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LSAs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LSAs = append(m.LSAs, &LSAheader{})
			if err := m.LSAs[len(m.LSAs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LSAheader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LSAheader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LSAheader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LSAge", wireType)
			}
			m.LSAge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LSAge |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LSType", wireType)
			}
			m.LSType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LSType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkStateID", wireType)
			}
			m.LinkStateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinkStateID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvRouter", wireType)
			}
			m.AdvRouter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdvRouter |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LSSeqNumber", wireType)
			}
			m.LSSeqNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LSSeqNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LSChecksum", wireType)
			}
			m.LSChecksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LSChecksum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LSOptions", wireType)
			}
			m.LSOptions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LSOptions |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LSA) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LSA: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LSA: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &LSAheader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RLSAV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RLSAV2 == nil {
				m.RLSAV2 = &RouterLSAV2{}
			}
			if err := m.RLSAV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ASELSAV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ASELSAV2 == nil {
				m.ASELSAV2 = &ASExternalLSAV2{}
			}
			if err := m.ASELSAV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RLSA", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RLSA == nil {
				m.RLSA = &RouterLSA{}
			}
			if err := m.RLSA.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NLSA", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NLSA == nil {
				m.NLSA = &NetworkLSA{}
			}
			if err := m.NLSA.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterAPrefixLSA", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InterAPrefixLSA == nil {
				m.InterAPrefixLSA = &InterAreaPrefixLSA{}
			}
			if err := m.InterAPrefixLSA.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IARouterLSA", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IARouterLSA == nil {
				m.IARouterLSA = &InterAreaRouterLSA{}
			}
			if err := m.IARouterLSA.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ASELSA", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ASELSA == nil {
				m.ASELSA = &ASExternalLSA{}
			}
			if err := m.ASELSA.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LLSA", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LLSA == nil {
				m.LLSA = &LinkLSA{}
			}
			if err := m.LLSA.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntraAPrefixLSA", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IntraAPrefixLSA == nil {
				m.IntraAPrefixLSA = &IntraAreaPrefixLSA{}
			}
			if err := m.IntraAPrefixLSA.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LSReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LSReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LSReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LSType", wireType)
			}
			m.LSType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LSType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LSID", wireType)
			}
			m.LSID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LSID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvRouter", wireType)
			}
			m.AdvRouter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdvRouter |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LSUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LSUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LSUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOfLSAs", wireType)
			}
			m.NumOfLSAs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOfLSAs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LSAs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LSAs = append(m.LSAs, &LSA{})
			if err := m.LSAs[len(m.LSAs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IntraAreaPrefixLSA) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IntraAreaPrefixLSA: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IntraAreaPrefixLSA: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOfPrefixes", wireType)
			}
			m.NumOfPrefixes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOfPrefixes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefLSType", wireType)
			}
			m.RefLSType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefLSType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefLinkStateID", wireType)
			}
			m.RefLinkStateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefLinkStateID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefAdvRouter", wireType)
			}
			m.RefAdvRouter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefAdvRouter |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefixes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefixes = append(m.Prefixes, &LSAPrefix{})
			if err := m.Prefixes[len(m.Prefixes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ASExternalLSA) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ASExternalLSA: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ASExternalLSA: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			m.Metric = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Metric |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixLength", wireType)
			}
			m.PrefixLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrefixLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixOptions", wireType)
			}
			m.PrefixOptions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrefixOptions |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefLSType", wireType)
			}
			m.RefLSType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefLSType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressPrefix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressPrefix = append(m.AddressPrefix[:0], dAtA[iNdEx:postIndex]...)
			if m.AddressPrefix == nil {
				m.AddressPrefix = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardingAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForwardingAddress = append(m.ForwardingAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.ForwardingAddress == nil {
				m.ForwardingAddress = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalRouteTag", wireType)
			}
			m.ExternalRouteTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalRouteTag |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefLinkStateID", wireType)
			}
			m.RefLinkStateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefLinkStateID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterAreaPrefixLSA) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterAreaPrefixLSA: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterAreaPrefixLSA: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			m.Metric = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Metric |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixLength", wireType)
			}
			m.PrefixLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrefixLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixOptions", wireType)
			}
			m.PrefixOptions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrefixOptions |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressPrefix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressPrefix = append(m.AddressPrefix[:0], dAtA[iNdEx:postIndex]...)
			if m.AddressPrefix == nil {
				m.AddressPrefix = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterAreaRouterLSA) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterAreaRouterLSA: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterAreaRouterLSA: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			m.Options = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Options |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			m.Metric = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Metric |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationRouterID", wireType)
			}
			m.DestinationRouterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestinationRouterID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ASExternalLSAV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ASExternalLSAV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ASExternalLSAV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkMask", wireType)
			}
			m.NetworkMask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkMask |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalBit", wireType)
			}
			m.ExternalBit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalBit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			m.Metric = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Metric |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardingAddress", wireType)
			}
			m.ForwardingAddress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForwardingAddress |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalRouteTag", wireType)
			}
			m.ExternalRouteTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalRouteTag |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouterLSA) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouterLSA: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouterLSA: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			m.Options = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Options |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routers = append(m.Routers, &Router{})
			if err := m.Routers[len(m.Routers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Router) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Router: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Router: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			m.Metric = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Metric |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceID", wireType)
			}
			m.InterfaceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterfaceID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeighborInterfaceID", wireType)
			}
			m.NeighborInterfaceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NeighborInterfaceID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeighborRouterID", wireType)
			}
			m.NeighborRouterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NeighborRouterID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouterLSAV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouterLSAV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouterLSAV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Links", wireType)
			}
			m.Links = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Links |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routers = append(m.Routers, &RouterV2{})
			if err := m.Routers[len(m.Routers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouterV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouterV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouterV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkID", wireType)
			}
			m.LinkID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinkID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkData", wireType)
			}
			m.LinkData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinkData |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			m.Metric = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Metric |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkLSA) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkLSA: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkLSA: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			m.Options = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Options |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AttachedRouter = append(m.AttachedRouter, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNetcap
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNetcap
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AttachedRouter) == 0 {
					m.AttachedRouter = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AttachedRouter = append(m.AttachedRouter, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AttachedRouter", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinkLSA) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinkLSA: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinkLSA: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RtrPriority", wireType)
			}
			m.RtrPriority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RtrPriority |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			m.Options = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Options |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkLocalAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinkLocalAddress = append(m.LinkLocalAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.LinkLocalAddress == nil {
				m.LinkLocalAddress = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOfPrefixes", wireType)
			}
			m.NumOfPrefixes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOfPrefixes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefixes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefixes = append(m.Prefixes, &LSAPrefix{})
			if err := m.Prefixes[len(m.Prefixes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LSAPrefix) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LSAPrefix: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LSAPrefix: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixLength", wireType)
			}
			m.PrefixLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrefixLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixOptions", wireType)
			}
			m.PrefixOptions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrefixOptions |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			m.Metric = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Metric |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressPrefix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressPrefix = append(m.AddressPrefix[:0], dAtA[iNdEx:postIndex]...)
			if m.AddressPrefix == nil {
				m.AddressPrefix = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BFD) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BFD: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BFD: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Diagnostic", wireType)
			}
			m.Diagnostic = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Diagnostic |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poll", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Poll = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Final", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Final = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlPlaneIndependent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ControlPlaneIndependent = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthPresent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AuthPresent = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Demand", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Demand = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Multipoint", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Multipoint = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetectMultiplier", wireType)
			}
			m.DetectMultiplier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DetectMultiplier |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MyDiscriminator", wireType)
			}
			m.MyDiscriminator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MyDiscriminator |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field YourDiscriminator", wireType)
			}
			m.YourDiscriminator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.YourDiscriminator |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesiredMinTxInterval", wireType)
			}
			m.DesiredMinTxInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DesiredMinTxInterval |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredMinRxInterval", wireType)
			}
			m.RequiredMinRxInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequiredMinRxInterval |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredMinEchoRxInterval", wireType)
			}
			m.RequiredMinEchoRxInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequiredMinEchoRxInterval |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthHeader == nil {
				m.AuthHeader = &BFDAuthHeader{}
			}
			if err := m.AuthHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BFDAuthHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BFDAuthHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BFDAuthHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthType", wireType)
			}
			m.AuthType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyID", wireType)
			}
			m.KeyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GRE) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GRE: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GRE: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChecksumPresent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ChecksumPresent = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutingPresent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RoutingPresent = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyPresent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KeyPresent = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqPresent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SeqPresent = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrictSourceRoute", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StrictSourceRoute = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AckPresent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AckPresent = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecursionControl", wireType)
			}
			m.RecursionControl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecursionControl |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			m.Checksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Checksum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ack", wireType)
			}
			m.Ack = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ack |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Routing == nil {
				m.Routing = &GRERouting{}
			}
			if err := m.Routing.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GRERouting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GRERouting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GRERouting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressFamily", wireType)
			}
			m.AddressFamily = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddressFamily |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SREOffset", wireType)
			}
			m.SREOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SREOffset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SRELength", wireType)
			}
			m.SRELength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SRELength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutingInformation", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoutingInformation = append(m.RoutingInformation[:0], dAtA[iNdEx:postIndex]...)
			if m.RoutingInformation == nil {
				m.RoutingInformation = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Next == nil {
				m.Next = &GRERouting{}
			}
			if err := m.Next.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FDDI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FDDI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FDDI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrameControl", wireType)
			}
			m.FrameControl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FrameControl |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcMAC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcMAC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstMAC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstMAC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EAP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EAP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EAP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeData = append(m.TypeData[:0], dAtA[iNdEx:postIndex]...)
			if m.TypeData == nil {
				m.TypeData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EAPOL) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EAPOL: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EAPOL: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EAPOLKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EAPOLKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EAPOLKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyDescriptorType", wireType)
			}
			m.KeyDescriptorType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyDescriptorType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyDescriptorVersion", wireType)
			}
			m.KeyDescriptorVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyDescriptorVersion |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyType", wireType)
			}
			m.KeyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyIndex", wireType)
			}
			m.KeyIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Install", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Install = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyACK", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KeyACK = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyMIC", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KeyMIC = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Secure = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MICError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MICError = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Request = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasEncryptedKeyData", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasEncryptedKeyData = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SMKMessage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SMKMessage = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyLength", wireType)
			}
			m.KeyLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplayCounter", wireType)
			}
			m.ReplayCounter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplayCounter |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = append(m.Nonce[:0], dAtA[iNdEx:postIndex]...)
			if m.Nonce == nil {
				m.Nonce = []byte{}
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IV", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IV = append(m.IV[:0], dAtA[iNdEx:postIndex]...)
			if m.IV == nil {
				m.IV = []byte{}
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RSC", wireType)
			}
			m.RSC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RSC |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MIC", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MIC = append(m.MIC[:0], dAtA[iNdEx:postIndex]...)
			if m.MIC == nil {
				m.MIC = []byte{}
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyDataLength", wireType)
			}
			m.KeyDataLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyDataLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedKeyData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedKeyData = append(m.EncryptedKeyData[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedKeyData == nil {
				m.EncryptedKeyData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VRRPv2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VRRPv2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VRRPv2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualRtrID", wireType)
			}
			m.VirtualRtrID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VirtualRtrID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountIPAddr", wireType)
			}
			m.CountIPAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CountIPAddr |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthType", wireType)
			}
			m.AuthType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdverInt", wireType)
			}
			m.AdverInt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdverInt |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			m.Checksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Checksum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPAddress = append(m.IPAddress, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CiscoDiscovery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CiscoDiscovery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CiscoDiscovery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			m.TTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTL |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			m.Checksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Checksum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &CiscoDiscoveryValue{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CiscoDiscoveryValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CiscoDiscoveryValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CiscoDiscoveryValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDPVLANDialogue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDPVLANDialogue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDPVLANDialogue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VLAN", wireType)
			}
			m.VLAN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VLAN |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDPLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDPLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDPLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDPPowerDialogue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDPPowerDialogue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDPPowerDialogue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MgmtID", wireType)
			}
			m.MgmtID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MgmtID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Values = append(m.Values, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNetcap
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNetcap
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Values) == 0 {
					m.Values = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Values = append(m.Values, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDPSparePairPoE) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDPSparePairPoE: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDPSparePairPoE: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PSEFourWire", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PSEFourWire = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PDArchShared", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PDArchShared = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PDRequestOn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PDRequestOn = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PSEOn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PSEOn = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CiscoDiscoveryInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CiscoDiscoveryInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CiscoDiscoveryInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CDPHello", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CDPHello == nil {
				m.CDPHello = &CDPHello{}
			}
			if err := m.CDPHello.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addresses = append(m.Addresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capabilities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Capabilities == nil {
				m.Capabilities = &CDPCapabilities{}
			}
			if err := m.Capabilities.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPPrefixes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPPrefixes = append(m.IPPrefixes, &IPNet{})
			if err := m.IPPrefixes[len(m.IPPrefixes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VTPDomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VTPDomain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NativeVLAN", wireType)
			}
			m.NativeVLAN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NativeVLAN |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullDuplex", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FullDuplex = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VLANReply", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VLANReply == nil {
				m.VLANReply = &CDPVLANDialogue{}
			}
			if err := m.VLANReply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VLANQuery", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VLANQuery == nil {
				m.VLANQuery = &CDPVLANDialogue{}
			}
			if err := m.VLANQuery.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerConsumption", wireType)
			}
			m.PowerConsumption = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PowerConsumption |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MTU", wireType)
			}
			m.MTU = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MTU |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtendedTrust", wireType)
			}
			m.ExtendedTrust = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExtendedTrust |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UntrustedCOS", wireType)
			}
			m.UntrustedCOS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UntrustedCOS |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SysName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SysName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SysOID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SysOID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MgmtAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MgmtAddresses = append(m.MgmtAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &CDPLocation{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PowerRequest == nil {
				m.PowerRequest = &CDPPowerDialogue{}
			}
			if err := m.PowerRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerAvailable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PowerAvailable == nil {
				m.PowerAvailable = &CDPPowerDialogue{}
			}
			if err := m.PowerAvailable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SparePairPoe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SparePairPoe == nil {
				m.SparePairPoe = &CDPSparePairPoE{}
			}
			if err := m.SparePairPoe.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnergyWise", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnergyWise == nil {
				m.EnergyWise = &CDPEnergyWise{}
			}
			if err := m.EnergyWise.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unknown", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unknown = append(m.Unknown, &CiscoDiscoveryValue{})
			if err := m.Unknown[len(m.Unknown)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDPHello) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDPHello: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDPHello: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OUI", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OUI = append(m.OUI[:0], dAtA[iNdEx:postIndex]...)
			if m.OUI == nil {
				m.OUI = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolID", wireType)
			}
			m.ProtocolID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtocolID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterMaster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterMaster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unknown1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unknown1 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubVersion", wireType)
			}
			m.SubVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubVersion |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unknown2", wireType)
			}
			m.Unknown2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Unknown2 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterCommander", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterCommander = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchMAC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwitchMAC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unknown3", wireType)
			}
			m.Unknown3 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Unknown3 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagementVLAN", wireType)
			}
			m.ManagementVLAN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ManagementVLAN |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDPEnergyWise) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDPEnergyWise: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDPEnergyWise: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedData = append(m.EncryptedData[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedData == nil {
				m.EncryptedData = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unknown1", wireType)
			}
			m.Unknown1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Unknown1 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unknown2", wireType)
			}
			m.Unknown2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Unknown2 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardwareID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HardwareID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialNum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerialNum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unknown3", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unknown3 = append(m.Unknown3[:0], dAtA[iNdEx:postIndex]...)
			if m.Unknown3 == nil {
				m.Unknown3 = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyUnknown1", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyUnknown1 = append(m.ReplyUnknown1[:0], dAtA[iNdEx:postIndex]...)
			if m.ReplyUnknown1 == nil {
				m.ReplyUnknown1 = []byte{}
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyPort", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyPort = append(m.ReplyPort[:0], dAtA[iNdEx:postIndex]...)
			if m.ReplyPort == nil {
				m.ReplyPort = []byte{}
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyAddress = append(m.ReplyAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.ReplyAddress == nil {
				m.ReplyAddress = []byte{}
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyUnknown2", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyUnknown2 = append(m.ReplyUnknown2[:0], dAtA[iNdEx:postIndex]...)
			if m.ReplyUnknown2 == nil {
				m.ReplyUnknown2 = []byte{}
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyUnknown3", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyUnknown3 = append(m.ReplyUnknown3[:0], dAtA[iNdEx:postIndex]...)
			if m.ReplyUnknown3 == nil {
				m.ReplyUnknown3 = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDPCapabilities) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDPCapabilities: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDPCapabilities: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L3Router", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.L3Router = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TBBridge", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TBBridge = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SPBridge", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SPBridge = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L2Switch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.L2Switch = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHost", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsHost = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IGMPFilter", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IGMPFilter = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1Repeater", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.L1Repeater = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPhone", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPhone = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemotelyManaged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RemotelyManaged = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPNet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPNet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPNet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPMask", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPMask = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NortelDiscovery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NortelDiscovery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NortelDiscovery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SegmentID = append(m.SegmentID[:0], dAtA[iNdEx:postIndex]...)
			if m.SegmentID == nil {
				m.SegmentID = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chassis", wireType)
			}
			m.Chassis = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chassis |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Backplane", wireType)
			}
			m.Backplane = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Backplane |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumLinks", wireType)
			}
			m.NumLinks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumLinks |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcMac", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcMac = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstMac", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstMac = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CIP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CIP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CIP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Response = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceID", wireType)
			}
			m.ServiceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServiceID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassID", wireType)
			}
			m.ClassID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClassID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceID", wireType)
			}
			m.InstanceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstanceID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AdditionalStatus = append(m.AdditionalStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNetcap
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNetcap
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AdditionalStatus) == 0 {
					m.AdditionalStatus = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AdditionalStatus = append(m.AdditionalStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalStatus", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ENIP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ENIP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ENIP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			m.Command = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Command |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionHandle", wireType)
			}
			m.SessionHandle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionHandle |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderContext", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SenderContext = append(m.SenderContext[:0], dAtA[iNdEx:postIndex]...)
			if m.SenderContext == nil {
				m.SenderContext = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			m.Options = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Options |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandSpecific", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommandSpecific == nil {
				m.CommandSpecific = &ENIPCommandSpecificData{}
			}
			if err := m.CommandSpecific.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ENIPCommandSpecificData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ENIPCommandSpecificData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ENIPCommandSpecificData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			m.Cmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cmd |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceProfile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceProfile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceProfile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceManufacturer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceManufacturer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceIPs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceIPs = append(m.DeviceIPs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contacts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contacts = append(m.Contacts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumPackets", wireType)
			}
			m.NumPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumPackets |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			m.Bytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Port) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Port: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Port: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortNumber", wireType)
			}
			m.PortNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortNumber |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &PortStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Packets", wireType)
			}
			m.Packets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Packets |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			m.Bytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPProfile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPProfile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPProfile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumPackets", wireType)
			}
			m.NumPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumPackets |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Geolocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Geolocation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNSNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DNSNames = append(m.DNSNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampFirst", wireType)
			}
			m.TimestampFirst = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampFirst |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampLast", wireType)
			}
			m.TimestampLast = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampLast |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Applications", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Applications = append(m.Applications, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ja3Hashes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ja3Hashes == nil {
				m.Ja3Hashes = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthNetcap
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthNetcap
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthNetcap
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthNetcap
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipNetcap(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthNetcap
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Ja3Hashes[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Protocols == nil {
				m.Protocols = make(map[string]*Protocol)
			}
			var mapkey string
			var mapvalue *Protocol
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthNetcap
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthNetcap
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthNetcap
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthNetcap
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Protocol{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipNetcap(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthNetcap
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Protocols[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			m.Bytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SNIs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SNIs == nil {
				m.SNIs = make(map[string]int64)
			}
			var mapkey string
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthNetcap
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthNetcap
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipNetcap(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthNetcap
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SNIs[mapkey] = mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcPorts = append(m.SrcPorts, &Port{})
			if err := m.SrcPorts[len(m.SrcPorts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstPorts = append(m.DstPorts, &Port{})
			if err := m.DstPorts[len(m.DstPorts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContactedPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContactedPorts = append(m.ContactedPorts, &Port{})
			if err := m.ContactedPorts[len(m.ContactedPorts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Protocol) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Protocol: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Protocol: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Packets", wireType)
			}
			m.Packets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Packets |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Category", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Category = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *File) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: File: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: File: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ident", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ident = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentTypeDetected", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentTypeDetected = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SMTPResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SMTPResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SMTPResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseCode", wireType)
			}
			m.ResponseCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SMTPRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SMTPRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SMTPRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Argument", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Argument = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SMTPCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SMTPCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SMTPCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			m.Command = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Command |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SMTP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SMTP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SMTP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEncrypted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEncrypted = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsResponse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsResponse = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MailIDs = append(m.MailIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commands", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commands = append(m.Commands, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Diameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Diameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Diameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageLen", wireType)
			}
			m.MessageLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageLen |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandCode", wireType)
			}
			m.CommandCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommandCode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationID", wireType)
			}
			m.ApplicationID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApplicationID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HopByHopID", wireType)
			}
			m.HopByHopID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HopByHopID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndToEndID", wireType)
			}
			m.EndToEndID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndToEndID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AVPs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AVPs = append(m.AVPs, &AVP{})
			if err := m.AVPs[len(m.AVPs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			m.SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			m.DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AVP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AVP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AVP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeCode", wireType)
			}
			m.AttributeCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttributeCode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttributeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttributeFormat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderLen", wireType)
			}
			m.HeaderLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeaderLen |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Len", wireType)
			}
			m.Len = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Len |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorCode", wireType)
			}
			m.VendorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VendorCode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecodedValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DecodedValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Padding", wireType)
			}
			m.Padding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Padding |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueLen", wireType)
			}
			m.ValueLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValueLen |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *POP3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: POP3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: POP3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MailIDs = append(m.MailIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commands", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commands = append(m.Commands, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Mail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReturnPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Date = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field References", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.References = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InReplyTo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InReplyTo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentLanguage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentLanguage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasAttachments", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasAttachments = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XOriginatingIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XOriginatingIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvelopeTo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnvelopeTo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body, &MailPart{})
			if err := m.Body[len(m.Body)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliveryDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeliveryDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Origin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailPart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MailPart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MailPart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetcap
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthNetcap
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthNetcap
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetcap
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthNetcap
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthNetcap
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipNetcap(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthNetcap
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Header[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *POP3Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: POP3Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: POP3Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Argument", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Argument = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *POP3Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: POP3Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: POP3Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Software) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Software: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Software: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Product", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Product = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vendor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceProfiles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceProfiles = append(m.DeviceProfiles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DPIResults", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DPIResults = append(m.DPIResults, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Service = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flows", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flows = append(m.Flows, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Website", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Website = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OS", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OS = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Service) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Service: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Service: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Banner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Banner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flows", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flows = append(m.Flows, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Product", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Product = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vendor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesServer", wireType)
			}
			m.BytesServer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesServer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesClient", wireType)
			}
			m.BytesClient = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesClient |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OS", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OS = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Credentials) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Credentials: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Credentials: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Service = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flow", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flow = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SSH) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SSH: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SSH: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HASSH", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HASSH = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flow", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flow = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ident", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ident = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algorithms", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Algorithms = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsClient", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsClient = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vulnerability) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vulnerability: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vulnerability: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Severity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V2Score", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V2Score = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessVector", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessVector = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Versions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Versions = append(m.Versions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Software", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Software == nil {
				m.Software = &Software{}
			}
			if err := m.Software.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Exploit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Exploit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Exploit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.File = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Date = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Typ = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Port = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Software", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Software == nil {
				m.Software = &Software{}
			}
			if err := m.Software.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Alert) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Alert: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Alert: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcPort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstPort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MITRE", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MITRE = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPReputation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPReputation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetcap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetcap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetcap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetcap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNetcap(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNetcap
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNetcap
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNetcap
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupNetcap
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthNetcap
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthNetcap        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNetcap          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupNetcap = fmt.Errorf("proto: unexpected end of group")
)
