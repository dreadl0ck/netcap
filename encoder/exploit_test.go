/*
 * NETCAP - Traffic Analysis Framework
 * Copyright (c) 2017-2020 Philipp Mieden <dreadl0ck [at] protonmail [dot] ch>
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

package encoder

import (
	"fmt"
	"github.com/blevesearch/bleve"
	"github.com/dreadl0ck/netcap/resolvers"
	"github.com/dreadl0ck/netcap/types"
	"github.com/dreadl0ck/netcap/utils"
	"github.com/mgutz/ansi"
	"path/filepath"
	"testing"
)

/*
 * Exploit Database
 * https://www.exploit-db.com
 */

func exploitDbLookupTest(software *types.Software) *bleve.SearchResult {
	var (
		queryTerm = buildExploitQuery(software.Vendor, software.Product, software.Version)
		query     = bleve.NewQueryStringQuery(queryTerm)
		//query = bleve.NewMatchQuery("Google Chrome")
		search             = bleve.NewSearchRequest(query)
		searchResults, err = exploitsIndex.Search(search)
	)
	fmt.Println("query:", queryTerm)
	if err != nil {
		utils.DebugLog.Println("failed to search for vulnerable software:", err)
		return nil
	}
	return searchResults
}

func TestExploitSearch(t *testing.T) {

	// Load vulnerabilities DB index
	var (
		indexName = filepath.Join(resolvers.DataBaseSource, "exploit-db.bleve")
		err       error
	)
	exploitsIndex, err = bleve.Open(indexName)
	if err != nil {
		t.Fatal(err)
	}

	// TODO: ensure only numeric values in versions
	// +Description:"Sucuri" +Versions:Cloudproxy ?

	for _, software := range testSoftware {

		fmt.Println("lookup software", software.Vendor, software.Product, software.Version)
		searchResults := exploitDbLookupTest(software)
		if searchResults == nil {
			t.Fatal("no results")
		}

		//fmt.Println("search for ", software.Product, software.Vendor, software.Version)

		for _, v := range searchResults.Hits {

			var color string
			doc, _ := exploitsIndex.Document(v.ID)
			if v.Score > thresholdNVD {
				color = ansi.Red
			}
			fmt.Println(ansi.Yellow, v.ID, "score", v.Score, ansi.Reset)
			for i, f := range doc.Fields {
				fmt.Println(color, i, f.Name(), string(f.Value()), ansi.Reset)
			}
			fmt.Println("---------------------------------------------------------")
		}
	}
}
