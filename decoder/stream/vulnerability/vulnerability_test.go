/*
 * NETCAP - Traffic Analysis Framework
 * Copyright (c) 2017-2020 Philipp Mieden <dreadl0ck [at] protonmail [dot] ch>
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

package vulnerability

import (
	"fmt"
	"path/filepath"
	"testing"

	"github.com/blevesearch/bleve"
	"github.com/mgutz/ansi"

	"github.com/dreadl0ck/netcap/decoder/db"
	"github.com/dreadl0ck/netcap/resolvers"
	"github.com/dreadl0ck/netcap/types"
)

const debugVulnerabilityTests = false

var testSoftware = []*types.Software{
	{
		Product: "PostgreSQL",
		Version: "9.1.0",
	},
	{
		Product: "OpenSSH",
		Version: "7.6",
	},
	{
		Product: "OpenSSH",
		Version: "7.6p1",
	},
	{
		Product: "OpenSSH",
		Version: "7.9",
	},
	{
		Vendor:  "Windows",
		Product: "SSH",
		Version: "7.7",
	},
	{
		Product: "Microsoft-IIS",
		Version: "10.0",
	},
	{
		Product: "Microsoft-CryptoAPI",
		Version: "10.0",
	},
	{
		Product: "NetDNA-cache",
		Version: "2.2",
	},
	{
		Product: "Edge",
		Version: "18.18363",
	},
	{
		Product: "Apache",
		Version: "2.4.38",
	},
	{
		Product: "Windows-Update-Agent",
		Version: "10.0.10011",
	},
	{
		Product: "Chrome",
		Vendor:  "Google",
		Version: "26.0.1410",
	},
	{
		Product: "Apache",
		Version: "2.4.7",
	},
	{
		Product: "Apache",
		Version: "2.4.38",
	},
	{
		Product: "NginX",
		Version: "1.14.0",
	},
	{
		Product: "PHP",
		Version: "7.0",
	},
	{
		Product: "vsFTP",
		Version: "3.0.3",
	},
}

//func TestLoadNVD(t *testing.T) {
//
//	start := time.Now()
//	years := []string{
//		"2002",
//		"2003",
//		"2004",
//		"2005",
//		"2006",
//		"2007",
//		"2008",
//		"2009",
//		"2010",
//		"2011",
//		"2012",
//		"2013",
//		"2014",
//		"2015",
//		"2016",
//		"2017",
//		"2018",
//		"2019",
//		"2020",
//	}
//	var total int
//	for _, year := range years {
//		data, err := ioutil.ReadFile(filepath.Join(resolvers.DataBaseSource, "nvdcve-1.1-"+year+".json"))
//		if err != nil {
//			t.Fatal(err)
//		}
//		var items = new(NVDVulnerabilityItems)
//		err = json.Unmarshal(data, items)
//		if err != nil {
//			t.Fatal(err)
//		}
//		total += len(items.CVEItems)
//	}
//
//	//spew.Dump(items)
//	fmt.Println("loaded", total, "CVEs in", time.Since(start))
//}

// nolint
// MITRE CVE Database
// https://cve.mitre.org

func vulnerabilitiesLookupTest(software *types.Software) *bleve.SearchResult {
	var (
		queryTerm          = software.Product + " " + software.Version
		query              = bleve.NewMatchQuery(queryTerm)
		search             = bleve.NewSearchRequest(query)
		searchResults, err = db.VulnerabilitiesIndex.Search(search)
	)
	if debugVulnerabilityTests {
		fmt.Println("searching for", queryTerm)
	}
	if err != nil {
		fmt.Println("failed to search for vulnerable software:", err)
		return nil
	}
	return searchResults
}

//func TestMitreVulnSearch(t *testing.T) {
//
//	// Load vulnerabilities DB index
//	var (
//		indexName = filepath.Join(resolvers.DataBaseSource, "mitre-cve.bleve")
//		err       error
//	)
//	vulnerabilitiesIndex, err = bleve.Open(indexName)
//	if err != nil {
//		t.Fatal(err)
//	}
//
//	software := &types.Software{
//		Timestamp:      "",
//		Product:        "Apache",
//		Vendor:         "",
//		Version:        "2.4.7",
//		DeviceProfiles: nil,
//		SourceName:     "",
//		DPIResults:     nil,
//		Service:        "",
//		Flows:          nil,
//		SourceData:     "",
//		Notes:          "",
//	}
//
//	searchResults := vulnerabilitiesLookupTest(software)
//	if searchResults == nil {
//		t.Fatal("no results")
//	}
//
//	//fmt.Println("search for ", software.Product, software.Vendor, software.Version)
//
//	for _, v := range searchResults.Hits {
//
//		var color string
//		doc, _ := vulnerabilitiesIndex.Document(v.ID)
//		if v.Score > thresholdMITRE {
//			color = ansi.Red
//		}
//		fmt.Println(color, "score", v.Score, &types.Vulnerability{
//			Timestamp:   software.Timestamp,
//			Software:    software,
//			Description: strings.Trim(string(doc.Fields[2].Value()), "\""),
//			ID:          string(doc.Fields[0].Value()),
//		}, ansi.Reset)
//	}
//}

/*
 * NVD - National Vulnerability Database
 * https://nvd.nist.gov
 */

func nvdVulnerabilitiesLookupTest(soft *types.Software) *bleve.SearchResult {
	var (
		queryTerm = buildNVDQuery(soft.Vendor, soft.Product, soft.Version)
		// queryTerm          = "+Description:\"Google Chrome\" +Versions:26.0.1410"
		query = bleve.NewQueryStringQuery(queryTerm)
		// query = bleve.NewMatchQuery("Google Chrome")
		search             = bleve.NewSearchRequest(query)
		searchResults, err = db.VulnerabilitiesIndex.Search(search)
	)
	if debugVulnerabilityTests {
		fmt.Println("searching for", queryTerm)
	}
	if err != nil {
		fmt.Println("failed to search for vulnerable software:", err)
		return nil
	}
	return searchResults
}

// can be used to test single queries over a new index schema from a separate path on the filesystem
func TestNVDVulnSearchIndexV2(t *testing.T) {
	// Load vulnerabilities DB index
	var (
		indexName = filepath.Join(resolvers.DataBaseFolderPath, "nvd.bleve")
		err       error
		soft      = &types.Software{
			Product: "PostgreSQL",
			Version: "9.1.0",
		}
	)
	db.VulnerabilitiesIndex, err = db.OpenBleve(indexName)
	if err != nil {
		t.Fatal(err)
	}
	defer db.CloseBleve(db.VulnerabilitiesIndex)

	if debugVulnerabilityTests {
		fmt.Println("lookup software", soft.Vendor, soft.Product, soft.Version)
	}
	searchResults := nvdVulnerabilitiesLookupTest(soft)
	if searchResults == nil {
		t.Fatal("no results")
	}

	if debugVulnerabilityTests {
		fmt.Println("numResults", len(searchResults.Hits))

		for _, v := range searchResults.Hits {

			var color string
			doc, _ := db.VulnerabilitiesIndex.Document(v.ID)
			if v.Score > ThresholdNVD {
				color = ansi.Red
			}
			fmt.Println(ansi.Yellow, v.ID, "score", v.Score, ansi.Reset)
			for i, f := range doc.Fields {
				fmt.Println(color, i, f.Name(), string(f.Value()), ansi.Reset)
			}
			fmt.Println("---------------------------------------------------------")
		}
	}
}

func TestNVDVulnSearch(t *testing.T) {
	// Load vulnerabilities DB index
	var (
		indexName = filepath.Join(resolvers.DataBaseFolderPath, "nvd.bleve")
		err       error
	)
	db.VulnerabilitiesIndex, err = db.OpenBleve(indexName)
	if err != nil {
		t.Fatal(err)
	}
	defer db.CloseBleve(db.VulnerabilitiesIndex)

	for _, s := range testSoftware {

		if debugVulnerabilityTests {
			fmt.Println("lookup software", s.Vendor, s.Product, s.Version)
		}
		searchResults := nvdVulnerabilitiesLookupTest(s)
		if searchResults == nil {
			t.Fatal("no results")
		}

		// fmt.Println("search for ", software.Product, software.Vendor, software.Version)

		if debugVulnerabilityTests {
			for _, v := range searchResults.Hits {

				var color string
				doc, _ := db.VulnerabilitiesIndex.Document(v.ID)
				if v.Score > ThresholdNVD {
					color = ansi.Red
				}
				fmt.Println(ansi.Yellow, v.ID, "score", v.Score, ansi.Reset)
				for i, f := range doc.Fields {
					fmt.Println(color, i, f.Name(), string(f.Value()), ansi.Reset)
				}
				fmt.Println("---------------------------------------------------------")
			}
		}
	}
}
